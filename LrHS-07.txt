    2ЛАБОРАТОРНАЯ РАБОТА 7.
    2ФУНКЦИОНАЛЫ-СВЁРТКИ НА СПИСКАХ. ПРОГРАММИРОВАНИЕ В СТИЛЕ ОРИГАМИ

 ш1.0
               1- Ты ведёшь себя не как исчислитель, а как пиит.
               1Нержин не удивился 0: 1 и "математик" и "поэт" были заме-
               1нены по известному чудачеству Сологдина  говорить  на
               1так называемом Языке Предельной Ясности,  не употреб-
               1ляя  _птичьих ., то есть иностранных, слов. 0
                                        1А.Солженицын. В круге первом
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Знать . 0:
 ш1.0
    1- понятия 0: " 1оригами 0", " 1оригамика 0" 1, 0  1"паттерн рекурсии", "свёртка" 0;
   - 1 принцип программирования в стиле оригами 0;
    1- 0  1функционалы свёртки в библиотеке Prelude 0;
    1- 0  1определение функций и функционалов 0  1с помощью свёртки foldr 0;
    1- 0  1определение функций и функционалов 0  1с помощью свёртки foldl 0;
    1- 0  1определение комбинатора неподвижной 0  1точки с помощью свёртки 0;
    1- 0  1функционал развёртки на списках.

 ш1.2
    _ 1Уметь . 0:
 ш1.0
   - реализовывать функции в стиле Haskell-оригами;
   - определять комбинатор неподвижной точки на языке Haskell с по-
мощью свёртки и использовать его для программирования.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                       2Вспомогательные понятия

 ш1.0
             1- Не понимаю, как можно жить, не прочитав Достоевского 0!
             1- Ну, жил же Пушкин 0!
                                                1Литературный анекдот
 ш1.2

                             21. 0  3Моноиды
   Пусть M - множество.
    2Определение 0.
 ш1.1
    2(1)  0[Голдблатт,1983,с.43]  _ 1Моноидом . 0 называется кортеж
 ш1.0

   (M,*, 3e 0),

 ш1.1
где *:M 52 0─ 76 0M, причём отображение * является ассоциативным, т.е. для
любых x,y,z 7е 0M
 ш1.0

   x*(y*z)=(x*y)*z.

 ш1.1
    _ 1Единицей моноида . 0 называется элемент  3e 7е 0M,  для которого для всех
x 7е 0M
 ш1.0

    3e 0*x=x, x* 3e 0=x.

 ш1.1
    2(2) 0 [Лаллеман,1985,с.16]  _ 1Моноид . 0 <M, 77 0,1> - это множество M с та-
кими бинарной операцией и выделенным элементом 1,  что (M, 77 0)  есть
 1полугруппа с единицей 0 1.

 ш1.2
                        22. 3 Оригами. Оригамика
   Японское слово " 1оригами 0" состоит из слов " 1свёртка 0" и " 1бумага 0".
    2Определение 0 ( 1описательное 0).
 ш1.1
    2(1) 0 (По [Хага,2012])  Под  _ 1оригами . 0 ( 1в Японии 0) обычно понимают ис-
кусство бумажных поделок,  увлечение в основном детское (почти  все
книги по оригами можно купить в детских отделах книжных магазинов).
    2(2) 0  _ 1Оригами . 0 - это цветные украшения или  фигурки,  сложенные  из
квадратного  листа  цветной  бумаги.  Результатом конструирования в
оригами являются бумажные фигурки животных, цветы, фрукты и т.д.
    2(3) 0  _ 1Оригами . 0 - это искусство бумажной  1скульптуры 0.

 ш1.2
    2Определение 0 ( 1конструктивное 0) 1  0[Комлев,2006].
 ш1.1
    _ 1Оригами . 0 (от яп.   1ori 0 -  1свёртка 0,   1kami - бумага 0) - это  старинное
японское искусство конструирования из бумаги разного рода изображе-
ний декоративного характера (путём  её   1перегибания 0,   1разрезания 0  и
 1комбинирования 0).

 ш1.2
    2Определение 0 (по [Хага,2012]).
 ш1.1
    _ 1Оригамика . 0 - это "оригамистическая"  1геометрия 0, для которой основ-
ным и практически единственным инструментом геометрических построе-
ний является  _ 1лист бумаги . 0.

 ш1.2
                        23. 0  3Паттерны рекурсии
   Вначале определим смысл термина " 1паттерн 0".
   По словам К.Александра (цит.  по  [Гамма,Хелм,Джонсон,Влиссидес,
2006,с.16]), "любой  1паттерн 0 описывает задачу, которая снова и снова
возникает в вашей работе,  а также принцип её решения, причём таким
образом,  что это решение можно потом использовать миллион раз, ни-
чего не изобретая заново".
   Итак, смысл паттерна - предложить решение определённой задачи  в
конкретном контексте.
   Хотя К.Александр имел в виду паттерны,  возникающие при проекти-
ровании зданий и городов,  но его слова верны и в отношении паттер-
нов в программировании.
    2Определение 0.
 ш1.1
    _ 1Паттерном рекурсии . 0 (от англ.   1pattern - шаблон 0,   1примитив 0,  1обра-
 1зец 0) назовём описание взаимодействия функций и функционалов функци-
онального языка программирования,  адаптированных (приспособленных)
для  1рекурсивного решения 0 некоторой задачи в конкретном контексте.

 ш1.2
    3Замечания 0 ( 1важные 0).
 ш1.1
    21. 0 Фрагмент программы, который один программист воспринимает как
 1паттерн рекурсии 0,  для другого программиста может  являться  просто
 1строительным блоком 0.
    22.  0Свёртка - это не единственный полезный паттерн рекурсии.
   Например [Bird,de Moor,1997],  1двойственный оператор 0 используется
в целях спецификации.
    23. 0 Некоторые экспериментальные языки программирования  показыва-
ют, что использование паттернов рекурсии является более эффективным
способом использования рекурсивных функций. Среди них выделим:
   (а) язык программирования Charity (Cockett & Fukushima,1992);
   (б) язык программирования PolyP (Jansson & Jeuring,1997);
   (в) алгебраический язык ADL (Kieburtz & Lewis,1994).
 ш1.2

                    2Функционалы свёртки в Prelude

 ш1.0
                                                1Стиль - это человек.
                                                   1Ж.Л.Бюффон 0 ( 11763 0)
 ш1.2

   Рассмотрим функционалы  языка программирования Haskell,  которые
являются паттернами рекурсии в функциональном  программировании;  к
таким функционалам относится " 1свёртка 0".
   Оператор свёртки  встречается  ещё  в теории рекурсивных функций
(С.Клини,1952), а также в языках программирования APL ( 1оператор ре-
 1дукции 0, К.Айверсон, 1962), и FP ( 1оператор вставки 0, Дж.Бэкус,1978).
    2Определение 0 (по [Кирпичёв,2009,с.156]).
 ш1.1
    _ 1Свёрткой . 0 ( 1в программировании 0) называется индуктивный процесс вы-
числения  _ 1снизу вверх . 0, применяющий в каждом узле некоторой  1структуры
 1данных 0  функцию,  соответствующую данному типу узла,  к содержимому
узла и результатам для его подузлов.

 ш1.2
   Приведём (неполный) список языков, в которых можно найти свертку
- непосредственно или с помощью дополнительных модулей и библиотек.
   Вместо слова fold в названиях функций и соответствующих операций
может употребляться reduce или accumulate:  2Clojure 0 (reduce),  2Common
 2Lisp 0 (reduce),  2C++ 0 (std::accumulate),  2Erlang 0 (foldl, foldr),  2Maxima
(lreduce, rreduce),  2OCaml 0 (List.fold_left, List.fold_right),  2Perl 5
(reduce),   2Perl 6 0 (reduction metaoperator),  2Python 0 (reduce, functo-
ols.reduce),   2Ruby 0  (enum.inject,  enum.reduce),   2Scala 0  (foldLeft,
foldRight,  reduceLeft,  reduceRight),   2Scheme   R6RS 0   (fold-left,
fold-right,  2Standard ML 0 (foldl, foldr).
                    21. 3 Свёртка справа на списках
   Функционал (от англ.   3fold 0 -  1свёртка 0,  3r 1ight 0 -  1справа 0), "сворачи-
вающий" заданный список с использованием бинарной функции и началь-
ного значения (свёртка производится  _ 1по ассоциации вправо . 0):
 ш1.0

    2foldr 0:: (a -> b -> b) -> b -> [a] -> b
    2foldr funct k lst

 ш1.2
   Например:
 ш1.0

   > foldr (+) 0 []        > foldr (-) 0 [1,2,3,4,5]
   0                       3

   > foldr (*) 4 [5,6,7]   > foldr min 10 [-1,2,13,-4,5]
   840                     -4

 ш1.2
   Название  1foldr 0 можно объяснить следующим образом.
   Рассмотрим список [a,b,c,d], который с помощью операции добавле-
ния элемента в начало списка запишем в виде
 ш1.0
   
   a : (b : (c : (d : []))).

 ш1.2
   Функционал foldr заменяет [] на некоторый начальный элемент e, а
операцию (:) на бинарную операцию, которую обозначим  7Х 0, и возвраща-
ет результат, т.е. она осуществляет следующее преобразование:
 ш1.0

   a : (b : (c : (d : []))) => a  7Х 0 (b  7Х 0 (c  7Х 0 (d  7Х 0 e))).

 ш1.2
   Так как операция (:) ассоциативна справа, то скобки в первом вы-
ражении можно было бы опустить.  Однако мы оставляем их в результи-
рующем выражении,  потому что операция  7Х 0 может быть неассоциативной
справа.
   Итак,  1денотационная семантика 0 функционала foldr представима либо
в инфиксной, либо в префиксной форме записи:
 ш1.0

   ┌────────────────────────────────────────────────────────────┐
   │ foldr ( 7Х 0) e [x 41 0,x 42 0,...,x 4n 0] = x 41 0  7Х 0 (x 42 0  7Х 0 (... (x 4n 0  7Х 0 e)...)) │
    1│                                                            │ 0,
   │ foldr f e [x 41 0,x 42 0,...,x 4n 0] = f x 41 0 (f x 42 0 (... (f x 4n 0 e)...)) 1   0 │
   └───────────────────────────────────────────────────────── 1── 0─┘

 ш1.2
где  7Х 0 - бинарная операция, f - функция с двумя аргументами, e - на-
чальное значение.
   Другими словами,  функционал foldr "сворачивает" список  в  одно
значение,  вставляя  1между 0 всеми элементами списка операцию  7Х 0, прод-
вигаясь при этом справа налево от заданного начального значения.
    2Пример 0.
 ш1.1
   Для списка, содержащего три элемента, последовательно получим:
 ш1.0

   foldr ( 7Х 0) e [] = e 4,

   foldr ( 7Х 0) e [x 41 0] = x 41 0  7Х 0 e,

   foldr ( 7Х 0) e [x 41 0,x 42 0] = x 41 0  7Х 0 (x 42 0  7Х 0 e),

   foldr ( 7Х 0) e [x 41 0,x 42 0,x 43 0] = x 41 0  7Х 0 (x 42 0  7Х 0 (x 43 0  7Х 0 e)).

 ш1.2
   Функционал " 1свёртка справа 0" для списков определён так:
 ш1.0

   foldr:: (a -> b -> b) -> b -> [a] -> b
   foldr f e []     = e
   foldr f e (x:xs) = f x (foldr f e xs)

 ш1.2
   Итак, foldr  f v,  используя функцию f::  a -> b -> b и значение
e:: b, обрабатывает список типа [a].
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1.

 ш1.2
    2Теорема 0 ( 1лёгкая 0).
 ш1.1
   Если операция  7Х 0 и функция e образуют  1моноид 0, то
 ш1.0

   foldr ( 7Х 0) e []             = e;
   foldr ( 7Х 0) e [x 41 0,x 42 0,...,x 4n 0] = x 41 7Х 0x 42 7Х 0... 7Х 0x 4n 0.

 ш1.2
    2Доказательство 0. Упражняйтесь.
    2Теорема 0 [Bird,Wadler,1988,p.69].
 ш1.1
    2(1) 0 Если  операция   7Х 0 и функция e образуют  1моноид 0,  то для любых
списков xs и ys
 ш1.0

   foldr ( 7Х 0) e (xs ++ ys) = (foldr ( 7Х 0) e xs)  7Х 0 (foldr ( 7Х 0) e ys

 ш1.1
    2(2) 0 Для произвольных f и e и для любых списков xs и ys
 ш1.0

   foldr f e (xs ++ ys) = foldr f (foldr f e ys) xs

 ш1.2
    2Доказательство 0. Упражняйтесь.
    3Замечание 0.
 ш1.1
   В языке  программирования  Python  работа с функционалом свёртка
синтаксически выглядит так (с использованием безымянных функций):
 ш1.0

   >>> reduce(lambda x,y: x+y,[1,2,3],0)
   6

 ш1.2
                22. 3 Свёртка справа на непустых списках
   Функционал, "сворачивающий" заданный непустой список с использо-
ванием бинарной функции,  в качестве  начального  значения  берётся
первый элемент списка (свёртка производится  _ 1по ассоциации вправо . 0):
 ш1.0

    2foldr1 0:: (a -> a -> a) -> [a] -> a
    2foldr1 funct lst

 ш1.2
   Например:
 ш1.0

   > foldr1 (-) [1,2,3,4,5]      > foldr1 (*) [5,6,7]
   3                             210

   > foldr1 min [-1,2,-13,-4,5]
   -13

 ш1.2
   Итак,  1денотационная семантика 0 функционала foldr1 представима ли-
бо в инфиксной, либо в префиксной форме записи:
 ш1.0

   ┌──────────────────────────────────────────────────────────────┐
   │ foldr1 ( 7Х 0) [x 41 0,x 42 0,...,x 4n 0] = x 41 0  7Х 0 (x 42 0  7Х 0 (... (x 4n-1 0  7Х 0 x 4n 0)...)) │
    1│                                                              │ 0,
   │ foldr1 f [x 41 0,x 42 0,...,x 4n 0] = f x 41 0 (f x 42 0 (... (f x 4n-1 0 x 4n 0)...))  1   0│
   └─────────────────────────────────────────────────────────── 1── 0─┘

 ш1.2
где  7Х 0 - бинарная операция, f - функция с двумя аргументами.
                     23. 3 Свёртка слева на списках
   Функционал (от англ.  3fold 0 -  1свёртка 0,  3l 1eft 0 -  1слева 0), "сворачиваю-
щий" заданный список с использованием бинарной функции и начального
значения (свёртка производится  _ 1по ассоциации влево . 0):
 ш1.0

    2foldl 0:: (a -> b -> a) -> a -> [b] -> a
    2foldl funct k lst

 ш1.2
   Например:
 ш1.0

   > foldl (+) 0 []        > foldl (-) 0 [1,2,3,4,5]
   0                       -15

   > foldl (*) 4 [5,6,7]   > foldl max 10 [-1,2,13,-4,5]
   840                     13

 ш1.2
    1Денотационная семантика 0 функционала foldl такова:
 ш1.0

   ┌────────────────────────────────────────────────────────────┐
   │ foldl ( 7Х 0) e [x 41 0,x 42 0,...,x 4n 0] = (...((e  7Х 0 x 41 0)  7Х 0 x 42 0) ...)  7Х 0 x 4n 0 │,
   └────────────────────────────────────────────────────────────┘

 ш1.2
где  7Х 0 - бинарная операция, e - начальное значение.
   Заметим, что  если e - ассоциативная единица для операции  7Х 0,  то
foldr ( 7Х 0) e и foldl ( 7Х 0) e определяют одну и ту же функцию на конеч-
ных списках.
    2Пример 0.
 ш1.1
   Разберём подробно процесс применения foldl к заданному списку:
 ш1.0

   foldl ( 7Х 0) [a,b,c] = foldl ( 7Х 0) (e  7Х 0 a) [b,c] =
                     = foldl ( 7Х 0) ((e  7Х 0 a)  7Х 0 b) [c] =
                     = foldl ( 7Х 0) (((e  7Х 0 a)  7Х 0 b)  7Х 0 c) [] =
                     = ((e  7Х 0 a)  7Х 0 b)  7Х 0 c).

 ш1.2
   В языке Haskell функционал " 1свёртка слева 0" для списков определён
следующим образом:
 ш1.0

   foldl:: (b -> a -> b) -> b -> [a] -> b
   foldl f e []     = e
   foldl f e (x:xs) = foldl f (f e x) xs

 ш1.2
   Итак, foldl f e обрабатывает элементы списка  типа [a]  _ 1слева на-
 _ 1право . 0 с  использованием  функции  f::  b -> a -> b (для объединения
значений), и значение e:: b в качестве начального значения.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1.

 ш1.2
    2Теорема 0 [Bird,Wadler,1988,p.69].
 ш1.1
   Для произвольных f и e и для любых списков xs и ys
 ш1.0

   foldl f e (xs ++ ys) = foldl f (foldr f e xs) ys

 ш1.2
    2Доказательство 0. Упражняйтесь.
    3Замечание 0 ( 1для знатоков нумералов в  7l 1-исчислении 0).
 ш1.1
   Представление натурального числа в   7l 0-исчислении  заключается  в
неявном использовании свёртки.
   Например, число 3 представляется  7l 0-термом f(f(f0)) или в Haskell
 ш1.0

   succ (succ (succ 0)).

   Последняя функция представима следующей свёрткой:

   nat n = foldr1 f (replicate 1 n)
         where f = const . succ 

 ш1.2
                24. 3 Свёртка слева на непустых списках
   Функционал, "сворачивающий" заданный непустой список с использо-
ванием бинарной функции,  в качестве  начального  значения  берётся
первый элемент списка (свёртка производится  _ 1по ассоциации влево . 0):
 ш1.0

    2foldl1 0:: (a -> a -> a) -> [a] -> a
    2foldl1 funct lst

 ш1.2
   Например:
 ш1.0

   > foldl1 (-) [1,2,3,4,5]       > foldl1 (*) [5,6,7]
   -13                            210

   > foldl1 min [-1,2,-13,-4,5]
   -13

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   Функционал свёртки представляет собой  1паттерн рекурсии 0,  поэтому
для других рекурсивно определённых структур данных достаточно заме-
нить конструкторы [] и (:) другими значениями и функциями.

 ш1.2
    2Пример 0.
 ш1.1
   Построим функцию,  которая позволяет проследить, как конструиру-
ется результат выполнения правых и левых свёрток:
 ш1.0

   paren :: String -> String -> String
   paren x y = concat ["(",x," * ",y,")"]

 ш1.1
   Теперь рассмотрим функции:
 ш1.0

   test1 = foldr  paren "1" ["a","b","c","d"]
   test2 = foldl  paren "1" ["a","b","c","d"]
   test3 = foldr1 paren     ["a","b","c","d"]
   test4 = foldl1 paren     ["a","b","c","d"]

 ш1.1
   В результате вызова функций test1,  test2,  test3 и test4  соот-
ветственно получим:
 ш1.0

   "(a * (b * (c * (d * 1))))"
   "((((1 * a) * b) * c) * d)"
   "(a * (b * (c * d)))"
   "(((a * b) * c) * d)"
 ш1.2

                 3Теоремы двойственности для свёрток

 ш1.0
                1Планируя грядки на следующую весну, учтите главное -
                1там, где росли вершки, посадите корешки, и наоборот.
                                                       1Дачные советы
 ш1.2

    2Теорема 0 ( 1первая теорема двойственности для свёрток 0)
           [Bird,Wadler,1988,p.68].
 ш1.1
   Если операция   7Х 0  и  функция e образуют  1моноид 0,  а xs - конечное
множество, то
 ш1.0

   foldr ( 7Х 0) e xs = foldl ( 7Х 0) e xs.

 ш1.2
    2Доказательство 0. Упражняйтесь.
   Итак, свёртки  foldr  и foldl определяют одну и ту же функцию на
моноиде.
   Однако иногда более эффективным является использование foldr,  а
иногда - foldl.  Например, более эффективно использование foldl для
представления функций  sum  и product,  а для представления функций
concat, and и or более эффективно использование foldr.
    2Теорема 0 ( 1вторая теорема двойственности для свёрток 0)
           [Bird,Wadler,1988,p.68].
 ш1.1
   Если операции  7Х 0,  7х 0 и функция e таковы, что
 ш1.0

   (а)  7А 0x 7А 0y 7А 0z(x 7Х 0(y 7х 0z)=(x 7Х 0y) 7х 0z);  (б)  7А 0x(x 7Х 0e=e 7х 0x),

то для любых конечных списков xs

   foldr ( 7Х 0) e xs = foldl ( 7х 0) e xs.

 ш1.2
    2Доказательство 0. Упражняйтесь.
   Первая теорема двойственности следует из первой, если операции  7Х
и  7х 0 совпадают.
    2Пример 0 ( 1иллюстрация второй теоремы двойственности 0).
 ш1.1
   Рассмотрим определения функций length и reverse с помощью foldr
и foldl:
 ш1.0

   reverse' =  3foldr 0  7Х 41 0 e           ║  reverse' =  3foldl 0  7х 41 0 e
      where  7Х 41 0 = \x xs -> xs++[x]  ║     where  7х 41 0 = \ys x -> x:ys
            e 41 0 = []                ║           e 41 0 = []
                                   ║
   length' =  3foldr 0  7Х 42 0 e            ║  length' =  3foldl 0  7х 42 0 e
      where  7Х 42 0 = \x n -> n + 1     ║     where  7х 42 0 = \n x -> n + 1
            e 42 0 = 0                 ║           e 42 0 = 0

   Далее, очевидно, что

    7Х 41 ═+ 0(++),  7х 41 ═+ 0flip (:),  7Х 42 ═+ 0(+),  7х 42 ═+ 0(+), e 41 ═+ 0[], e 42 ═+ 00.

 ш1.1
   Остаётся проверить выполнимость условий  второй  теоремы  двойс-
твенности свёрток:
 ш1.0

   x 7Х 41 0(y 7х 41 0z)=(x 7Х 41 0y) 7х 41 0z => flip (:) (x++y) z = flip (:) (x++y) z =>

        => z : (x++y) = z : (x++y);

   x 7Х 41 0e 41 0=e 41 7х 41 0x => x++[] = flip (:) [] x => x++[] = x:[] => x = x;

   x 7Х 42 0(y 7х 42 0z)=(x 7Х 42 0y) 7х 42 0z => x+(y+z)=(x+y)+z => x+y+z=x+y+z,

   x 7Х 42 0e 42 0=e 42 7х 42 0x => x+0=0+x.

 ш1.2
    2Теорема 0 ( 1третья теорема двойственности для свёрток 0)
           [Bird,Wadler,1988,p.68-69].
 ш1.1
   Если  7Х 0 и  7Х 0~ - операции, удовлетворяющие условию
 ш1.0

   x 7Х 0~y=y 7Х 0x,

то для любых конечных списков xs

   foldr ( 7Х 0) e xs = foldl ( 7х 0~) e (reverse xs).

 ш1.2
    2Доказательство 0. Упражняйтесь.
    2Пример 0 ( 1иллюстрация третьей теоремы двойственности 0).
 ш1.1
   Рассмотрим определения функции plusPlus с помощью foldr и foldl:
 ш1.0

   plusPlus = flip $  3foldr 0 (:),                               (*)

   plusPlus xs ys =  3foldl 0 (flip (:)) ys (reverse xs).         (**)

 ш1.1
   Выполним эквивалентные преобразования равенства  (*)  с  помощью
алгебры комбинаторов:
 ш1.0

   plusPlus xs ys = flip $  3foldr 0 (:) xs ys =

      = flip ( 3foldr 0 (:)) xs ys =  3foldr 0 (:) ys xs.

   Сравнивая полученный результат с равенством (**), получим:

    7Х ═+ 0(:),  7Х ═+ 0flip (:).

 ш1.1
   Остаётся проверить выполнимость условия третьей  теоремы  двойс-
твенности:
 ш1.0

   x 7Х 0~y=y 7Х 0x => x:y = flip (:) y x = x:y.

 ш1.2
    3Замечание 0.
 ш1.1
   Используя теоремы двойственности для свёрток,  мы можем выразить
с помощью свёртки foldl многие функции, увеличивая их эффективность.
 ш1.2

                    3Законы объединения для свёртки

 ш1.0
                            1Ум - качество не скалярное, а векторное.
                                                             1Дж.Блох
 ш1.2

    21. 3  _ 1Законы fold-объединения . 0.
    2Теорема 0 [Bird,1998,p.131] ( 1закон объединения для foldr 0).
 ш1.1
   Если функция f является строгой, f a = b и f (g x y) = h x (f y)
для всех x и y, то
 ш1.0

   f .  3foldr 0 g a =  3foldr 0 h b

 ш1.2
    2Доказательство 0. Упражняйтесь.
    2Теорема 0 [Bird,1998,p.131] ( 1закон объединения для foldl 0).
 ш1.1
   Если функция f является строгой, f a = b и f (g x y) = h (f x) y
для всех x и y, то
 ш1.0

   f .  3foldl 0 g a =  3foldl 0 h b

 ш1.2
    2Доказательство 0. Упражняйтесь.
    22. 3  _ 1Законы fold-map объединения
    2Теорема 0 [Bird,1998,p.132; Gibbons,2003,p.43]
           ( 1foldr-map объединение 0).
 ш1.0

    3foldr 0 f e .  3map 0 g =  3foldr 0 (f . g) e

 ш1.2
    2Доказательство 0. Упражняйтесь.
    2Теорема 0 [Bird,Wadler,1988,p.72] ( 1foldl-map объединение 0).
 ш1.1
   Если x 7х 0y=x 7Х 0f y, то
 ш1.0

    3foldl 0 ( 7Х 0) a .  3map 0 f =  3foldl 0 ( 7х 0) a

 ш1.2
    2Доказательство 0. Получается  из  foldr-map объединения и одной из
теорем двойственности ( 1какой 0?), а также из утверждения
 ш1.0

   map f . reverse = reverse . map f

 ш1.2
    1Теорема доказана 0.
    23. 3  _ 1Закон fold-concat объединения
    2Теорема 0 [Bird,1998,p.132] ( 1foldr-concat объединение 0).
 ш1.0

    3foldr 0 f e .  3concat 0 =  3foldr 0 (flip ( 3foldr 0 f)) e

 ш1.2
    2Доказательство 0. Упражняйтесь.
    24. 3  _ 1Закон fold-map-concat объединения
    2Теорема 0 [Bird,1998,p.132-133] ( 1fold-map-concat объединение 0).
 ш1.1
   Если функция f является ассоциативной, e - единица, то
 ш1.0

    3foldr 0 f e .  3concat 0 =  3foldr 0 f e .  3map 0 ( 3foldr 0 f e)

 ш1.2
    2Доказательство 0. Упражняйтесь.
    25. 3  _ 1Законы fold-scan-объединения
    2Теорема 0 [Bird,1998,p.134] ( 1foldr-scan объединение 0).
 ш1.1
   Если операция  7х 0 является ассоциативной с единицей e и операция  7х
дистрибутивна относительно операции  7Х 0, то
 ш1.0

    3foldr1 0 ( 7Х 0) .  3scanl 0 ( 7х 0) e =  3foldr 0 ( ═* 0) e
      where x  ═* 0 y = e  7Х 0 (x  7х 0 y)

 ш1.2
    2Доказательство 0. Упражняйтесь.
    2Теорема 0 [Bird,1998,p.137] ( 1foldl-scan объединение 0).
 ш1.1
   Если операции  ═* 0,  7Х 0,  7х 0 таковы, что (x,y) ═* 0z=(x 7Х 0(y 7х 0z),y 7х 0z), то
 ш1.0

    3foldl1 0 ( 7Х 0) .  3scanl 0 ( 7х 0) e = fst .  3foldl 0 ( ═* 0) (a,a)

 ш1.2
    2Доказательство 0. Упражняйтесь.

                      2Функционалы-конструкторы

 ш1.0
            1В области мысли,  при постоянном умственном общении вряд
            1ли  можно  точно разграничить,  что принадлежит одному и
            1что другому.  Зато каждый имеет удовлетворение и радость
            1сознавать своё участие в общем результате.
                 1И.П.Павлов. Из предисловия к книге "Лекции о работе
                             1больших полушарий головного мозга"
 ш1.2

   Приведём функционалы из библиотеки Prelude,  с  помощью  которых
легко описывается операционная семантика функционалов-свёрток.
                    21. 3 Функционалы scanl и scanl1
    2А. 0 Функционал 2   0scanl  применяет  бинарный  оператор к начальному
значению и к каждому последующему элементу заданного списка, форми-
руя при этом список промежуточных результатов:
 ш1.0

    2scanl 0:: (a -> b -> a) -> a -> [b] -> [a]
    2scanl 0  2funct k lst

 ш1.2
   Например:
 ш1.0

   > scanl (+) 0 [1,2,3,4,5]           > scanl (*) 2 [5,6,7]
   [0,1,3,6,10,15]                     [2,10,60,420]

   > scanl min (-5) [-1,2,-13,-4,-6]
   [-5,-5,-5,-13,-13,-13]

 ш1.2
    2Теорема 0.
 ш1.0

    2(1) 0 last . scanl f e = foldl f e;

    2(2) 0 [Bird,1998,p.124]
       scanl f e = map (foldl f e) . inits

 ш1.2
    2Доказательство 0. Упражняйтесь.
    2Б. 0 Функционал scanl1 применяет бинарный оператор к "голове"  за-
данного  непустого  списка  и  к каждому последующему его элементу,
формируя при этом список промежуточных результатов:
 ш1.0

    2scanl1 0:: (a -> a -> a) -> [a] -> [a]
    2scanl1 0  2funct lst

 ш1.2
   Например:
 ш1.0

   > scanl1 (+) [1,2,3,4,5]   > scanl1 (*) [5,6,7]
   [1,3,6,10,15]              [5,30,210]

   > scanl1 min [-1,2,-13,-4,-6]
   [-1,-1,-13,-13,-13]

 ш1.2
                    22. 3 Функционалы scanr и scanr1
    2А. 0 Функционал scanr применяет  бинарный  оператор  к  начальному
значению и к каждому последующему элементу заданного списка;  полу-
ченный результат записывается в формируемый список.
   Далее бинарный  оператор применяется к каждому последующему эле-
менту "хвоста" списка. Результат также записывается в список.
   Процесс продолжается  до  тех  пор,  пока хвост списка не станет
пустым; в этом случае возвращается исходное начальное значение:
 ш1.0

    2scanr 0:: (a -> b -> b) -> b -> [a] -> [b]
    2scanr 0  2funct k lst

 ш1.2
   Например:
 ш1.0

   > scanr (+) 0 [1,2,3,4,5]            > scanr (*) 2 [5,6,7]
   [15,14,12,9,5,0]                     [420,84,14,2]

   > scanr min (-5) [-1,2,-13,-4,-6]    > scanr (-) 0 [1,2,3,4,5]
   [-13,-13,-13,-6,-6,-5]               [3,-2,4,-1,5,0]

 ш1.2
    2Теорема 0 [Bird,1998,p.125].
 ш1.0

   scanr f e = map (foldr f e) . tails

 ш1.2
    2Доказательство 0. Упражняйтесь.
    2Б. 0 Функционал scanr1 применяет бинарный  оператор  к  последнему
элементу  заданного  непустого  списка и к каждому последующему его
элементу,  начиная с предпоследующего. Полученный результат записы-
вается в формируемый список.
   Далее бинарный  оператор применяется к каждому последующему эле-
менту хвоста списка и результаты также записываются в список.
   Процесс продолжается до тех пор, пока хвост списка не станет од-
ноэлементным; в этом случае возвращается оставшийся элемент списка:
 ш1.0

    2scanr1 0:: (a -> a -> a) -> [a] -> [a]
    2scanr1 0  2funct lst

 ш1.2
   Например:
 ш1.0

   > scanr1 (+) [1,2,3,4,5]        > scanr1 (*) [5,6,7]
   [15,14,12,9,5]                  [210,42,7]

   > scanr1 min [-1,2,-13,-4,-6]
   [-13,-13,-13,-6,-6]

 ш1.2
    3Замечание 0.
 ш1.1
   Фактически функционалы  scanl и scanr реализуют своеобразную  1ме-
 1моизацию 0.
   Напомним, что  _ 1мемоизация . 0 [Орлов,2013,с.91] - это специальная оп-
тимизационная методика программирования,  которая позволяет  увели-
чить  скорость  выполнения  компьютерных программ и заключающаяся в
том,  чтобы исключить повторное вычисление  результатов  предыдущих
вызовов процедур и функций.
 ш1.2

                 2Определение функций и функционалов
                          2с помощью свёртки

 ш1.0
                               1Ладно, я покажу им, как это делается.
                                                  1Эдуард Мане 0 ( 11862 0)
 ш1.2

    2Определение 0.
 ш1.1
    2(1) 0  _ 1Программирование в стиле оригами . 0 - это  технология  функцио-
нального программирования, в которой:
   (а) ( 1fold-стиль 0,   1cata-стиль 0) некоторые используемые функции (не
обязательно все),  представлены в виде следующего паттерна, исполь-
зующего свёртку:
 ш1.0

   func ... lst = 3 foldr 0  ═f 0 e lst  ║  length' lst = foldr f e lst
      where  ═f 0 a b = ...          ║     where f x n = 1 + n
            e     = ...          ║           e     = 0

 ш1.1
   При этом вместо  3foldr 0 могут использоваться  3foldl 0, 3 foldr1 0,  3foldl1 0;
   (б) ( 1unfold-стиль 0,  1ana-стиль 0) некоторые используемые функции (не
обязательно все),  представлены в виде следующего паттерна, исполь-
зующего развёртку:
 ш1.0

   func ... x = 3 unfold 0 p  ═f 0 g x  ║  infinity = unfold p f g 1
      where p x = ...           ║      where p = \x -> False
             ═f 0 x = ...           ║            f = id
            g x = ...           ║            g = succ

 ш1.1
   (в) ( 1fold-unfold-стиль 0,  1hylo-стиль 0) некоторые используемые функ-
ции (не обязательно все),  представлены в виде паттерна, использую-
щего свёртку и развёртку:
 ш1.0

   func ... x = 3  0( 3foldr 0  ═f 41 0 e .  3unfold 0 p  ═f 42 0 g) x
      where  ═f 41 0 a b = ...
            e      = ...
            p x    = ...
             ═f 42 0 x   = ...
            g x    = ...

 ш1.1
   (г) ( 1unfold-fold-стиль 0)  некоторые используемые функции (не обя-
зательно все),  представлены в виде паттерна, использующего свёртку
и развёртку:
 ш1.0

   func ... x = 3  0( 3unfold 0 p  ═f 42 0 g .  3foldr 0  ═f 41 0 e) x
      where p x    = ...
             ═f 42 0 x   = ...
            g x    = ...
             ═f 41 0 a b = ...
            e      = ...

 ш1.1
   (д) ( 1fix-fold-стиль 0) некоторые используемые функции  (не  обяза-
тельно все), представлены в виде паттерна, использующего свёртку:
 ш1.0

   func ... x =  3foldr 0 f e x
       where f = \_ -> g
             e = undefined
             g = ...

 ш1.1
   Здесь функция g является нерекурсивной "заготовкой",  полученной
из рекурсивного определения функции func;

 ш1.1
   (е) большинство используемых в программе функций (или все) конс-
труируются  с  помощью  функционалов " 1свёртка 0" и " 1развёртка 0" в виде
паттернов, рассмотренных в пп. (а)-(д).
    2(2) 0  _ 1Haskell-оригами . 0 будем называть программирование в стиле ори-
гами на языке Haskell.

 ш1.2
    3Замечание 0.
 ш1.1
   Стиль foldr-unfoldr  хорошо подходит для языков программирования
с отложенными вычислениями,  поскольку в связке fold-unfold функции
свёртки и развёртки работают синхронно,  т.е.  функция развёртки не
производит новых элементов до тех пор,  пока они не понадобятся  во
внешней функции свёртки.

 ш1.2
                 21. 3 Использование функционала foldr
   Вначале напомним,  что применение инфиксной операции  7Х 0 в круглых
скобках ( 7Х 0) преобразует операцию в префиксную  форму.  Этот  приём,
называемый   _ 1секционированием . 0,  часто  является  полезным при записи
простых функций с использованием свёртки.  (Если требуется, то один
из аргументов операции может быть также заключён в круглые скобки).
   Далее отметим, что функции, написанные с использованием свёртки,
являются  _ 1менее удобочитаемыми . 0,  чем функции, написанные с использо-
ванием явной рекурсии. Однако программы, написанные с использовани-
ем foldr, более удобны для:
   (а) эквивалентных (тождественных) преобразований функций;
   (б) доказательства свойств функций.
    21. 0 Ряд функций,  действующих на списках, могут быть легко реали-
зованы с использованием свёртки:
 ш1.0

   sum':: [Int] -> Int     1  0 ║  product':: [Int] -> Int
   sum' = foldr (+) 0      1  0 ║  product' = foldr (*) 1
   ----------------------- 1- 0--------------------------
   and':: [Bool] -> Bool   1  0 ║  or':: [Bool] -> Bool
   and' = foldr (&&) True  1  0 ║  or' = foldr (||) False
   ----------------------- 1- 0--------------------------
   concat:: [[a]] -> [a]   1  0 ║  head:: [a] -> a
   concat = foldr (++) []  1  0 ║  head = foldr const (error "Empty")
   ------------------------ 1- 0-------------------------------------
   (++):: [a] -> [a] -> [a]
   (++) ys    = foldr (:) ys
   -------------------------
   (++):: [a] -> [a] -> [a]
   xs (++) ys = foldr (:) ys xs

 ш1.2
   В приведённых примерах конструктор (:) заменён некоторой  встро-
енной  функцией.  Однако,  в большинстве случаев применения свёртки
конструктор (:) заменяется функциями, определёнными пользователем и
реализованными с использованием  7l 0- _ 1абстракции . 0.
   Например:
 ш1.0

   length':: [a] -> Int
   length' = foldr (\x n -> 1 + n) 0
   ---------------------------------
   reverse':: [a] -> [a]
   reverse' = foldr (\x xs -> xs ++ [x]) []

 ш1.2
    22. 0 Реализуем с помощью свёртки часто встречающиеся  1функционалы 0.
 ш1.0

   map':: (a -> b) -> [a] -> [b]
   map' f = foldr (\x xs -> f x : xs) []
   -------------------------------------
   map'' f = foldr ((:) f) []

 ш1.2
   Интересно (!?),  что определение map' с  использованием  свёртки
может быть построено из обычного рекурсивного определения.
 ш1.0

   filter':: (a -> Bool) -> [a] -> [a]
   filter' p = foldr (\x xs -> if p x then x : xs else xs) []

 ш1.2
   Выражение функций и функционалов с помощью функционала foldr бы-
вает настолько  нетривиальным,  что,  например,   1Р.Бёрд 0 [Bird,1998,
с.121] писал,  что функционал zip  невозможно  выразить  с  помощью
foldr: "Not  every  function on lists can be defined as an instance
of  1foldr 0.  For example,   1zip 0 cannot be so defined.  Even for  those
that can, an alternative definition may be more efficient."
   Однако впоследствии он указал вариант представления:
 ш1.0

   zip' = foldr f e
       where e ys         = []
             f x g []     = []
             f x g (y:ys) = (x,y) : g ys

 ш1.2
   Функционал dropWhile нельзя выразить с помощью свёртки foldl та-
ким образом,  чтобы он корректно "работал" для всех списков (в  том
числе и для бесконечных). Однако имеется следующее представление:
 ш1.0

   dropWhile' p xs = foldr f id xs xs
        where f x g xs@(_:ys) | p x  = g ys
                              | True = xs

 ш1.2
   Выразим с помощью foldr свёртку foldl:
 ш1.0

   foldl':: (a -> b -> a) -> a -> [b] -> a
   foldl' f s xs = foldr (\x g -> (\a -> g (f a x))) id xs s
   ---------------------------------------------------------
   foldl'' f s xs = foldr (\a -> (. flip f a)) id xs s
   foldl''' f = flip (foldr (\a -> (. flip f a)) id)

 ш1.2
    23. 0 Построим функцию  compose,  которая  конструирует  композицию
функций  из заданного списка функций:  воспользуемся свёрткой с по-
мощью замены каждого конструктора (:) в  списке,  функцией  (.),  а
пустой список [] - стандартной функцией id:
 ш1.0

   compose':: [a -> a] -> a -> a
   compose' = foldr (.) id

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   Пример 2.

 ш1.2
    1Правая свёртка на списках 0 используется, когда известно, как  со-
ставить результат для всего списка из его "головы" и результата для
"хвоста", причём часть результата известна и без полного результата
для "хвоста", т.е. вычисляется лишь на основе "головы" (например, в
случае map или filter).
                 22. 3 Использование функционала foldl
   Приведём примеры представления функций с помощью foldl:
 ш1.0

   sum'  = foldl (+) 0
   sum'' = foldl (\x y -> x+y) 0
   -----------------------------
   concat = foldl (++) []        ( 1Медленная реализация 0!)
   ----------------------
   reversel:: [a] -> [a]
   reversel = foldl (\xs x -> x:xs)
                    []
   ----------------------        ║
   reversel':: [a] -> [a]        ║  flip (:) xs x = (:) x xs =
   reversel' = foldl (flip (:))  ║           = x:xs = \xs x -> x:xs
                     []          ║

 ш1.2
   Определение функции reversel позволяет обратить список  _ 1за линей-
 _ 1ное время . 0 (т.е. алгоритм имеет эффективность  7O 0(n)).
   Для "обоснования"  воспользуемся  интерпретатором  Haskell в ка-
честве "песочницы":
 ш1.0

   > reversel [1..100] =>  4546 cells
   > reversel [1..200] =>  9046 cells
   > reversel [1..400] => 18046 cells
   > reversel [1..800] => 36046 cells

 ш1.2
   Итак, последняя функция предпочтительнее, чем запись с использо-
ванием foldr:
 ш1.0

   reverse' = foldr (\x xs -> xs ++ [x]) [],

 ш1.2
т.к. в этом случае многократно используется операция ++.
   Выразить свёртку foldr через foldl  _ 1невозможно . 0,  т.к. foldl опре-
деляется строго в хвосте списка своих аргументов, а foldr - нет.
                3Работа с демонстрационными примерами
 ш1.1
   Пример 3, Пример 4.

 ш1.2
    1Левая свёртка на списках 0 используется, когда алгоритм выражается
в виде правой свёртки,  если список перевернуть.  Эта разновидность
свёртки используется редко.
   Наконец ( 1для знатоков строгой аппликации 0),  1строгая левая свёртка
используется, когда алгоритм выражается в виде императивного цикла.
    3Замечание 0 ( 1важное 0) (см. [Bird,1998]).
 ш1.1
   Существуют рекомендации,  помогающие  определить,  какая свёртка
лучше подходит для решения конкретной задачи.
 ш1.2

                3Моделирование комбинатора неподвижной
                         3точки в foldr-стиле

 ш1.0
             1Ни рука, ни интеллект, предоставленный себе, многого не
             1стоят 0: 1 дело совершается при помощи орудий и средств.
                                                             1Ф.Бэкон
 ш1.2

   Использование свёртки в качестве комбинатора  неподвижной  точки
берёт начало из теоретико-категорной работы [Freyd,1990], в которой
показано, что такой комбинатор может быть выражен в виде композиции
 1катаморфизма 0 и  1анаморфизма 0.
   В работе [Meijer,Hutton,1995] эти результаты переводятся на язык
функционального  программирования  и формулируются для произвольных
алгебраических типов данных.
   Итак, свёртку  можно  использовать в качестве комбинатора непод-
вижной точки; другими словами, можно написать функцию, моделирующую
комбинатор неподвижной точки Y с помощью функционала foldr:
 ш1.0

   fix = \f ->  3foldr 0 (\_ -> f) undefined (repeat undefined)

 ш1.2
   Теперь (как  всегда!)  с  помощью y' можно выполнить необходимое
количество вызовов  1нерекурсивной функции 0, моделируя рекурсию.
    2Пример 0.
 ш1.1
   Комбинатор неподвижной  точки  помогает  построить   рекурсивную
функцию  из  нерекурсивных  "заготовок",  полученных из рекурсивных
функций:
 ш1.0

   foldr' f e []     = e              foldr''  _f1 . f e []     = e
   foldr' f e (x:xs) =            =>  foldr''  _f1 . f e (x:xs) =
             x `f` foldr' f e xs                x `f`  _f1 . f e xs

   foldl' f e []     = e          =>  foldl''  _f1 . f e []     = e
   foldl' f e (x:xs) =                foldl''  _f1 . f e (x:xs) =
             foldl' f (e `f` x) xs               _f1 . f (e `f` x) xs

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 5.

 ш1.2
   Итак, зная рекурсивную схему для функции  ═f 0 можно  построить  для
неё нерекурсивную "заготовку" - функцию  ═f 5* 0,  а далее для вычисления
значений функции f пользоваться функцией fix  ═f 5* 0.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 5 41 0.

 ш1.2
   Заметив, что с помощью развёртки  легко  получается  бесконечный
список [1..]:
 ш1.0

   infinity = unfold (\x -> False) id succ 1,

 ш1.2
получим следующее представление в fold-unfold-стиле:
 ш1.0

   y = \f ->  3foldr 0 (\_ -> f) undefined
                   ( 3unfold 0 (\x -> False) id succ 1)

 ш1.2
   Впрочем, на практике выражение рекурсивных  функций  в  терминах
свёртки вряд ли полезно: ясно, что замена рекурсии на свёртку может
привести к значительному усложнению кода.
    3Замечание 0 ( 1важное 0).
 ш1.1
   Теоретический интерес представляют выражения комбинатора  непод-
вижной точки в  1foldl- 0 и в  1unfold-стиле 0.
 ш1.2

                      3Сбалансированная свертка

 ш1.0
               1Часть работы программиста состоит в том, чтобы решать
               1сегодняшние  задачи.  Другая,  возможно более важная,
               1состоит в подготовке к решению завтрашних задач. 0
                                                          1Дж. Бентли
 ш1.2

   Для ассоциативных операций результаты вычисления выражений
 ш1.0

   foldr (+) [a 41 0...a 4n 0] = a 41 0+(a 42 0+...+(a 4n-1 0+a 4n 0)...),

   foldl (+) [a 41 0...a 4n 0] = (...(a 41 0+a 42 0)+...)+a 4n

 ш1.2
совпадают. Более того,  расставляя скобки произвольным образом,  мы
будем получать все тот же результат.
   Другими словами,  можно абстрагироваться от порядка вычислений и
говорить об "абстрактной" свертке как о результате выражения
 ш1.0

   fold (+) [a 41 0...a 4n 0] = a 41 0+a 42 0+...+a 4n

 ш1.2
безотносительно к порядку выполнения операций.
   Теперь мы можем конкретизировать эту абстракцию, установив опре-
делённый порядок вычислений.
   Например, определим  _ 1сбалансированную . 0 ( _ 1древесную . 0)  _ 1свёртку . 0, произ-
водящую вычисления в таком порядке
 ш1.0

   foldb (+) [a 41 0...a 4n 0] = (...((a 41 0+a 42 0)+(a 43 0+a 44 0))+(...(a 4n-1 0+a 4n 0)...).

 ш1.2
   Сбалансированную свёртку  можно  выполнять  в направлении сверху
вниз:
 ш1.0

   foldb f [x] = x
   foldb f xs  = f (foldb f (take (length xs `div` 2) xs))
                   (foldb f (drop (length xs `div` 2) xs))

или в направлении снизу вверх:

   foldb' f [x] = x
   foldb' f xs  = foldb' f (pair f xs)
   -----------------------------------
   pair f []         = []
   pair f [x]        = [x]
   pair f (x1:x2:xs) = f x1 x2 : pair f xs

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 7.

                       2Функционал "развёртка"

 ш1.0
                    1Глаз должен выучиться видеть, как язык говорить.
                                                             1Д.Дидро
 ш1.2

                       21. 3 Основные определения
   Функционал " 1развёртка 0" охватывает достаточно общий образец гене-
рации списков 1.
    2Определение 1 0.
 ш1.1
    _ 1Функционал . 0 " _ 1развёртка . 0" определяется следующим паттерном рекурсии:
 ш1.0

   unfold:: (a -> Bool) -> (a -> b) -> (a -> a) -> a -> [b]
   unfold p f g x | p x  = []
                  | True = f x : unfold p f g (g x)

   Другими словами,

   head $ unfold p f g x = f x,
   tail $ unfold p f g x = unfold p f g (g x),
   null $ unfold p f g x = p x.

 ш1.2
   Опишем шутливо  _ 1операционную семантику . 0 функционала: на каждом ша-
ге функция unfold "скармливает" предикату p  аргумент  x,  а  потом
спрашивает:  "Понравилось?".  Если "понравилось" (функция p вернула
True), то "кормёжка" прекращается и возвращается пустой список.
   Если же  "не понравилось" (функция p вернула False),  то функция
возвращает результат (f x) и "заказывает", чем её кормить в следую-
щий раз (т.е. вычисляет g x).
   Затем unfoldr собирает результаты в список и возвращает его.
    2Пример 0.
 ш1.1
   Представим процесс вычисления значения функции
 ш1.0

   enum n m = unfold (>m) id succ

 ш1.1
для значений аргументов n=1, m=3 в виде следующего рисунка:
 ш1.0

               1 ───── 76 0 2 ───── 76 0 3 ───── 76 0 4 ───── 76 0 []
               │   51>3 0   │   52>3 0   │   53>3 0       54>3
    1Полученный 0   7^ 1  0        7^ 0         7^
      1список 0     21 0         22 0         23

 ш1.2
    2Теорема 0 (по [Bird,Wadler,1988,p.173]).
 ш1.0

   unfold p f g = map f . takeWhile (not . p) . iterate g

 ш1.2
    2Доказательство 0. Упражняйтесь.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 6.

 ш1.2
    2Теорема 0 ( 1универсальное свойство unfold 0) [Gibbons,2003,p.45].
 ш1.0

    3h 0 = unfold p f g <=>  3h 0 x | p x  = []
                            | True = f x :  3h 0 (g x)

 ш1.2
    2Доказательство 0. Упражняйтесь.
    2Теорема 0 ( 1свойство объединения unfold, fusion law 0)
           [Gibbons,2003,p.45].
 ш1.0

   unfold p f g . h = unfold p' f' g' <=

                   <= p . h = p', f . h = f', g . h = h . g'.

 ш1.2
    2Доказательство 0. Упражняйтесь.
   Функционал " 1развёртка 0"  определим также паттерном рекурсии,  ис-
пользующим функцию, которая называется  _ 1конструктором пары . 0.
    2Определение 2 0.
 ш1.0

   unfold':: (a -> Bool) -> (a -> (b,a)) -> a -> [b] 
   unfold' p fg x | p x  = []
                  | True = fx : unfold' p fg gx
       where (fx,gx) = fg x

 ш1.1
   Другими словами,
 ш1.0

   fg = \x -> (f x,g x)

 ш1.1
где элементы списка образует функция f,  а начальный элемент x пре-
образуется функцией g.

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 6 41 0.

 ш1.2
                       22. 3 Обобщение развёртки
   Рассмотрим следующее обобщение функционала " 1развёртка 0":
 ш1.0

    3ana 0 q r p f g x = if p x
                       then r x
                       else q (f x) ( 3ana 0 q r p f g (g x))

 ш1.2
   Установим представления свёртки и развёртки на списках с помощью
указанного выше обобщения.
 ш1.0

   foldr f e =  3ana 0 f (\x -> e) null head tail

   unfold    =  3ana 0 (:) (\x -> [])

 ш1.2
    2Теорема 0 ( 1лёгкая 0).
 ш1.1
   Имеют место следующие  1эквациональные утверждения 0:
 ш1.0

    2(1) 0 foldr f e =  3ana 0 f (\x -> e) null head tail.

    2(2)  0unfold    =  3ana 0 (:) (\x -> []).

 ш1.2
    2Доказательство 0.
 ш1.0

    21. 0  3ana 0 f (\x -> e) null head tail x =
       = if null x
           then (\x -> e) x
           else f (head x) ( 3ana 0 f (\x -> e) null head tail (tail x))
       = if null x
           then e
           else f (head x) ( 3ana 0 f (\x -> e) null head tail (tail x))
       = fold f e,

где fold f e x = if null x
                   then e
                   else f (head x) (fold f e (tail x)).

    22. 0  3ana 0 (:) (\x -> []) p f g x =
            = if p x
                then (\x -> []) x
                else (:) (f x) ( 3ana 0 (:) (\x -> []) p f g (g x)) =
            = if p x
                then []
                else f x :  3ana 0 (:) (\x -> []) p f g (g x) =
            = unfold p f g x.

 ш1.2
    1Теорема доказана 0.

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 0  21.
 ш1.0

 ш1.2

    2Пример 0  22.
 ш1.0

 ш1.2

    2Пример 0  23.
 ш1.0

 ш1.2

    2Пример 0  24.
 ш1.0

 ш1.2

    2Пример 0  25.
 ш1.0

 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                     1Раз - везение, два - везение, надобно и умение.
                                                         1А.В.Суворов
 ш1.2

                       20. 3 Классическое оригами
    21. 0 Сконструируйте классические оригами:
 ш1.1
   (1)  _ 1статичные модели . 0:  стакан,  шлем самурая, дзунако, вертушка,
пароход, парусник, голубь, цикада;
   (2)  _ 1движущиеся модели . 0: лягушка, японский журавлик, лающий щенок,
учёный тюлень и др.

 ш1.2
                  21. 3 Функционалы свёртки в Prelude
    21 4* 2. 0 Определите назначение следующих функций:
 ш1.0

   (1) test1      = foldr (+) 0 [1..10]
   (2) test2      = foldr (+) 0
   (3) test3      = foldr (*) 1
   (4) test4 lst  = foldr max (head lst) (tail lst)
   (5) test5 elem = (.) (foldr (||) False) (map (== elem))
   (6) test6 lst  = take (toInt (len lst `div` 2)) lst
          where len = foldr (\z -> \n -> n+1) 0
   (7) test7 = map fact
          where fact n = foldl1 (*) [1..n]
   (8) test8      = map (length . show . (scanl (*) 1 [1..] !!))
   (9) test9 x = sum $ map (\k -> power sin k x) [1..50]
          where power f 0     = id           
                power f (n+1) = f . power f n
   (10) test10 m n  = takeWhile (<=n) $ iterate (+ 1) m
   (11) [Bird,Wadler,1988,p.172]
        group n = map (take n) . takeWhile (/=[])
                               . iterate (drop n)
   (12) [Bird,Wadler,1988,p.172]
        digits  = reverse . map (`mod` 10) . takeWhile (/=0)
                                           . iterate (`div` 10)

 ш1.2
    22. 0 Известно, что свёртка foldr приспособлена для работы с беско-
нечными списками:
 ш1.0

   > head $ (foldr (\x xs -> (x + pi) : xs) [] ) [1..]
   4.141592653589793

 ш1.2
   К сожалению, иногда возникают неприятности. Например, рассмотрим
функцию, которая удаляет из заданного списка элементы,  расположен-
ные на нечётных местах:
 ш1.0

   evenOnly = snd . foldr (\x (os,es) -> (x : es,os)) ([],[])

   > evenOnly [1..10]
   [2,4,6,8,10]

 ш1.2
   Однако на бесконечном списке её поведение становится странным:
 ш1.0

   > head $ evenOnly [1..]
   Interrupted.

 ш1.2
   Почему это происходит, и какие минимальные изменения можно в неё
внести, чтобы восстановить утраченную работоспособность?
                22. 3 Определение функций и функционалов
                          3с помощью свёртки
    21. 0 Реализуйте следующие функции с помощью свёртки foldr:
 ш1.0

   (1) sum, product, and, or, concat, head, (++), length, reverse;
   (2) not, tail, init, last.

 ш1.2
    22. 0 Реализуйте следующие функционалы с помощью свёртки foldr:
 ш1.0

   map, filter, zip, dropWhile, foldl.

 ш1.2
    23. 0 Реализуйте следующие функции с помощью свёртки foldl:
 ш1.0

   (1) sum, product, and, or, concat, reverse;
   (2) head, (++), length, not, tail, init, last.

 ш1.2
    24 5* 2. 0 Реализуйте следующие функционалы с помощью свёртки foldl:
 ш1.0

   map, filter, zip, dropWhile, foldr.

 ш1.2
    25 5* 2. 0 Реализуйте  следующие  функционалы  из библиотеки List с по-
мощью свёртки:
 ш1.0

   (1) tails'' []     = [[]]
       tails'' (x:xs) = (x : xs) : tails'' xs

   (2) inits'' []     = [[]]
       inits'' (x:xs) = [] : map (x :) (inits'' xs)

 ш1.2
    26. 0 ( 1С.Довжиков 0)
   Определите, правильно ли реализованы следующие функции, записан-
ные в foldr-стиле, с помощью  1ручной прокрутки 0 кода:
 ш1.0

   (1) tail' lst = foldr f [] lst
           where f x ys = if length ys == -1 + length lst
                            then ys else x:ys

   (2) init' lst = foldl f [] lst
           where f ys x = if length ys == -1 + length lst
                            then ys else ys ++ [x]

   (3) last' = (!! 0) . foldr f [] . h2
            where f (x,i) ys = if i==0 then x:ys else ys
       -------------------------------------------------
       h2 :: [a] -> [(a,Int)]
       h2 []     = []
       h2 [x]    = [(x,0)]
       h2 (x:xs) = (x,1) : (h2 xs)

   (4) takeWhile' p = foldr f' [] . (g p)
             where f' (x,b) ys = if b then x:ys else ys
       ------------------------------------------------
       dropWhile' :: (a -> Bool) -> [a] -> [a]
       dropWhile' p = foldr f' [] . (g p)
             where f' (x,b) ys = if b then ys else x:ys
       ------------------------------------------------
       g :: (a -> Bool) -> [a] -> [(a,Bool)]
       g p [] = []
       g p (x:xs) = if p x
                      then (x,True) : (g p xs)
                      else (x,False) : (map (\x -> (x,False)) xs)

 ш1.2
                       23. 3 Развёртка на списках
    21. 0 Функция (range n m) возвращает список чисел от n до m.  Опре-
делите её с помощью развёртки.
    22. 0 Определите с помощью развёртки следующие функции:
 ш1.0

   (1) map, zip; (2) 5* 0 filter.

 ш1.2
    23. 0 Проверьте,  реализует ли приведённая ниже функция  функционал
filter; при положительном ответе перепишите функцию в unfold-стиле.
 ш1.0

   filter' p lst | null lst     = []
                 | p (head lst) = f lst
                 | True         = tail $ f lst
      where f  = unfold p' f' g'
            p' = null 
            f' = head
            g' = g (not . p) . tail 
            -------------------------
            g pr l | null l      = []
                   | pr (head l) = dropWhile pr l
                   | True        = l
 ш1.2
