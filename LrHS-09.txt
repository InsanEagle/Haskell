    2ЛАБОРАТОРНАЯ РАБОТА 9.
    2ЯЗЫК ПРОГРАММИРОВАНИЯ Haskell:  моделирование  7l 2-исчисления и ис-
 2числения комбинаторов

 ш1.0
              1Вы говорите, что люди же решают задачи. Но посмотрите 0:
              1каждый специалист имеет свои излюбленные задачи, кото-
              1рые он хорошо решает.  А для Вашего  профессионального
              1роста  и  трезвой  самооценки очень полезно побывать в
              1такой ситуации,  когда Ваши излюбленные методы отказы-
              1вают.  Если Вы сумели проанализировать свою неудачу Вы
              1достойны звания специалиста,  если же нет,  Вы находи-
              1тесь на пути к догматизму либо шарлатанству. 0
                      1Н.Н.Непейвода. Стили и методы программирования
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Знать . 0:
 ш1.0
   - механизм реализации  вычислений  в  языке  Haskell  с  помощью
"строковой" и графовой редукции.

 ш1.2
    _ 1Уметь . 0:
 ш1.0
   - моделировать стандартные комбинаторы на языке Haskell;
   - моделировать комбинатор неподвижной точки на языке Haskell;
   - использовать  комбинатор  неподвижной  точки для моделирования
рекурсии на языке Haskell;
   - проводить "строковую" редукцию для заданного 7 l 0-терма ( 1повторе-
 1ние 0);
   - проводить графовую редукцию для заданного комбинатора;
   - проводить "строковую" и графовую редукцию для простой програм-
мы на языке Haskell.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                      3Моделирование стандартных
                            3комбинаторов

 ш1.0
              1- Я слышала,  как забавляются лучшие бойцы твоего пле-
              1мени. Кто-нибудь разгоняет на них тройку, и они ударом
              1в оглоблю опрокидывают всех трёх коней 0! 1 Та так можешь 0?
              1- Не знаю, - сказал Волкодав. - Я не пробовал.
                                                1М.Семёнова. Волкодав
 ш1.2

   Язык Haskell иногда называют " _ 1засахаренной . 0"   _ 1версией . 0   7l 0- _ 1исчисле-
 _ 1ния . 0.  Напомним,  что  _ 1синтаксический сахар . 0 (англ.  1syntactic sugar 0) -
это дополнение синтаксиса,  которые не добавляют новые возможности,
но делают язык программирования более удобным в использовании.
    2Определение 0.
 ш1.1
    _ 1Комбинаторы . 0 ( 1в программировании 0) - это функции высшего  порядка,
которые позволяют из одних функций конструировать другие.

 ш1.2
   Рассмотрим моделирование на языке Haskell некоторых  стандартных
комбинаторов, содержащихся в библиотеке Prelude.
 ш1.0

    21. 0  2I ═+ 7l 0x.x ( _ 1тождественный комбинатор . 0).

 ш1.2
   Функция, возвращающая значение своего аргумента, такова:
 ш1.0

   id:: a -> a
   id x

 ш1.2
   Например:
 ш1.0

   > id 3   > id head [1,2,3]   > id tail [-1,-2,-3]
   3        1                   [-1,-2,-3]

 ш1.2
    3Замечание 0.
 ш1.1
   Приведём вариант моделирования комбинатора 2 I 0:
 ш1.0

   i = \x -> x

    22. 0  2K ═+ 7l 0x. 7l 0y.x  ( _ 1комбинатор образования константы . 0).

 ш1.2
   Функция, аналогичная комбинатору  2K 0 (возвращающая свой первый ар-
гумент при заданных двух), такова:
 ш1.0

   const:: a -> b -> a
   const k _ = k

   Например:

   > const 'a' 'b'   > const (-1) 1   > const "abcdef" "xyz"
   'a'               -1               "abcdef"

 ш1.2
    3Замечание 0.
 ш1.1
   Приведём варианты моделирования комбинатора 2 K 0:
 ш1.0

   k = \x -> \y -> x

   k c x = c

 ш1.1
   Комбинаторная характеристика  2K 0xy=x означает существование комби-
натора (функции) взятия  1первой проекции 0, т.е. первого элемента упо-
рядоченной пары или первого элемента списка.
   Эта характеристика  близка языкам функционального программирова-
ния,  оперирующего списками, и соответствует фундаментальной опера-
ции взятия первого элемента списка.
 ш1.0

    23. 0  2C ═+ 7l 0xyz.xzy ( _ 1элементарный коммутатор . 0).

 ш1.2
   Функция (аналогичная комбинатору  2C 0),  возвращающая значение  за-
данной бинарной функции,  подсчитанное на аргументах в обратном по-
рядке, такова:
 ш1.0

   flip:: (a -> b -> c) -> b -> a -> c
   flip f x y = f y x

 ш1.2
   Например:
 ш1.0

   > flip (-) 2 3   > flip (-) 3 2
   1                -1

 ш1.2
    3Замечание 0.
 ш1.1
   Приведём варианты моделирования комбинатора 2 C 0:
 ш1.0

   (1) c = \x y z -> (x z) y
   (2) c f x y = f y x

    24. 0  2B ═+ 7l 0xyz.x(yz) ( _ 1элементарный композитор . 0).

 ш1.2
   Функция (аналогичная комбинатору  2B 0),  возвращающая значение ком-
позиции двух функций, такова:
 ш1.0

   (.):: (a -> b) -> (c -> a) -> (c -> b)
   (.) f g x = f (g x)

 ш1.2
   Например:
 ш1.0

   > (.) sin cos 1      > (sin . cos) 1      > sin (cos 1)
   0.514395 :: Double   0.514395 :: Double   0.514395 :: Double

 ш1.2
    3Замечание 0.
 ш1.1
   Приведём варианты моделирования комбинатора 2 B 0:
 ш1.0

   (1) b = \f g -> f.g
   (2) b f g x = (f.g) x

    25. 0  7J ═+ 7l 0x. 7l 0y. 7l 0z. 7l 0w.x(yz)(yw).

 ш1.2
   Функцией (аналогичной комбинатору  7J 0) в интерпретаторе GHCi явля-
ется  функция on,  которая перед применением бинарной функции "про-
пускает" аргументы через унарную функцию, т.е.
 ш1.0

   f1 `on` f2 = \x -> \y  -> (f2 x) f1 (f2 y)

 ш1.2
    3Замечание 0.
 ш1.1
   Приведём вариант моделирования комбинатора 2  7J 0:
 ш1.0

   on f1 f2 = \x -> \y -> f1 (f2 x) (f2 y)

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1.

 ш1.2
                      3Моделирование комбинатора
                          3неподвижной точки
   Рассмотрим моделирование  комбинатора  неподвижной точки в языке
программирования Haskell:
 ш1.0

   y f = f (y f)

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 2.

 ш1.2
                   3Моделирование рекурсии с 0  3помощью
                    3комбинатора 0  3неподвижной точки
   Рассмотрим рекурсивную функцию языка Haskell, представленную не-
формальной записью, и её записью в виде  7l 0-терма:
 ш1.0

    ═f 0 x = (... ═f 0...) <=>  ═f 0= 7l 0x.(... ═f 0...),

 ш1.2
где (... ═f 0...) - обозначение  7l 0-терма,  содержащего свободное вхожде-
ние  7l 0-терма  ═f 0.
   Другими словами, мы получили "рекурсивный"  7l 0-терм  ═f 0.
   Напомним, что  2Y 0 - комбинатор неподвижной точки.
    2Теорема 0 ( 1важная 0).
 ш1.0

                         4┌ 0                4┐
    ═f 0= 7l 0x.(... ═f 0...) =>  ═f 0= 2Y 0│ 7l 0f. 7l 0x.(...f...)│ ═+ 2Y 0E.
                         4└ ═└ 0────── ═┬ 0────── ═┘ 4┘
                                 E

 ш1.2
    2Доказательство 0.  7l 0-терм E является комбинатором.
   Воспользуемся  1обращением 0  7b 0- 1редукции 0:
 ш1.0

                        4┌ 0                4┐
    ═f 0= 7l 0x.(... ═f 0...) =>  ═f 0= 72l 0f. 7l 0x.(...f...) 72 ═f 0 =>  ═f 0=E ═f 0,  ═f 7Е 0FV(E).
                        4└ ═└ 0────── ═┬ 0────── ═┘ 4┘
                                 5E

 ш1.2
в результате чего построено " _ 1рекурсивное . 0"  _ 1определение . 0  7l 0- _ 1терма . 0  ═f 0.
    7l 0-формула  ═f 0=E ═f 0  выражает  тот  факт,  что  ═f 0 является  1неподвижной
 1точкой комбинатора 0 E. Найдём  7l 0-терм для  ═f 0 (по  1теореме о неподвижной
 1точке 0 такой  7l 0-терм  1существует 0 для любого  7l 0-терма E),  для чего вос-
пользуемся характеристическим  свойством  комбинатора   неподвижной
точки:  2Y 0E=E( 2Y 0E) и получим  _ 1нерекурсивное определение . 0  7l 0- _ 1терма . 0  ═f 0:
 ш1.0

          4┌ 0                4┐
    ═f 0= 2Y 0E ═+ 2Y 72l 0f. 7l 0x.(...f...) 72 0.
          4└ 0                4┘

 ш1.2
    1Теорема 0  1доказана.
   Итак,  1теорема о неподвижной точке 0 гарантирует возможность  пере-
хода  от  рекурсивного  определения  ═f 0= 7l 0x.(... ═f 0...) к нерекурсивному
определению  ═f 0= 2Y 0E ( 1по форме записи 0!).  При этом  эффект  цикличности
определения  (и  соответствующего вычисления) оказывается скрытым с
помощью комбинатора неподвижной точки.
   Напомним комбинаторную характеристику  2Y 0E=E( 2Y 0E) комбинатора 2 Y 0.
    2Следствие 0 ( 1для программирования 0).
 ш1.0

      4┌ 0                4┐
    ═f 0=│ 7l 0f. 7l 0x.(...f...)│( 2Y 0E).
      4└ 0                4┘

 ш1.2
    2Доказательство 0. Воспользуемся  характеристическим свойством ком-
бинатора  2Y 0 и 7 b 0-редукцией:
 ш1.0

                         4┌ 0                4┐
    ═f 0= 2Y 0E 1  0=> 1  ═f 0=E( 2Y 0E) =>  ═f 0=│ 7l 0f. 7l 0x.(...f...)│( 2Y 0E).
                         4└ 0                4┘

 ш1.2
    1Следствие доказано 0.
    2Пример 0  21 0.
 ш1.1
   Рассмотрим рекурсивное  уравнение   ═f 0(x)= ═b 0( ═f 0(x-1))  и выразим его
неподвижную точку с помощью комбинаторов:
 ш1.0

                                          4┌ 0                4┐
    ═f 0(x)= ═b 0( ═f 0(x-1)) =>  ═f 0= 7l 0x. ═b 0( ═f 0(x-1)) =>  ═f 0=│ 7l 0f. 7l 0x. ═b 0(f(x-1))│ ═f 0 =>
                                          4└ 0                4┘
          4┌ 0                4┐ 0       4┌ 0                4┐
   =>  ═f 0= 2Y 0│ 7l 0f. 7l 0x. ═b 0(f(x-1))│ =>  ═f 0=│ 7l _ 0f .. 7l 0x. ═b 0( _f .(x-1))│( 2Y 0E) =>
          4└ ═└ 0────── ═┬ 0────── ═┘ 4┘ 0       4└ 0                4┘
                   5E
         4┌ 0                4┐
   =>  ═f 0=│ 7l 0x. ═b 0(( 2Y 0E)(x-1))│.
         4└ 0                4┘

   Теперь опишем процесс вычисления значения функции  ═f 0(a):

         4┌ 0                4┐ 0    4┌ 0          4┐ 0   4┌ 0           4┐
    ═f 0(a)=│ 7l _ 0x .. ═b 0(( 2Y 0E)( _x .-1))│a= ═b 0│( 2Y 0E)(a-1)│= ═b 0│E( 2Y 0E)(a-1)│=
         4└ 0                4┘ 0    4└ 0          4┘ 0   4└ 0           4┘
          4┌┌ 0                4┐ 0          4┐ 0   4┌┌ 0                4┐ 0      4┐
       = ═b 0││ 7l _ 0f .. 7l 0x. ═b 0( _f .(x-1))│( 2Y 0E)(a-1)│= ═b 0││ 7l _ 0x .. ═b 0(( 2Y 0E)( _x .-1))│(a-1)│=
          4└└ 0                4┘ 0          4┘ 0   4└└ 0                4┘ 0      4┘
          4┌ 0  4┌ 0          4┐┐ 0   4┌ 0  4┌ 0           4┐┐ 0       4┌ 0  4┌ 0  4┌ 0           4┐┐┐
       = ═b 0│ ═b 0│( 2Y 0E)(a-2)││= ═b 0│ ═b 0│E( 2Y 0E)(a-2)││= 7777 0= ═b 0│ ═b 0│ ═b 0│E( 2Y 0E)(a-3)│││= 7777
          4└ 0  4└ 0          4┘┘ 0   4└ 0  4└ 0           4┘┘ 0       4└ 0  4└ 0  4└ 0           4┘┘┘

 ш1.2
    2Пример 0  22 0 ( 1использования Следствия 0).
 ш1.1
   Рассмотрим рекурсивную функцию для вычисления факториала
 ш1.0

    ═f 0= 7l 0x.if x=0 then 1 else x* ═f 0(x-1).

 ш1.1
   Тогда
 ш1.0

   E ═+ 7l 0f. 7l 0x.if x=0 then 1 else x*f(x-1)

 ш1.1
и можно с помощью Следствия  подробно  описать  процесс  вычисления
значения  ═f 0(3):
 ш1.0

             7( 0                            7)
    ═f 0(3)= 2Y 0E3= 72 1if 0 x=0  1then 0 1  1else 0 x 77 0f(x-1) 72 0( 2Y 0E)3=
             79 0                            70
             7( 0                               7)
           = 72 1if 0 x=0  1then 0 1  1else 0  _x 77 0( 2Y 0E)(x-1) . 72 03=
             79 0                               70
                   7( 0                            7)
       =3 77 0( 2Y 0E)2=3 772 1if 0 x=0  1then 0 1  1else 0 x 77 0f(x-1) 72 0( 2Y 0E)2=
                   79 0                            70
               7( 0                               7)
           =3 772 1if 0 x=0  1then 0 1  1else 0  _x 77 0(YE)(x-1) . 72 02=
               79 0                               70
                       7( 0                            7)
       =3 77 02 77 0( 2Y 0E)1=3 77 02 772 1if 0 x=0  1then 0 1  1else 0 x 77 0f(x-1) 72 0( 2Y 0E)1=
                       79 0                            70
                 7( 0                               7)
           =3 77 02 772 1if 0 x=0  1then 0 1  1else 0  _x 77 0( 2Y 0E)(x-1) . 72 01=
                 79 0                               70
                           7( 0                            7)
       =3 77 02 77 01 77 0( 2Y 0E)0=3 77 02 77 01 772 1if 0 x=0  1then 0 1  1else 0 x 77 0f(x-1) 72 0( 2Y 0E)0=
                           79 0                            70
               7( 0                               7)
       =3 77 02 77 01 772 1if 0 x=0  1then 0  _1 .  1else 0 x*( 2Y 0E)(x-1) 72 00=3 77 02 77 01 77 01=6.
               79 0                               70

 ш1.2
    2Пример 3 0 ( 1трансформации рекурсивной функции 0) 2.
 ш1.1
   Представим рекурсивную функцию на языке Haskell с помощью комби-
натора неподвижной точки.
   Вначале реализуем комбинатор 2 Y 0:
 ш1.0

   y f = f (y f)

 ш1.1
   Затем возьмём  рекурсивную функцию fct для вычисления факториала
натурального числа и преобразуем её с помощью вспомогательной функ-
ции fun к требуемому виду fct':
 ш1.0

  ┌──────────────────────────┐
   1│ 0fct x | x==1 = 1          │ => fun  _f . x | x==1 = 1         =>
   1│ 0      | True = x*fct (x-1)│            | True = x* _f . (x-1)
  └──────────────────────────┘
                                                 ┌────────────────┐
                              => fct' = y fun => │fct' x = y fun x│
                                                 └────────────────┘
 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 2, Пример 2 41 0.

                   2Механизм реализации вычислений
                           2в языке Haskell

 ш1.0
              1... попробуйте взобраться на вершину горы, не останав-
              1ливаясь для того,  чтобы полюбоваться красотой деревь-
              1ев.  На обратном пути,  спускаясь с вершины,  мы можем
              1охватить взглядом всё великолепие открывающегося вида.
                                                              1Ю.Сато
 ш1.2

   В предыдущих разделах  было  определено  и  достаточно  подробно
рассмотрено отношение редуцируемости 7 l 0-термов друг к другу.  Однако
данное рассмотрение было проведено безотносительно к технологии вы-
полнения вычислений в функциональных языках программирования.
   Но механизм  редукции - это непосредственная реализация вычисли-
тельных процессов,  поэтому имеет смысл рассмотреть данный механизм
более подробно именно в разрезе языков программирования.
                    21. 0  3Нормальная и аппликативная
                       3редукционные 0  3стратегии
   Первоначально в  рамках  теории функционального программирования
были разработаны две стратегии проведения редукции для поиска и по-
лучения нормальной  формы некоторого 7 l 0-терма.  По своей сути данные
стратегии являют собой способы проведения  вычислений,  или,  иными
словами, способы вызовов функций.
    2Определение 0 ( 1повторение 0).
 ш1.1
   Под  _ 1нормальной редукционной стратегией . 0 понимается способ  редук-
ции заданного 7 l 0-терма,  при котором на каждом шаге редукции выбира-
ется  1самый левый и самый внешний 7 b 1-редекс 0.

 ш1.2
    2Пример 0 ( 1использования нормальной редукционной стратегии 0).
 ш1.0

   ( 7l 0y.x)(( 7l 0x.xx)( 7l 0x.xx))=x

 ш1.2
    2Определение 0 ( 1повторение 0).
 ш1.1
    _ 1Аппликативной редукционной стратегией . 0 называется  такая  страте-
гия,  при  которой на каждом шаге редукции выбирается 7 b 0-редекс,  не
содержащий внутри себя других  7b 0-редексов.

 ш1.2
   Аппликативная редукционная  стратегия  не всегда позволяет полу-
чить нормальную форму выражения, даже если она существует.
    2Пример 0 ( 1использования аппликативной редукционной стратегии 0).
 ш1.0

   ( 7l 0y.x)(( 7l 0x.xx)( 7l 0x.xx))=( 7l 0y.x)(( 7l 0x.xx)( 7l 0x.xx))=

      =( 7l 0y.x)(( 7l 0x.xx)( 7l 0x.xx))=( 7l 0y.x)(( 7l 0x.xx)( 7l 0x.xx))= 1...

 ш1.1
   На этом  примере  видно как аппликативная редукционная стратегия
может привести к зацикливанию процесса вычислений на редукции одно-
го и  того  же 7 l 0-терма и получить нормальную форму выражения в этом
случае невозможно.

 ш1.2
   В программировании  нормальная  редукционная стратегия соответс-
твует  _ 1вызову по имени . 0,  т.е.  аргумент выражения не вычисляется  до
того, пока к нему не возникнет обращения в теле выражения.
   Аппликативная редукционная  стратегия  соответствует   _ 1вызову  по
 _ 1значению . 0, когда  перед  передачей  фактического параметра в функцию
его значение предварительно вычисляется.
   Рассмотренные редукционные   стратегии  легли  в  основу  работы
трансляторов языков функционального программирования.
   В первую очередь стратегии редукции повлияли на работу  _ 1интерпре-
 _ 1таторов . 0, которая описывается следующими шагами [Душкин,2007,с.320]:
 ш1.1
   (1) в вычисляемом выражении выделяется некоторое обращение к ре-
курсивной или   1встроенной функции 0 (!) с полностью означенными аргу-
ментами. Если выделенное обращение к  1встроенной функции 0 существует,
то происходит его выполнение и возврат к началу этого шага;
   (2) если выделенное на первом шаге обращение является обращением
к  1рекурсивной функции 0,  то вместо него подставляется тело функции с
фактическими параметрами (так как они уже означены). Далее происхо-
дит переход на начало первого шага;
   (3) если больше обращений нет, то происходит остановка.

 ш1.2
   Видно, что  вычисления в функциональной парадигме программирова-
ния повторяют шаги редукции,  но дополнительно содержат  вычисления
значений  1встроенных функций 0.
                    22. 0  3Понятие "ленивая редукция"
   С точки  зрения  теории 7  l 0-исчисления,   1нормальная  редукционная
 1стратегия 0 является оптимальной, т.к. гарантированно позволяет найти
нормальную форму в случае её существования.
   Однако в  практических  целях  при  выполнении  вычислений такая
стратегия совершенно неэффективна.  Так,  рассматривая вычисления с
целыми числами,  можно увидеть множество примеров, когда нормальная
редукционная стратегия заставляет интерпретатор неоднократно произ-
водить одни и те же вычисления.
   Например, если имеется функция, возводящая число в квадрат
 ш1.0

   sqr ═+ 7l 0x.mult x x,

и необходимо вычислить выражение

   sqr (sqr n) -> mult (sqr n) (sqr n) ->
               -> mult (mult n n) (mult n n),

 ш1.2
то при  применении  нормальной редукционной стратегии 7 l 0-терм n при-
дётся вычислить четыре раза.
    1Аппликативная редукционная  стратегия 0 помогла бы в данном случае
с точки зрения оптимизации вычислений, однако, она может привести к
зацикливанию.
   В связи с этим в рамках 7 l 0-исчисления была разработана  _ 1технология
 _ 1отложенных . 0 ( _ 1ленивых . 0)  _ 1вычислений . 0,  которая соответствует   1вызову  по
 1необходимости 0 в реализациях функциональных языков программирования:
 ш1.1
   (1) аргумент никогда не вычисляется, пока его значение не потре-
буется в процессе дальнейших вычислений;
   (2) значение 7 l 0-выражения вычисляется только до требуемой точнос-
ти,  что позволяет использовать потенциально бесконечные  структуры
данных;
   (3) не вычисляет какой-либо 7 l 0-терм более одного раза.

 ш1.2
                  23. 0  3"Строковая" редукция 7 l 3-термов
   Напомним, что   7l 0-исчисление  и комбинаторная логика легко транс-
формируются друг в друга (данный метод  разработан  Д.Тернером)  по
следующим  _ 1правилам трансформации . 0  7l 0- _ 1термов в комбинаторные выражения . 0:
    2(А) 0 в  _ 1базисе . 0 {I, 2K 0, 2S 0}:
 ш1.0

    2(1) 0 T[ 7l 0x.x] ═+ 0I;

    2(2) 0 T[ 7l 0x.P] ═+ 2K 0P, если x 7Е 0FV(P);

    2(3) 0 T[ 7l 0x.PQ] ═+ 2S 0T[ 7l 0x.P]T[ 7l 0x.Q], если x 7е 0FV(P)&x 7е 0FV(Q);

    2(4) 0 T[ 7l 0x. 7l 0y.M] ═+ 0T[ 7l 0x.T[ 7l 0y.M]].

 ш1.2
    2(В) 0 в  _ 1базисе . 0 {I, 2K 0, 2S 0,B,C}:
 ш1.0

    2(1) 0 T[ 7l 0x.x] ═+ 0I;

    2(2) 0 T[ 7l 0x.PQ] ═+ 2K 0(PQ), если x 7Е 0FV(P)&x 7Е 0FV(Q);

    2(3) 0 T[ 7l 0x.PQ] ═+ 2B 0PT[ 7l 0x.Q], если x 7Е 0FV(P)&x 7е 0FV(Q);

    2(4) 0 T[ 7l 0x.PQ] ═+ 2C 0T[ 7l 0x.P]Q, если x 7е 0FV(P)&x 7Е 0FV(Q);

    2(5) 0 T[ 7l 0x.PQ] ═+ 2S 0T[ 7l 0x.P]T[ 7l 0x.Q], если x 7е 0FV(P)&x 7е 0FV(Q);

    2(6) 0 T[ 7l 0x. 7l 0y.M] ═+ 0T[ 7l 0x.T[ 7l 0y.M]].

 ш1.2
    2Пример 0 ( 1повторение 0).
 ш1.1
    21. 0 Вычислим значение  7l 0-терма ( 7l 0x. 7l 0y.+xy) двумя способами:
 ш1.0

   (а) (( 7l 0x. 7l 0y.+xy)2)3=5,

   (б)  2C 0( 2BB 0( 2B 0+ 2I 0)) 2I 023=( 2BB 0( 2B 0+ 2I 0))2 2I 03= 2BB 0( 2B 0+ 2I 0)2 2I 03= 2B 0(( 2B 0+ 2I 0)2) 2I 03=

                    =(( 2B 0+ 2I 0)2)( 2I 03)=( 2B 0+ 2I 0)23= 2B 0+ 2I 023=+( 2I 02)3=+23=5.

    22. 0 ( 7l 0x.+2(-x3))4= 2B 0(+2)( 7l 0x.-x3)4= 2B 0(+2)( 2C 0( 7l 0x.-x)3)4=

                    2=B 0(+2)( 2C 0( 2B 0- 2I 0)3)4.

   Вычислим значение исходного  7l 0-терма двумя способами:

   (а) ( 7l _ 0x ..+2(-x3))4=+2(-43)=+21=3,

   (б)  2B 0(+2)( 2C 0( 2B 0- 2I 0)3)4=(+2)( 2C 0( 2B 0- 2I 0)34)=+2( 2B 0- 2I 043)=

                      =+2(-(I4)3)=+2(-43)=+21=3.

 ш1.1
    23. 0 Рассмотрим  7l 1- 0терм
 ш1.0

    7l 0x. 7l 0f.if x=1 then 1 else x*f(x-1).

 ш1.1
   Преобразуем его, записав операцию ветвления в функциональном ви-
де
 ш1.0

    7l 0x. 7l 0f.if x=1 1 x*f(x-1)=

          = 7l 0x. 7l 0f.if (= x 1) 1 (* x f(- x 1))=

          = 7l 0f. 2S 0( 7l 0x.if (= x 1)) 1 ( 7l 0x.* x f (- x 1))= 7777 0=

          = 2S 0( 2C 0( 2B 0if( 2C 0( 2B 0= 2I 0)1))1)( 2S 0( 2C 0( 2B 0* 2I 0) 2I 0)( 2C 0( 2B 0- 2I 0)1)).
 ш1.2

                    24. 0  3Редукция с помощью графов

 ш1.0
                1Понять - значит привыкнуть и научиться использовать.
                                                           1Р.Фейнман
 ш1.2

   Ленивая редукционная стратегия хорошо представляется в виде  _ 1гра-
 _ 1фов . 0, в узлах которых находятся редуцируемые  7l 0-термы, значения кото-
рых требуются в вычислительном  процессе  более  одного  раза.  Как
только  подобный   7l 0-терм редуцируется,  его значение перезаписывает
узел в графе, что позволяет всем ссылкам на этот  7l 0-терм сразу полу-
чить его новое значение.
   Ленивая редукционная стратегия, представленная с помощью графов,
хорошо работает  с объектами  _ 1комбинаторной логики . 0,  т.к.  в ней от-
сутствуют свободные переменные. Наличие переменных, свободных в те-
ле  7l 0-выражения, приводит к тому, что при изменении значения свобод-
ной переменной приходится копировать новое значение тела   7l 0-выраже-
ния.
   Редукция при помощи графов работает над  _ 1комбинаторами . 0.
   Каждый терм и его дочерние термы являются константными выражени-
ями.  Именно поэтому нет особых причин в запрете  на  деструктивную
трансформацию  подобных  графов - ведь отсутствуют переменные,  чьи
значения могли бы изменяться динамически.  Поэтому в конце процесса
редукции граф просто заменяется на свою нормальную форму.
   Изобразим с помощью графов  _ 1редукцию базисных комбинаторов
 ш1.0

    2I 0,  2K 0,  2S 0,  2C 0,  2B 0,  2W 0:

        7^ 0              7^ 0                 7^ 0              7^
    4┌ 0───∙─── 4┐ 0         ∙             4┌ 0───∙─── 4┐ 0         ∙
    7^ 0        7^ 0    =>   X             7^ 0        7^ 0    =>   X
   ∙       ∙                   4┌ 0───∙─── 4┐ 0   ∙
    2I 0       X                   7^ 0        7^ 0   Y
                 2I 0X => X       ∙       ∙ 2        K 0XY => X
                               2K 0       X

 ш1.2
   Редукция комбинатора 2 K 0 показывает пример ленивого способа вычис-
лений,  т.к. в этом правиле редукции второй аргумент никогда не вы-
числяется.
 ш1.0

                7^ 0                    7^
            4┌ 0───∙─── 4┐ 0           4┌ 0────∙──── 4┐
            7^ 0        7^ 0  =>       7^ 0          7^ 0     2S 0XYZ => (XZ)(YZ)
        4┌ 0───∙─── 4┐ 0   ∙       4┌ 0───∙─── 4┐ 0   4┌ 0──∙── 4┐
        7^ 0        7^ 0   Z       7^ 0       │   7^ 0      7^
    4┌ 0───∙─── 4┐ 0   ∙          ∙       │  ∙   7    0∙
    7^ 0        7^ 0   Y          X       │  Y   7  0   7% 0 Z
   ∙       ∙                       4└ 0──────── 4┘
    2S 0       X

                7^ 0               7^
            4┌ 0───∙─── 4┐ 0       4┌ 0───∙─── 4┐
            7^ 0        7^ 0  =>   7^ 0        7^ 0           2B 0XYZ => X(YZ)
        4┌ 0───∙─── 4┐ 0   ∙      ∙    4┌ 0───∙─── 4┐
        7^ 0        7^ 0   Z      X    7^ 0        7^
    4┌ 0───∙─── 4┐ 0   ∙              ∙       ∙
    7^ 0        7^ 0   Y              Y       Z
   ∙       ∙
    2B 0       X

                7^ 0                   7^
            4┌ 0───∙─── 4┐ 0           4┌ 0───∙─── 4┐
            7^ 0        7^ 0  =>       7^ 0        7^ 0       2C 0XYZ => XZY
        4┌ 0───∙─── 4┐ 0   ∙       4┌ 0───∙─── 4┐ 0   ∙
        7^ 0        7^ 0   Z       7^ 0        7^ 0   Y
    4┌ 0───∙─── 4┐ 0   ∙          ∙       ∙
    7^ 0        7^ 0   Y          X       Z
   ∙       ∙
    2C 0       X

            7^ 0                    7^
        4┌ 0───∙─── 4┐ 0            4┌ 0───∙─── 4┐
        7^ 0        7^ 0   =>       7^ 0       │
    4┌ 0───∙─── 4┐ 0   ∙        4┌ 0───∙─── 4┐ 0   │          2W 0YX => YXX
    7^ 0        7^ 0   X        7^ 0        7^ 0   │
   ∙       ∙           ∙       ∙ 75 0── 4┘
    2W 0       Y           Y       X

 ш1.2
   Редукция встроенных  функций  (примитивов) должна осуществляться
после того,  как аргументы таких примитивов будут  редуцированы  до
определённых константных значений (например, числовых).
   Например, если есть некоторая функция 1  mlt 0,  которая  возвращает
произведение двух её операндов, то вполне понятно, что редукция вы-
ражения 1 mlt 0 m n должна явить своим результатом произведение mn.
   Редукция при помощи графов довольно проста.
   Процесс вычислений рассматривает граф  и ищет в нём   _ 1самые левые
 _ 1вхождения термов . 0.
   Если эти термы - базовые комбинаторы, к которым приложено доста-
точное количество аргументов,  то производится преобразование графа
в соответствии с правилами редукции.
   Если самый  левый  терм - встроенная функция,  то осуществляется
редукция её аргументов до получения значений.
   Редукция аргументов производится по этим же правилам - в подгра-
фе ищется самый левый терм и т.д.
    2Пример 0  21 0 ( 1графовой редукции комбинатора 0).
 ш1.1
   Рассмотрим комбинатор  2S 0( 2KS 0) 2K 0xyz и проведём графовую редукцию:
 ш1.0

                   7^ 0                      7^ 0                  7^
                4┌ 0──∙── 4┐ 0                4┌ 0──∙── 4┐ 0            4┌ 0──∙── 4┐
                7^ 0      7^ 0  =>            7^ 0      7^ 0  =>        7^ 0      7^
             4┌ 0──∙── 4┐ 0  ∙             4┌ 0──∙── 4┐ 0  ∙         4┌ 0──∙── 4┐ 0  ∙
             7^ 0      7^ 0  z             7^ 0      7^ 0  z         7^ 0      7^ 0  z
          4┌ 0──∙── 4┐ 0  ∙            4┌ 0───∙─── 4┐ 0 ∙         4┌ 0──∙── 4┐ 0  ∙
          7^ 0      7^ 0  y            7^ 0        7^ 0 y         7^ 0      7^ 0  y
       4┌ 0──∙── 4┐ 0  ∙            4┌ 0──∙── 4┐ 0  4┌ 0──∙── 4┐ 0       ∙   4┌ 0──∙── 4┐
       7^ 0      7^ 0  x            7^ 0      7^ 0  7^ 0      7^ 0        2S 0   7^ 0      7^
    4┌ 0──∙── 4┐ 0  ∙            4┌ 0──∙── 4┐ 0  ∙ ∙     ∙          ∙     ∙
    7^ 0      7^ 2  K 0            7^ 0      7^ 0  x  2K 0     x           2K 0     x
   ∙   4┌ 0──∙── 4┐ 0           ∙     ∙
    2S 0   7^ 0      7^ 0            2K 0      2S
      ∙     ∙
       2K 0      2S

                 7^ 0                  7^
             4┌ 0───∙─── 4┐ 0           4┌ 0──∙── 4┐
   =>        7^ 0        7^ 0     =>    7^ 0      7^ 0     => x(yz)=Bxyz
          4┌ 0──∙── 4┐ 0  4┌ 0──∙── 4┐ 0       ∙   4┌ 0──∙── 4┐
          7^ 0      7^ 0  7^ 0      7^ 0       x   7^ 0      7^
       4┌ 0──∙── 4┐ 0  ∙ ∙     ∙          ∙     ∙
       7^ 0      7^ 0  z y     z          y     z
      ∙     ∙
       2K 0     x

 ш1.2
    2Пример 0  22 0 ( 1"строковой" и графовой редукции комбинатора 0).
 ш1.1
   Вначале проведём "строковую" редукцию:
 ш1.0

    2S 0( 2KS 0) 2K 0fgx=( 2KS 0)f( 2K 0f)gx= 2S 0( 2K 0f)gx=( 2K 0f)x(Gx)=f(gx)

   Теперь осуществим графовую редукцию:

                   7^ 0                            7^
                4┌ 0──∙── 4┐ 0                      4┌ 0──∙── 4┐
                7^ 0      7^ 0                      7^ 0      7^
             4┌ 0──∙── 4┐ 0  ∙                  4┌ 0───∙─── 4┐ 0 ∙
             7^ 0      7^ 0  x                  7^ 0        7^ 0 x
          4┌ 0──∙── 4┐ 0  ∙     =>         4┌ 0────∙──── 4┐ 0  ∙    =>
          7^ 0      7^ 0  g                7^ 0          7^ 0  g
       4┌ 0──∙── 4┐ 0  ∙                4┌ 0──∙── 4┐ 0    4┌ 0──∙── 4┐
       7^ 0      7^ 0  f                7^ 0      7^ 0    7^ 0      7^
    4┌ 0──∙── 4┐ 0  ∙                4┌ 0──∙── 4┐ 0  ∙   ∙     ∙
    7^ 0      7^ 2  K 0                7^ 0      7^ 0  │ 2  0  2 K 0      7% 0 f
   ∙   4┌ 0──∙── 4┐ 0               ∙     ∙   4└ 0───────── 4┘
    2S 0   7^ 0      7^ 0                2K 0      2S
      ∙     ∙
       2K 0      2S

                7^ 0                    7^ 0                 7^
             4┌ 0──∙── 4┐ 0             4┌ 0───∙─── 4┐ 0          4┌ 0──∙── 4┐
             7^ 0      7^ 0             7^ 0        7^ 0          7^ 0      7^
   =>     4┌ 0──∙── 4┐ 0  ∙  =>      4┌ 0──∙── 4┐ 0  4┌ 0──∙── 4┐ 0  =>  ∙    4┌ 0─∙── 4┐
          7^ 0      7^ 0  x          7^ 0      7^ 0  7^ 0      7^ 0      f    7^ 0     7^
       4┌ 0──∙── 4┐ 0  ∙          4┌ 0──∙── 4┐ 0  ∙ ∙     ∙          ∙    ∙
       7^ 0      7^ 0  g          7^ 0      7^ 0  7  0│ g      7% 0 x        g    x
      ∙   4┌ 0──∙── 4┐ 0         ∙     ∙   4└ 0─────── 4┘
       2S 0   7^ 0      7^ 0          2K 0     F
         ∙     ∙
          2K 0     f

 ш1.2
    2Пример 0  23 0 ( 1"строковой" и графовой редукции комбинатора 0).
 ш1.1
   Рассмотрим комбинатор
 ш1.0

    2C 0( 2SBI 0)(add 1)x

и проведём "строковую" редукцию:

    2C 0( 2SBI 0)(add 1)x=( 2SBI 0)x(add 1)= 2B 0x( 2I 0x)(add 1)= 2B 0xx(add 1)=

                 =x(x(add 1)).

   Теперь осуществим редукцию комбинатора с помощью графов:

                7^ 0                             7^
          4┌ 0─────∙───── 4┐ 0    =>            4┌ 0────∙──── 4┐ 0     =>
          7^ 0            7^ 0                  7^ 0          7^
       4┌ 0──∙──────── 4┐ 0  ∙ x             4┌ 0──∙── 4┐ 0    4┌ 0──∙── 4┐
       7^ 0            7^ 0                  7^ 0      7^ 0    7^ 0      7^
    4┌ 0──∙── 4┐ 0      4┌ 0──∙── 4┐ 0            4┌ 0──∙── 4┐ 0  ∙   ∙     ∙
    7^ 0      7^ 0      7^ 0      7^ 0            7^ 0      7^ 0  x  add    1
   ∙   4┌ 0──∙── 4┐ 0  ∙     ∙         4┌ 0──∙── 4┐ 0  ∙
    2C 0   7^ 0      7^ 0 add    1         7^ 0      7^ 0   2I
    4┌ 0──∙── 4┐ 0  ∙                 ∙     ∙
    7^ 0      7^ 0  I                  2S 0      2B
   ∙     ∙
    2S 0      2B

                    7^ 0                          7^
   =>        4┌ 0──────∙───── 4┐ 0     =>      4┌ 0──────∙───── 4┐
             7^ 0             7^ 0             7^ 0             7^
         4┌ 0───∙─── 4┐ 0      4┌ 0──∙── 4┐ 0       2    0∙ 2    0      4┌ 0──∙── 4┐
         7^ 0        7^ 0      7^ 0      7^ 0       2  0  x   2  0      7^ 0      7^
      4┌ 0──∙── 4┐ 0  4┌ 0──∙── 4┐ 0  ∙     ∙       2  0           ∙   4┌ 0──∙── 4┐
      7^ 0      7^ 0  7^ 0      7^ 0 add    1                  x   7^ 0      7^
     ∙     ∙ ∙     ∙                              ∙     ∙
      2B 0     x  2I 0     x                  2  0           add    1

 ш1.2
    2Пример 0  24 0 ( 1вычислений с помощью "строковой" и графовой редукции 0)
          (по [Душкин,2007,с.322,325]).
 ш1.1
   Рассмотрим выражение на языке Haskell:
 ш1.0

   let sqr n = n*n
   in sqr 5

 ш1.1
   Данное выражение возводит в квадрат число 5 с помощью встроенной
функции (*). Это выражение преобразуем в  7l 0-терм
 ш1.0

   ( 7l 0n.* n n) 5=( 7l 0f.f 5)( 7l 0n.* n n),

 ш1.1
который, далее,  преобразуем в комбинаторный терм при помощи правил
трансформации:
 ш1.0
                      4(4) 0                   4(1) 0              4(5)
   ( 7l 0f.f 5)( 7l 0n.* n n) =  2C 0( 7l 0f.f)5( 7l 0n.* n n) =  2CI 05( 7l 0n.* n n) =

                                4(1) 0                4(3)
         =  2CI 05( 2S 0( 7l 0n.* n)( 7l 0n.n)) =  2CI 05( 2S 0( 7l 0n.* n) 2I 0) =

                             4(1) 0             4BMI=M
         =  2CI 05( 2S 0( 2B 0*( 7l 0n.n))I) =  2CI 05( 2S 0( 2B 0* 2I 0) 2I 0)  =   2CI 05( 2S 0* 2I 0).

   Продемонстрируем процесс "строковых" вычислений:

    2CI 05( 2S 0* 2I 0)= 2I 0( 2S 0* 2I 0)5=( 2S 0* 2I 0)5= 2S 0* 2I 05=(*5)( 2I 05)=(*5)5=*55=25.

 ш1.2
   Остаётся осуществить графовую редукцию полученного комбинаторно-
го терма, которая приводит к вычислению значения:
 ш1.0

                7^ 0                         7^
          4┌ 0─────∙───── 4┐ 0             4┌ 0─────∙───── 4┐
          7^ 0            7^ 0             7^ 0            7^
       4┌ 0──∙── 4┐ 0      4┌ 0──∙── 4┐ 0  =>   4┌ 0──∙───── 4┐ 0     ∙   =>
       7^ 0      7^ 0      7^ 0      7^ 0       7^ 0         7^ 0     5
    4┌ 0──∙── 4┐ 0  ∙   4┌ 0──∙── 4┐ 0  ∙      ∙      4┌ 0──∙── 4┐
    7^ 0      7^ 0  5   7^ 0      7^ 0   2I 0       2I 0      7^ 0      7^
   ∙     ∙     ∙     ∙             4┌ 0──∙── 4┐ 0  ∙
    2C 0      2I 0      2S 0     *             7^ 0      7^ 0   2I
                                  ∙     ∙
                                   2S 0     *

                 7^ 0                  7^ 0                     7^ 0          7^
             4┌ 0───∙─── 4┐ 0          4┌ 0───∙─── 4┐ 0             4┌ 0───∙─── 4┐ 0     ∙
             7^ 0        7^ 0          7^ 0        7^ 0             7^ 0        7^ 05    25
   =>     4┌ 0──∙── 4┐ 0    ∙  =>   4┌ 0──∙── 4┐ 0  4┌ 0──∙── 4┐ 0  =>   4┌ 0──∙── 4┐ 0    ∙  =>
          7^ 0      7^ 0    5       7^ 0     │  7^ 0      7^ 0       7^ 0     │     7%
       4┌ 0──∙── 4┐ 0  ∙           ∙     │ ∙     ∙      ∙      4└ 0──── 4┘
       7^ 0      7^ 0   2I 0           *     │  2I 0      7% 05     *
      ∙     ∙                     4└ 0─────── 4┘
       2S 0     *

 ш1.1
   Иллюстрация процесса графовой редукции помогает  _ 1увидеть . 0,  что  в
процессе вычисления имеется всего одна копия объекта 5, которая ис-
пользуется в двух местах. Именно поэтому аргумент функции sqr будет
вычислен всего один раз, каким бы этот аргумент ни был.

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 4.

 ш1.2
                  25. 0  3Графовая редукция комбинатора
                          3неподвижной точки
   Метод ленивой редукции позволяет осуществить и вычисления рекур-
сивных определений,  записанных с использованием  1комбинатора непод-
 1вижной точки 0.
   На рисунке показано  _ 1правило графовой редукции комбинатора непод-
 _ 1вижной точки .  3Y 0 (по [Душкин,2007,с.326]):
 ш1.0

                     4┌ 0─ 4┐
       7^ 0             7^^ 0 │
    4┌ 0──∙── 4┐ 0       4┌ 0──∙── 4┘
    7^ 0      7^ 0  =>   7^
   ∙     ∙      ∙
    2Y 0     X      X

 ш1.2
    2Пример 0 ( 1вычислений с помощью "строковой" и графовой редукции 0)
          (по [Душкин,2007,с.326-327]).
 ш1.1
   Рассмотрим следующую функцию на языке Haskell:
 ш1.0

   -- Функция, конструирующая бесконечный
   -- список натуральных чисел
   ---------------------------
   fn n = n : fn (n+1)
   ----------------------
   test1 = take 10 (fn 1)

 ш1.1
   Приведём детальное описание процесса преобразования соответству-
ющей функции в 7 l 0-терм.  Вначале осуществим некоторые преобразования
в языке Haskell с помощью комбинатора неподвижной точки:
 ш1.0

   -- Функция, конструирующая бесконечный
   -- список натуральных чисел
   ---------------------------
   fn n = n : fn (n+1)
   ---------------------
   fn1 f n = n : f (n+1)
   -----------------------------
   fn2 = y (\f n -> n : f (n+1))
   -------------------------------
   -- Комбинатор неподвижной точки
   -------------------------------
   y f = f (y f)
   ----------------------
   test1 = take 10 (fn 1)
   test2 = take 10 (y fn1 1)
   test3 = take 10 (fn2 1)

 ш1.1
   Другими словами, мы удалили рекурсию в функции fn с помощью ком-
бинатора неподвижной точки:
 ш1.0

   fn n = n : fn (n+1) => fn f n = n : f (n+1) =>

   =>  2Y 0 ( 7l 0f. 7l 0n.pair n f (n+1))= 2Y 0 ( 7l 0f. 7l 0n.pair n (f (add 1 n)))

 ш1.1
   Теперь приведём детальное описание процесса преобразования полу-
ченного  7l 0-терма в комбинаторный терм:
 ш1.0

   (1)  7l 0n.pair n (f (add 1 n))= 2S 0( 7l 0n.pair n)( 7l 0n.f (add 1 n))=

         = 2S 0( 2B 0 pair  2I 0)( 2B 0f( 7l 0n.add 1 n))= 2S 0( 2B 0 pair  2I 0)( 2B 0f( 2B 0(add 1) 2I 0));

   (2)  7l 0f. 2S 0( 2B 0 pair  2I 0)( 2B 0f( 2B 0(add 1) 2I 0))=

         = 2B 0( 2S 0( 2B 0 pair  2I 0))( 7l 0f.( 2B 0f)( 2B 0(add 1) 2I 0))=

         = 2B 0( 2S 0( 2B 0 pair  2I 0))( 2C 0( 7l 0f. 2B 0f)( 2B 0(add 1) 2I 0))=

         = 2B 0( 2S 0( 2B 0 pair  2I 0))( 2C 0( 2BBI 0)( 2B 0(add 1) 2I 0)).

   Осуществим вспомогательные преобразования:

   (а)  2B 0Z 2I 0 =>  2B 0Z 2I 0x=Z( 2I 0x)=Zx =>  2B 0Z 2I 0=Z;

   (б)  2C 0( 2BBI 0)(add 1)x=( 2BBI 0)x(add 1)= 2B 0( 2I 0x)(add 1)= 2B 0x(add 1)=

                     = 2CB 0(add 1)x =>  2C 0( 2BBI 0)(add 1)= 2CB 0(add 1).

   Таким образом, получим

    2B 0( 2S 0( 2B 0 pair  2I 0))( 2C 0( 2BBI 0)( 2B 0(add 1) 2I 0))= 2B 0( 2S 0  1pair 0)( 2CB 0( 1add 0 1)),

а комбинаторный терм выглядит теперь так:

    2Y 0( 2B 0( 2S 0  1pair 0)( 2CB 0( 1add 0 1)))

 ш1.2
   Проведём графовую редукцию полученного комбинатора, применённого
к аргументу 1:
 ш1.0

                 7^ 0                                         7^
           4┌ 0─────∙───── 4┐ 0                               4┌ 0───∙─── 4┐
           7^ 0            7^ 0                               7^ 0        7^
     4┌ 0─────∙───── 4┐ 0     ∙           =>              4┌ 0───∙ 75 0── 4┐ 0   ∙   =>
     7^ 0            7^ 0      31 0                           7^ 0    4└ 0─── 4┘ 0    31
    ∙   4┌ 0────────∙──────── 4┐ 0               4┌ 0────────∙──────── 4┐
     2Y 0   7^ 0                  7^ 0               7^ 0                  7^
    4┌ 0───∙─── 4┐ 0         4┌ 0────∙──── 4┐ 0      4┌ 0───∙─── 4┐ 0         4┌ 0────∙──── 4┐
    7^ 0        7^ 0         7^ 0          7^ 0      7^ 0        7^ 0         7^ 0          7^
   ∙     4┌ 0──∙── 4┐ 0   4┌ 0──∙── 4┐ 0    4┌ 0──∙── 4┐ 0  ∙     4┌ 0──∙── 4┐ 0   4┌ 0──∙── 4┐ 0    4┌ 0──∙── 4┐
    2B 0     7^ 0      7^ 0   7^ 0      7^ 0    7^ 0      7^ 0   2B 0     7^ 0      7^ 0   7^ 0      7^ 0    7^ 0      7^
        ∙     ∙  ∙     ∙   ∙     ∙       ∙     ∙  ∙     ∙   ∙     ∙
         2S 0   pair  2C 0      2B 0  add    1        2S 0   pair  2C 0      2B 0  add    1

                            7^ 0                             7^
                        4┌ 0───∙─── 4┐ 0                   4┌ 0─────∙*
                      * 7^ 0        7^ 0                   7^
   =>             4┌ 0─────∙       ∙   =>     4┌ 0────────∙──────── 4┐
                  7^ 0              31 0          7^ 0                  7^
          4┌ 0───────∙─────── 4┐ 0             4┌ 0──∙── 4┐ 0          4┌ 0────∙──── 4┐
          7^ 0                7^ 0             7^    0   7^ 0          7^ 0          7^
       4┌ 0──∙── 4┐ 0        4┌ 0────∙──── 4┐ 0       ∙     ∙     4┌ 0────∙──── 4┐ 0    ∙
       7^ 0      7^ 0        7^        0  7 ^ 0      pair    31 0     7^ 0          7^ 3    1
      ∙     ∙   4┌ 0────∙──── 4┐ 0    ∙              4┌ 0────∙──── 4┐ 0    ∙
       2S 0   pair  7^ 0          7^ 0    *              7^ 0          7^ 0     3*
             4┌ 0──∙── 4┐ 0    4┌ 0──∙── 4┐ 0             4┌ 0──∙── 4┐ 0    4┌ 0──∙── 4┐
             7^ 0      7^ 0    7^ 0      7^ 0             7^ 0      7^ 0    7^ 0      7^
            ∙     ∙   ∙     ∙            ∙     ∙   ∙     ∙
             2C 0      2B 0  add     31 0             2C 0      2B 0  add     31

                      7^ 0                             7^
                  4┌ 0───∙*                        4┌ 0───∙ 75 0─────────── 4┐
   =>             7^ 0                =>           7^ 0                │
         4┌ 0────────∙──────── 4┐ 0               4┌ 0────∙──── 4┐ 0           │
         7^ 0                  7^ 0               7^ 0          7^ 0           │
      4┌ 0──∙── 4┐ 0          4┌ 0────∙──── 4┐ 0       4┌ 0──∙── 4┐ 0  4┌ 0────∙──── 4┐ 0      │
      7^    0   7^ 0          7^ 0          7^ 0       7^    0   7^ 0  7^ 0          7^ 0      │
     ∙     ∙    4┌ 0─────∙───── 4┐ 0   ∙      ∙     ∙ ∙     4┌ 0────∙──── 4┐ 0 │
    pair    31 0    7^    0         7^ 0    31 0     pair   │ │     7^ 0          7^ 0 │
             4┌ 0──∙── 4┐ 0      4┌ 0──∙── 4┐ 0             │ │  4┌ 0──∙── 4┐ 0     31 0 ∙ │
             7^    0   7^ 0      7^ 0      7^ 0             │ │  7^ 0      7^ 3      7%% 0 │
            ∙     ∙     ∙     ∙             │ │ ∙     ∙     ││ │
             2B 0      3* 0    add     31 0             │ │add    │     ││ │
                                            │ │        4└ 0───── 4┘ 0│ │
                                            │  4└ 0──────────────│─ 4┘
                                             4└ 0──────────────── 4┘

 ш1.2
   Графовая редукция показывает, что вычисление (add 1 1) не произ-
водится,  пока значение этого выражения не потребуется в каком-либо
другом выражении.  Именно поэтому результатом  вычисления  значения
(fn 1) действительно является бесконечный список
 ш1.0

   [1,1+1,1+1+1,...].

 ш1.2
   Вызовы нерекурсивных функций раскладываются на простейшие комби-
наторы и примитивы,  а затем вычисляются. Это происходит один раз и
непосредственно при первой встрече таких функций.  Поэтому програм-
мисты могут определять множество таких функций для упрощения вычис-
лений и повышения уровня читаемости исходного кода.
   Константные выражения также вычисляются один раз и в тот момент,
когда они впервые встречены в коде.
   Хотя такое поведение позволяет  избежать  множества  бесполезных
вычислений, оно может привести к неограниченному росту графа, кото-
рый в конечном итоге может занять всю память.  Это - плата за  воз-
можность работы с потенциально бесконечными структурами данных.
   Итак, трансляция  языков функционального программирования,  т.е.
языков,  математической основой которых  является 7  l 0-исчисление,  в
 7l 0-термы, затем - в комбинаторы, далее - "строковая" редукция и, на-
конец,  последующая редукция полученного выражения на основе  меха-
низма редукции графов дают  _ 1практический способ реализации этих язы-
 _ 1ков . 0.
   Идея представления выражений деревьями  и  определение  редукции
непосредственно в терминах деревьев хотя и применяется при работе с
 7l 0-термами, однако при переходе к комбинаторам этот подход становит-
ся особенно элегантным из-за отсутствия переменных и наличия только
ограниченного числа (по числу базовых комбинаторов) правил преобра-
зования графов (не считая правил,  описывающих действия примитивных
функций).
   Важно отметить, что при применении нормальной редукционной стра-
тегии в этом случае  1автоматически 0 реализуется  1ленивая стратегия вы-
 1числений 0.

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 1.
 ш1.0

   -- Демонстрация моделирования базисных комби-
   -- наторов на языке Haskell
   -- **************************************
   -- Комбинатор B (элементарный композитор)
   -- выражает композицию функций f и g:
   --
   --   Bfg=f(gx)
   -----------------
   b f g x = f (g x)
   ------------------------------------------------
   -- Комбинатор C (элементарный коммутатор) меняет
   -- порядок следования аргументов функции f:
   --
   --   Cfxy=fyx
   ---------------
   c f x y = f y x
   ----------------------------------------------
   -- Комбинатор D (комбинатор упорядоченной пары
   -- или проверка на нуль)
   ------------------------
   d x y z = z (k y) x
   ---------------------------------------
   -- Комбинатор I (комбинатор тождества):
   --
   --   If=f
   -----------
   i f x = f x
   ----------------
   -- Комбинатор J 
   -----------------------
   j x y z w = x y (x w z)
   --------------------------------------------------
   -- Комбинатор K (элементарный канцелятор) выражает
   -- константу c как функцию аргумента x:
   --
   --   Kcx=c
   ----------
   k c x = c
   -------------------------------------------------
   -- Комбинатор S (элементарный коннектор) "распре-
   -- деляет" аргумент x по функциям f и g:
   --
   --   Sfgx=fx(gx)
   -------------------
   s f g x = f x (g x)
   -------------------------------------------------
   -- Комбинатор Sp (комбинатор прибавления единицы)
   -------------------------------------------------
   sp u x y = x (u x y)
   ---------------------------------------------------
   -- Комбинатор W (элементарный дупликатор) дублирует
   -- второй аргумент:
   --
   --   Wfx=fxx
   -------------
   w f x = f x x
   ----------------------------------------------------
   -- Комбинатор Z0 (комбинатор, моделирующий нумерал 0
   -- в нумерации Чёрча)
   ---------------------
   z0 x y = y
   -----------------
   -- Комбинатор phi
   ---------------------------
   phi x y z w = x (y w) (z w)
   ---------------------------
   -- Комбинатор psi
   ---------------------------
   psi x y z w = x (y z) (y w)
   -- *******************************************
   -- Тестирование комбинаторов B, C, I, K, S, W:
   -- *******************************************
   test1 =   b sqrt maximum [4,2,-5,25] == 5.0
          && c (-) 2 3                  == 1
          && c (-) 3 2                  == (-1)
          && i head [5,4,3,2,1]         == 5
          && k 2 3                      == 2
          && s (+) abs (-5)             == 0
          && w (+) 3                    == 6
   --------------------------------------------
   test1' = phi (+) ((** 2).sin) ((** 2).cos) 1
   --------------------------------------------------------
   -- Запись функции w=f(g(h(x,y,z))) в бесточечной нотации 
   ------------------------------------------------------------
   w'   = b (b (b (b f g))) h         -- с помощью комбинаторов
   w''  = (.) ((.) ((.) ((.) f g))) h -- с помощью операции (.)
   w''' = (((f.g).).).h               -- с помощью сечений
                                      -- композиции
   h x y z = x + y + z
   f x     = x^2  
   g x     = x*3
   ---------------------------------
   test2 =   w'  1 2 3 == w''  1 2 3
          && w'' 3 2 1 == w''' 3 2 1
   -------------------------------------------------------
   -- Запись функции r=f1 (f2 x y) z в бесточечной нотации 
   -------------------------------------------------------
   r' = (f1.).f2
   f1 x y = x^y
   f2 x y = x+y
   ---------------------------------
   test3 = r' 31 42 53 == (31+42)^53
 ш1.2

    2Пример 2.
 ш1.0

   -- Демонстрация:
   --  (1) моделирования комбинатора неподвижной точки
   --      на языке Haskell;
   --  (2) использования комбинатора  неподвижной точ-
   --      ки для моделирования рекурсивных вычислений
   -- ************************************************
   -- Функция, моделирующая комбинатор неподвижной
   -- точки Y по определению:
   --
   --   Yf=f(Yf)
   -------------
   y f = f (y f)
   -- ****************************************************
   -- Демонстрация моделирования рекурсии в языке Haskell,
   -- основанного на теореме о неподвижной точке:
   --   для любого терма F если x=Fx, то x=YF
   -- ******************************************
   -- Пример 1. Рассмотрим нерекурсивную функцию 
   --           z = \x -> x+1
   --------------------------
   z = \x -> x+1
   ---------------------------------------------------
   --           По функции z() построим функционал z':
   ---------------------------------------------------
   z' = \f -> \x -> x+1
   --------------------------------------------------------
   -- Пример 2. Рассмотрим в качестве функции F рекурсивную
   --           функцию, вычисляющую факториал числа x
   ---------------------------------------------------
   f:: Num a => a -> a
   f x | x==1 = 1
       | True = x*f (x-1)
   ---------------------------------------------------
   --           По функции f() построим функционал f':
   ---------------------------------------------------
   f':: Num a => (a -> a) -> a -> a
   f' fun x | x==1 = 1
            | True = x*fun (x-1)
   ---------------------------------------------
   -- Пример 3. Проведём аналогичные манипуляции
   --           с функционалом map'
   --------------------------------
   map':: (a -> b) -> [a] -> [b]
   map' f []     = []
   map' f (x:xs) = f x : map' f xs
   -----------------------------------------------------------
   --           По функционалу map' построим функционал map'':
   -----------------------------------------------------------
   map'':: ((a -> b) -> [a] -> [b]) -> (a -> b) -> [a] -> [b]
   map'' f1 f []     = []
   map'' f1 f (x:xs) = f x : f1 f xs
   ---------------------------------------------
   -- Пример 4. Проведём аналогичные манипуляции
   --           с функционалом filter'
   -----------------------------------
   filter':: (a -> Bool) -> [a] -> [a]
   filter' p []     = []
   filter' p (x:xs) | p x  = x : filter' p xs
                    | True = filter' p xs
   -------------------------------------------------------
   --           По функционалу filter' построим функционал
   --           filter'':
   -----------------------------------------------------
   filter'':: ((a -> Bool) -> [a] -> [a]) -> (a -> Bool)
                           -> [a] -> [a]
   filter'' f1 p []     = []
   filter'' f1 p (x:xs) | p x  = x : f1 p xs
                        | True = f1 p xs
   --------------------------------------------------------
   -- Пример 5. Реализация бесконечного циклического списка
   --           с использованием комбинатора Y
   -------------------------------------------
   l lst = take 20 (y (\x -> lst ++ x))
   -- *********************************
   -- Неудачные тестовые примеры:
   ------------------------------
   test1 = y z' 12 == 13
   -----------------------------------------------------
   test2 =   f 10              ==             y f'    10 
          && y         f'   10 == f'         (y f')   10   
          && f'     (y f')  10 == f'     (f' (y f'))  10
          && f' (f' (y f')) 10 == f' (f' (f' (y f'))) 10
   -----------------------------------------------------
   test3 = y map'' (^2) [1..5] == map' (^2) [1..5]
   test4 = y map'' sin [1..7]  == map' sin [1..7]
   ----------------------------------------------
   test5 = y filter'' (>0) [1,-1,2,-2,3,-3]
                               == filter' (>0) [1,-1,2,-2,3,-3]
 ш1.2

    2Пример 3.
 ш1.0

   -- Демонстрация использования комбинатора неподвижной точки
   -- ********************************************************
   -- Определение комбинатора неподвижной точки
   --------------------------------------------
   fix f = f (fix f)
   -- ***********************************************
   -- Функция repeat' конструирует бесконечный список
   -- из одного заданного элемента.
   -- Детализируем процесс вычислений:
   --
   -- take 3 (fix (1:)) -> take 3 (1:fix (1:))
   --                   -> 1:take 2 (fix (1:))
   --                   -> 1:(1:take 1 (fix (1:)))
   --                   -> 1:(1:(1:take 0 (fix (1:))))
   --                   -> 1:(1:(1:[]))
   --                   -> 1:(1:[1]) -> 1:[1,1]
   --                   -> [1,1,1]
   -------------------------------
   repeat' n = fix (n : )
   -- ***********************************************
   -- Функция, "готовая" к использованию вместе с fix
   --------------------------------------------------
   fact f = \x -> if x==0 then 1 else x * f (x-1)
   -- ***************************************************
   -- Функция возвращает  все последовательности длины k,
   -- состоящие из  чисел  от 1 до n, и такие, что не су-
   -- ществует двух рядом стоящих одинаковых чисел
   -----------------------------------------------
   sequen n k = fix (allDiffCore n) k (\x -> True)
   -----------------------------------------------
   allDiffCore n f =
        \k cond -> if k==1
                     then map (\x -> [x]) $ filter cond [1..n]
                     else concat $ map (\x -> map (x:)
                                                  (f (k-1) (/=x)))
                                       (filter cond [1..n])
   -- ******************************************************
   -- Функция возвращает все возрастающие последовательности
   -- длины k, состоящие из чисел от 1 до n
   -------------------------------------------------
   sequen' n k = fix (allDiffCore' n) k (\x -> True)
   -------------------------------------------------
   allDiffCore' n f =
        \k cond -> if k==1
                     then map (\x -> [x]) $ filter cond [1..n]
                     else concat $ map (\x -> map (x:)
                                                  (f (k-1) (>x)))
                                       (filter cond [1..n])
   -- *****************************************************
   -- Неудачные тестовые примеры:
   ---------------------------------------------------
   -- Применение комбинатора fix к постоянной функции:
   --
   -- fix const -> const (fix const) -> 45
   ---------------------------------------
   test1 = fix const45
      where const45 x = 45
   --------------------------------------
   -- Конструирование бесконечного списка
   --------------------------------------
   test2 = repeat' 12         
   -----------------------------------
   -- Конструирование конечного списка
   -----------------------------------
   test3 = take 5 (repeat' 1) 
   ------------------------------------------
   -- Функция возвращает факториал числа 1500
   ------------------------------------------
   test4 = fix fact 1500 == product [1..1500]
   ------------------------------------------
   test5 = sequen 4 3
   test6 = sequen' 10 5
 ш1.2

    2Пример 4.
 ш1.0

   -- Демонстрация строковой редукции комбинаторного выражения.
   -- Программа работает в интерпретаторе ghci.
   --
   -- Автор: Москвин Д.Н. (20.02.2007)
   -----------------------------------
   module StrRed
   where
   -------------------------------------
   -- Структура абстрактного типа данных
   --------------------------------------
   data Cmb =  Cmb String   -- комбинатор
             | (:#) Cmb Cmb -- аппликация комбинаторов - комбинатор
                            -- (инфиксный конструктор)
      deriving (Eq)
   -----------------------
   instance Show Cmb where
      show (Cmb x)   = x
      show (ts :# t) = case t of _ :# _ -> show ts ++ 
                                               "(" ++ show t ++ ")"
                                 _      -> show ts ++ show t
   -------------------------------------------------------------
   -- Представление инфиксного  конструктора применения (:#) ле-
   -- воассоциативным с приоритетом 5,  чтобы запись комбинатор-
   -- ного выражения была без лишних скобок. Например, выражение 
   -- (SK)K==SKK
   -- будет представимо строкой
   -- s:#k:#k
   -----------------------------------------------
   -- Замечание. Возможна запись instance Read Cmb
   -----------------------------------------------
   infixl 5 :#
   -----------------------
   -- Основные комбинаторы
   -------------------------
   b = Cmb "B" -- композитор
   w = Cmb "W" -- дубликатор
   k = Cmb "K" -- канцелятор
   i = Cmb "I" -- бездельник
   s = Cmb "S" -- коннектор
   c = Cmb "C" -- пермутатор
   ----------------------------------
   -- Неспецифицированные комбинаторы
   ----------------------------------
   x = Cmb "x"
   y = Cmb "y"
   z = Cmb "z"
   t = Cmb "t"
   u = Cmb "u"
   v = Cmb "v"
   --------------------------------------------------
   -- Функция пошагового вывода результата применения 
   -- комбинаторов в комбинаторном выражении
   -----------------------------------------
   modN:: Cmb -> String
   modN cmb = let res = mod1 cmb 
              in if res == cmb then (show cmb) 
                               else ((show cmb) ++ " -> " 
                                                ++ modN res)
   ---------------------------------------------------------
   -- Функция применения  самого  левого комбинатора в 
   -- комбинаторном выражении, который можно применить
   ---------------------------------------------------
   mod1:: Cmb -> Cmb
   mod1 (Cmb c) = (Cmb c)
   ---------------------------
   -- Применение комбинатора I
   ---------------------------
   mod1 ((Cmb c) :# t) 
             | c == "I"   = t
             | True       = (Cmb c) :# mod1 t
   ------------------------------------------
   -- Применение комбинаторов W, K
   -------------------------------
   mod1 ((Cmb c) :# t :# s)
             | c == "W"   = t :# s :# s
             | c == "K"   = t
             | True  = mod1' ((Cmb c) :# t) s
   ------------------------------------------
   -- Применение комбинаторов B, S, C
   ----------------------------------
   mod1 ((Cmb c) :#t :# s :# u)
             | c == "B"  = t :# (s :# u)
             | c == "S"  = t :# u :# (s :# u)
             | c == "C"  = t :# u :# s
             | True  = mod1' ((Cmb c) :# t :# s) u
   -----------------------------------------------
   mod1 (ts :#t :# s :# u) = mod1' (ts :#t :# s) u
   ------------------------------------------------
   -- Функция, выявляющая в комбинаторном выражении 
   -- применимый комбинатор и применяет его
   ----------------------------------------
   mod1' :: Cmb -> Cmb -> Cmb
   mod1' c1 c2 = let res = mod1 c1
                 in if res == c1 then c1 :# mod1 c2 
                                 else res :# c2
   --------------------------------------------
   -- Набор комбинаторов:
   ----------------------
   -- B в базисе SK
   -----------------------------
   b_sk = s:#(k:#s):#k :#x:#y:#z
   -----------------------------
   -- W в базисе SK
   -------------------------------------
   w_sk = s:#s:#(k:#(s:#k:#k)) :#x:#y:#z
   -------------------------------------
   -- C в базисе SK
   ---------------------------------------------------------------
   c_sk = s:#((s:#(k:#s):#k):#(s:#(k:#s):#k):#s):#(k:#k) :#x:#y:#z
   ---------------------------------------------------------------
   -- I в базисе SK
   ------------------
   i_sk = s:#k:#k :#x
   -----------------------------------------
   -- Комбинатор неподвижной точки Y (Карри)
   -----------------------------------------
   yCurry = s:#(b:#w:#b):#(b:#w:#b) :#x
   ------------------------------------------
   -- комбинатор неподвижной точки Y (Тромпа)
   ---------------------------------------------------------
   yTromp = s:#s:#k:#(s:#(k:#(s:#s:#(s:#(s:#s:#k)))):#k) :#x
   ---------------------------------------------------------
   -- Комбинатор, не имеющий нормальной формы
   ------------------------------------------
   noNF = s:#i:#i:#(s:#i:#i) :#x:#y
   --------------------------------
   -- Неудачные тестовые примеры:
   ------------------------------
   test1 = modN b_sk ==
           "S(KS)Kxyz -> KSx(Kx)yz -> S(Kx)yz -> Kxz(yz) -> x(yz)"
   test2 = modN (c:#i:#x:#(s:#y:#i))
   test3 = modN yCurry
   -- "S(BWB)(BWB)x -> BWBx(BWBx) -> W(Bx)(BWBx) -> 
   -- Bx(BWBx)(BWBx) -> x(BWBx(BWBx)) -> x(W(Bx)(BWBx)) -> 
   -- x(Bx(BWBx)(BWBx)) -> x(x(BWBx(BWBx))) -> x(x(W(Bx)(BWBx))) ->
   -- x(x(Bx(BWBx)(BWBx))) -> x(x(x(BWBx(BWBx)))) -> {Interrupted!}"
 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                       1Я хочу, чтобы компьютер был моим слугой, а не
                       1господином,  поэтому я должен уметь быстро  и
                       1эффективно 0  1объяснить ему, что делать.
                                                          1Ю.Мацумото
 ш1.2

                21. 0  3Синтаксис бестипового 2  7l 2- 3исчисления
    21. 0 Напишите на языке программирования Haskell программу, распоз-
нающую: (а)  7l 0-терм; (б)  7l 0-формулу.
    22. 0 Напишите на языке программирования Haskell функцию для вычис-
ления  1ранга 0  7l 0-терма.
    23. 0 Напишите на языке программирования Haskell функцию, реализую-
щую операцию " 1подстановка 0  7l 1-терма вместо свободного вхождения пред-
 1метной переменной 0".
    24 5* 2. 0 (По [Барендрегт,1985,с.37])
   Напишите на языке программирования Haskell функцию, распознающую
 1дизъюнктность 0 двух заданных 7 l 0-термов.
                22. 0  3Синтаксис исчисления комбинаторов
    21. 0 Напишите на языке программирования Haskell функцию, распозна-
ющую: (а) CL-терм; (б) CL-формулу.
    22. 0 Напишите на языке программирования Haskell функцию для вычис-
ления  _ 1ранга . 0  1CL- _терма . 0, определяемого следующим образом:
 ш1.0

            7( 00, если M 7= 0x 4i 0, i 7е ═N 0;
           │
    1rank 0(M) ═+ 7* 00, если M 7= 0(N 41 0N 42 0), где N 41 0,N 42 7е 0T 4CL 0;
           │
            79 01+ 1rank 0(M), если M 7= 2K  0или M 7= 2S 0.

 ш1.2
    23. 0 Напишите на языке программирования Haskell функцию, реализую-
щую  операцию " 1подстановка 0  1CL-терма вместо вхождения предметной пе-
 1ременной 0".
    24. 0 Напишите на языке программирования Haskell функцию для нахож-
дения по заданному CL-терму его гёделевого номера.
    25 5* 2. 0 Напишите  на  языке программирования Haskell функцию для на-
хождения CL-терма по его гёделевому номеру.
                  23. 0  3Связь исчисления комбинаторов
                           3и 0  7l 3-исчисления
    21. 0 Напишите на языке программирования Haskell функцию,  преобра-
зующую произвольный  7l 0-терм в базис {I, 2K 0, 2S 0}.
    22. 0 Напишите на языке программирования Haskell функцию,  преобра-
зующую произвольный  7l 0-терм в базис {I, 2K 0, 2S 0,B,C}.
    23. 0 Напишите на языке программирования Haskell функцию,  преобра-
зующую произвольный  7l 0-терм в базис {B,W,C, 2K 0}.
    24 5* 2. 0 Напишите на языке программирования Haskell функцию, преобра-
зующую произвольный комбинатор в базисе {I, 2K 0, 2S 0} в  7l 0-терм.
    25 5* 2. 0 Напишите на языке программирования Haskell функцию, преобра-
зующую произвольный комбинатор в базисе {I, 2K 0, 2S 0,B,C} в  7l 0-терм.
    26 5* 2. 0 Напишите на языке программирования Haskell функцию, преобра-
зующую произвольный комбинатор в базисе {B,W,C, 2K 0} в  7l 0-терм.
    27 4* 2. 0 Проверьте  с помощью программного обеспечения ( 1какого 0?) пра-
вильность представлений следующих комбинаторов:
 ш1.0

   I= 2SKK 0, B= 2S 0( 2KS 0) 2K 0, W= 2SS 0( 2K 0( 2SKK 0)), C= 2S 0(( 2S 0( 2KS 0) 2K 0)( 2S 0( 2KS 0) 2K 0) 2S 0)( 2KK 0).

 ш1.2
                        24. 3 Строковая редукция
    21. 0 Преобразуйте следующие  7l 0-термы в базисе 1  0{I, 2K 0, 2S 0,B,C}:
 ш1.0

   (а)  7l 0x.Mx, x 7Е 0FV(M);  (г)  7l 0x. 7l 0y.yx;
   (б)  7l 0x. 7l 0y.Ix;        (д)  7l 0x. 7l 0y.fxy.
   (в)  7l 0x. 7l 0y.Iy;

 ш1.2
                        25. 3 Графовая редукция
    21 4* 2. 0 Проведите графовую редукцию для комбинаторов:
 ш1.0

   (а)  2S 0( 2KS 0) 2K 0xyz; (б)  2S 0( 2KS 0) 2K 0fgx; (в) C(BBI)(add 1)x.

 ш1.2
    22 4* 2. 0 Изобразите процесс графовой редукции применения  2Y 0a  комбина-
тора неподвижной точки  2Y ═+ 0W 2S 0(BWB).
 ш1.1
    _ 1Указание . 0.
 ш1.0

   Y ═f+ 0W 2S 0(BWB) ═f 0= 2S 0(BWB)(BWB) ═f 0=(BWB ═f 0)(BWB ═f 0)=W(B ═f 0)(BWB ═f 0)=

              =B ═f 0(BWB ═f 0)(BWB ═f 0)= ═f 0(BWB ═f 0(BWB ═f 0))= ═f 0( _ 2S 0(BWB)(BWB) . ═f 0)= ═f 0(Y ═f 0).
 ш1.2
