>  import Prelude hiding (curry,uncurry)

    2УПРАЖНЕНИЕ 0  21.
    2ЭЛЕМЕНТЫ БЕСТИПОВОГО  7l 2-ИСЧИСЛЕНИЯ 0  2В ЯЗЫКЕ Haskell

    _ 1Вспомогательные понятия . 0:
 ш1.0


 ш1.2
    _ 1Основные понятия . 0:
 ш1.0



 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
    2Определение 0 ( 1содержательное 0) (по [Филд,Харрисон,1993,с.121]).
 ш1.1
    7l 0- _ 1исчисление . 0 - это исчисление  анонимных  ( 1безымянных 0)  функций,
которое предоставляет:
   (1) метод представления функций и  способов  их  комбинирования,
который изучает функции в 3  0связи с их  1аппликативным 0 (англ.   1applica-
 1tion 0 -  1приложение 0) поведением. Поэтому  1аппликация 0 (применение функ-
ции к аргументу) является исходной операцией  7l 0-исчисления;
   (2) множество  правил  вывода для синтаксического преобразования
функций.
 ш1.2

                       2Бестиповое 0  7l 0- 2исчисление
                       2как формальная система
                        21. 0  3Язык 0  7l 1- 3исчисления
   Определим язык 7 l 0-исчисления как язык в некотором алфавите.
    2Определение 0.
 ш1.1
    _ 1Алфавит бестипового .  7l 1- _исчисления . 0 (обозначается  7Aд 0)  -  это  мно-
жество
 ш1.0

    7Aд ═+ 0G 41 7u 0G 42 7u 0G 43 7u 0G 44 0,

 ш1.1
    2(1) 0 G 41 ═+ 0{x 41 0,x 42 0,x 43 0,...} -  1множество предметных переменных 0;
    2(2) 0 G 42 ═+ 0{=}  -  1множество предикатных символов 0;  "=" - двухместный
предикатный символ (читается: " 1равно 0" или " 1конверсия 0");
    2(3) 0 G 43 ═+ 0{ 7l 0} -  1множество логических  символов 0;  " 7l 0"  -  логический
символ (читается: " 1лямбда 0", " 1абстрактор 0", " 1функция от 0");
    2(4) 0 G 44 ═+ 0{ 2( 0, 2) 0, 2. 0} -  1множество вспомогательных символов 0;  символ " 2( 0"
читается: " 1открывающая скобка 0",  символ " 2) 0" читается:  " 1закрывающая
 1скобка 0"), символ " 2. 0" читается: " 1точка 0", " 1которая возвращает 0".

 ш1.2
   Определим индуктивно  понятие " 7l 0- 1терм 0" (" 1лямбда-терм 0" или просто
" 1терм 0").
   В метаязыке,  предназначенном для описания  7l 1- 0исчисления,  7l 0-термы
будем обозначать  1прописными латинскими буквами 0,  а предметные пере-
менные -  1строчными латинскими буквами 0.
    2Определение 0.
 ш1.1
    2(1) 0 Предметные переменные являются  7l 0- _ 1термами . 0.
    2(2) 0 Если M и N -  7l 0-термы,  то  2( 0MN 2) 0 (читается: " 1аппликация 0  7l 1-тер-
 1мов M и 0  1N 0") является  7l 0- _ 1термом . 0.
    2(3) 0 Если M -  7l 0-терм, а х - предметная переменная, то  2( 7l 0х.М 2) 0 (чи-
тается: " 1абстракция 0  7l 1-терма M 0") является  7l 1- _термом . 0.
   При этом x будем называть  _ 1переменной абстракции . 0,  а  7l 1- 0терм  M  -
 _ 1телом абстракции . 0.
    2(4) 0 Других  7l 0-термов, кроме построенных по пп.(1)-(3), нет.

 ш1.2

>  data Lambda =   Var String        -- Предметная переменная
>                | App Lambda Lambda -- Аппликация
>                | Lam String Lambda -- Абстракция
>    deriving Eq

   -- ****************************************
   -- Функции для представления лямбда-термов:
   -------------------------------------------

>  lam41 = App (Lam "x" (App (Var "x") (Var "y")))
>              (Lam "y" (Var "y"))
   
>  lam42 = Lam "x" (Lam "y"
>                    (App (Var "z")
>                         (Lam "z" (App (Var "z")
>                                  (Lam "x" (Var "y"))))))
   
>  lam43 = App (Lam "y" (App (App (Var "x") (Var "y"))
>                            (Var "z")))
>              (Lam "z" (Lam "x" (App (Var "x") (Var "y"))))
   
>  lam44 = App (Lam "x" (Lam "y" (App (Var "x")
>                                     (Lam "z" (App (Var "y")
>                                                   (Var "z"))))))
>              (Lam "x" (Lam"y" (Var "z")))

    _ 1Соглашения об обозначениях . 0  7l _ 1-термов . 0.
 ш1.1
   При записи  7l 0-термов в  метаязыке  часто  используются  следующие
 _ 1соглашения об обозначениях . 0,  позволяющие при записи   7l 0-термов опус-
кать скобки и повторяющиеся символы 7 l 0:
   (а)  _ 1соглашение о восстановлении скобок по ассоциативности влево . 0:
слово метаязыка
 ш1.0

   M 41 0M 42 0...M 4n 0

является сокращённой записью  7l 0-терма

   (...((M 41 0M 42 0)M 43 0)...M 4n 0);

 ш1.1
   (б)  _ 1соглашение об опускании повторяющихся символов . 0  7l 0  _ 1и о восста-
 _ 1новлении скобок по ассоциативности вправо . 0: слово метаязыка
 ш1.0

    7l 0x 41 0х 42 0...х 4n 0.M

является сокращённой записью  7l 0-терма

   ( 7l 0x 41 0.( 7l 0х 42 0.(...( 7l 0х 4n 0.M)...)))

 ш1.1
(говорят, что "тела абстракций простираются  1направо 0 максимально да-
леко");
   (в)  _ 1обобщающее соглашение . 0: слово метаязыка
 ш1.0

    7l 0x 41 0х 42 0...х 4n 0.M 41 0M 42 0...M 4k

является сокращённой записью  7l 0-терма

   ( 7l 0x 41 0.( 7l 0х 42 0.(...( 7l 0х 4n 0.(...((M 41 0M 42 0)M 43 0)...M 4k 0))...))).

 ш1.2
    2Примеры 0.
 ш1.0

   ┌──────────────────────────────────┬──────────────────┐
   │               7l 3-терм 0              │ 3Сокращённая запись 0│
   │                                  │    3в метаязыке 0    │
   ╞══════════════════════════════════╪══════════════════╡
   │ (((M 41 0M 42 0)M 43 0)M 44 0)                   │ M 41 0M 42 0M 43 0M 44 0         │
   │                                  │                  │
   │ (((xz)y)z)                       │ xzyz             │
   │                                  │                  │
   │ ((xz)(yz))                       │ xz(yz)           │
   │                                  │                  │
   │ ( 7l 0x 41 0.( 7l 0х 42 0.( 7l 0х 43 0.M)))              │  7l 0x 41 0х 42 0х 43 0.M        │
   │                                  │                  │
   │ ( 7l 0x 41 0.( 7l 0х 42 0.( 7l 0х 43 0.(((M 41 0M 42 0)M 43 0)M 44 0)))) │  7l 0x 41 0х 42 0х 43 0.M 41 0M 42 0M 43 0M 44 0 │
   └──────────────────────────────────┴──────────────────┘

 ш1.2
    2Определение 0 ( 1Х.Карри 0).
 ш1.1
   Символом " 7= 0" метаязыка будем обозначать бинарное отношение " _ 1гра-
 _ 1фическое  равенство . 0  7l 1- _термов . 0",  устанавливающее их полное синтакси-
ческое совпадение.
   Другими словами, будем употреблять запись
 ш1.0

   M 7= 0N

для обозначения  1побуквенного совпадения 0  7l 0-термов M и N.

 ш1.2
    2Определение 0 (по [Барендрегт,1985,с.35]).
 ш1.1
    _ 1Длиной . 7 l 0- _ 1терма . 0  1M 0 (обозначается ║M║) называется количество симво-
лов в записи 7 l 0-терма.

 ш1.2
    2Определение 0.
 ш1.1
    _ 1Рангом . 0  7l 0- _ 1терма . 0 называется функция  1rank 0: 7L 0─ 76 ═N 0, определяемая следу-
ющим индуктивным образом:
 ш1.0

            7( 00, если M 7= 0x 4i 0, i 7е ═N 0;
           │
    1rank 0(M) ═+ 7* 1rank 0(N 41 0)+ 1rank 0(N 42 0), если M 7= 2( 0N 41 0N 42 2) 0, N 41 0N 42 7еL 0;
           │
            79 01+ 1rank 0(N), если M 7= 2( 7l 0x.N 2) 0, N 7еL 0.

 ш1.2
    _ 1Соглашение об обозначениях . 0.
 ш1.1
   Обозначим  7L 0 - множество  7l 0-термов.

 ш1.2
   Пусть M,N 7еL 0.
    2Определение 0.
 ш1.1
    _ 1Формулой бестипового .  7l 1- _исчисления . 0 ( 7l 0- _ 1формулой . 0 или просто   _ 1форму-
 _ 1лой . 0) называется слово вида:
 ш1.0

   M=N.

 ш1.2
    _ 1Соглашение об обозначениях . 0.
 ш1.1
   Обозначим F 7д 0 - множество  7l 0-формул.

 ш1.2
    2Определение 0.
 ш1.1
    _ 1Языком . 0  7l 1- _исчисления . 0 (или  7l 1- _языком . 0) называется кортеж
 ш1.0

   L 7д ═+ 2< 7Aд 0, 7L 0,F 7д 2> 0.

 ш1.2
                 22. 0  3Свободные и связанные переменные
    2Определение 0 (по [Барендрегт,1985,с.37]).
 ш1.1
    _ 1Множество подтермов .  7l 0- _ 1терма . M 0  (обозначается   1Sub 0(M))  определим
индуктивно следующим образом:
 ш1.0

    2(1) 0  1Sub 0(x) ═+ 0{x}, если x 7е 0G 41 0;

           4┌ 0       4┐
    2(2) 0  1Sub 0│ 2( 0M 41 0M 42 2) 0│ ═+ 0{M 41 0M 42 0} 7u 1Sub 0(M 41 0) 7u 1Sub 0(M 42 0), если M 41 7еL 0, M 42 7еL 0;
           4└ 0       4┘
           4┌ 0       4┐
    2(3) 0  1Sub 0│ 2( 7l 0x.M 2) 0│ ═+ 0{ 7l 0x.M} 7u 1Sub 0(M), если M 7еL 0.
           4└ 0       4┘

 ш1.2

>  sub:: Lambda -> [Lambda]
>  sub (Var y)     = povto [Var y]
>  sub (App e1 e2) = povto ([App e1 e2] ++ sub e2 ++ sub e1)
>  sub (Lam y e)   = povto ([Lam y e] ++ sub e)

>  -- Функции для представления ламбда-термов:

>  lam11 = Lam "x" (App (App (Var "x") (Var "y"))
>                       (Lam "z" (Var "y")))
>  lam12 = Lam "x" (App (Var "y") (Var "x"))

>  test1 =   show (sub lam11)
>                == "[\\x.xy(\\z.y),xy(\\z.y),\\z.y,y,xy,x]"
>         && show (sub lam12)
>                == "[\\x.yx,yx,x,y]"

    2Определение 0.
 ш1.1
    7l 0- _ 1подтермом . 0  1M  7l 0- _ 1терма . 0  1N 0 будем называть  7l 0-терм M 7е 1Sub 0(N).

 ш1.2
    7l 0-термы являются   1словами  в  алфавите бестипового  7l 1-исчисления 0,
поэтому для  7l 0-термов определено отображение  " 1вхождение  предметной
 1переменной в  7l 1-терм 0".
    2Определение 0.
 ш1.1
    2(1) 0  _ 1Связанным вхождением предметной переменной . x  _в . 0  7l 0- _ 1терм . M 0  на-
зывается вхождение предметной переменной x в  7l 0-терм M, для которого
 1существует 0 такой  7l 0-терм N, что
 ш1.0

    2( 7l 0x.N 2) 7е 1Sub 0(M).

 ш1.1
    2(2)  _ 1Свободным вхождением предметной переменной . x  _в . 0  7l 0- _ 1терм . 0  1M 0  на-
зывается вхождение предметной переменной x в  7l 0-терм M, для которого
не существует такого  7l 0-терма N, что
 ш1.0

    2( 7l 0x.N 2) 7Е 1Sub 0(M).

 ш1.2
    2Определение 0.
 ш1.1
    2(1) 0  _ 1Свободной предметной переменной . 0  7l 0- _ 1терма . M 0  называется  пред-
метная  переменная,  имеющая  хотя  бы  одно  свободное вхождение в
 7l 0-терм M.
    2(2) 0  _ 1Связанной предметной переменной . 0  7l 0- _ 1терма . M 0  называется  пред-
метная переменная,  имеющая хотя  бы  одно  связанное  вхождение  в
 7l 0-терм M.

 ш1.2
    2Примеры 0.
 ш1.1
    21. 0 В  7l 0-терме  2( 7l 0z.x 2)( 7l 0y.yx 2( 7l 0x.yzx 2)) 0 самое левое вхождение z явля-
ется связанным, а самое правое - свободным; два самых левых вхожде-
ния x являются свободными, а два самых правых - связанными; все три
вхождения y являются связанными.
   Сказанное представим так:
 ш1.0

      7^    0  7 ^ ^  0  7 ^ ^ ^ 0    1Связанные переменные
    2( 7l _ 0z ..x 2)( 7l _ 0y ..yx 2( 7l _ 0x ..yzx 2))
                 ═└ 0─ ═┬ 0── ═┘
     ═└ 0─ ═┬ 0─ ═┘ 0  ═└ 0──── ═┬ 0───── ═┘
        7%  0  7    %     % 0     1Свободные переменные

 ш1.1
    22. 0 В  7l 0-терме  2( 0x 2( 7l 0x.x 2)) 0 предметная переменная x является одновре-
менно и свободной, и связанной.

 ш1.2

>  free:: [Char] -> Lambda -> Bool
>  free x (Var y)     = x==y
>  free x (App e1 e2) = free x e1 || free x e2
>  free x (Lam y e)   = x/=y && free x e

>  -- Функции, представляющие ламбда-термы:

>  lam21 = Lam "x" (Lam "y" (Lam "z"
>                (App (Var "x") (App (Var "y") (Var "z")))))
>  lam22 = Lam "x" (Lam "y" (Lam "z"
>                (App (App (Var "x") (Var "z")) (Var "y"))))
>  lam23 = Lam "x" (Lam "y"
>                (App (App (Var "x") (Var "y")) (Var "y")))
>  lam24 = App (Lam "x" (App (Var "x") (Var "y")))
>              (Lam "y" (Var "y"))
>  lam25 = Lam "x" (App (Var "b") (App (Var "f")
>                  (App (Var "a") (Var "x"))))

>  test2 =   not (free "x" lam21) && not (free "y" lam21)
>         && not (free "z" lam21) && not (free "x" lam22)
>         && not (free "y" lam22) && not (free "z" lam22)
>         && not (free "x" lam23) && not (free "y" lam23)
>         && not (free "x" lam24) &&      free "y" lam24
>         && not (free "x" lam25) &&      free "b" lam25
>         &&      free "f" lam25  &&      free "a" lam25

>  notfree:: [Char] -> Lambda -> Bool
>  notfree x (Var y)     = False
>  notfree x (App e1 e2) = notfree x e1 || notfree x e2
>  notfree x (Lam y e)   = x==y || notfree x e

>  -- Функции для представления лямбда-термов:

>  lam31 = App (Lam "v" (Var "x"))
>              (Lam "y" (App (App (Var "y") (Var "x"))
>                            (Lam "x" (App (App (Var "y") (Var "v"))
>                                          (Var "x")))))

>  lam32 = Lam "x" (Lam "y" (App (Var "z")
>                           (Lam "z" (App (Var "z")
>                                         (Lam "x" (Var "y"))))))

>  test3 =   notfree "v" lam31  -- lam1=(\v.x)(\y.yx(\x.yvx))
>         && notfree "y" lam31
>         && notfree "x" lam31
>         && notfree "x" lam32  -- lam2=\x.\y.z(\z.z(\x.y))
>         && notfree "y" lam32
>         && notfree "z" lam32

    2Определение 0 (по [Барендрегт,1985,с.36]).
 ш1.1
    _ 1Множество 0  1свободных переменных .  7l 1- _терма . 0   1M 0  (обозначается  FV(M))
определим индуктивно:
 ш1.0

    2(1) 0 FV(x) ═+ 0{x};   2(2) 0 FV(MN) ═+ 0FV(M) 7u 0FV(N);   2(3) 0 FV( 7l 0x.M) ═+ 0FV(M)\{x}.

 ш1.2

   -- Демонстрация функции, возвращающей множество 
   -- свободных переменных заданного терма
   -- ************************************

>  mn_free:: Lambda -> [[Char]]
>  mn_free (Var y)     = [y]
>  mn_free (Lam y e)   = povto (filter (y/=) (mn_free e))
>  mn_free (App e1 e2) = povto (mn_free e1 ++ mn_free e2)

>  test4 =   mn_free lam41 == ["y"]
>         && mn_free lam42 == ["z"]
>         && mn_free lam43 == ["x","z","y"]
>         && mn_free lam44 == ["z"]

    2Определение 0.
 ш1.1
    _ 1Множество 0  1связанных переменных .  7l 1- _терма . 0   1M 0  (обозначается  CV(M))
определим индуктивно:
 ш1.0

    2(1) 0 CV(x) ═+ 7' 0;   2(2) 0 CV(MN) ═+ 0CV(M) 7u 0CV(N);   2(3) 0 CV( 7l 0x.M) ═+ 0{x} 7u 0CV(M).

 ш1.2
    2Примеры 0.
 ш1.0

         4┌ 0                      4┐
    21.  0FV│ 2( 7l 0z.x 2)( 7l 0y.yx 2( 7l 0x.yzx 2)) 0│ ═+ 0FV( 7l 0z.x) 7u 0FV( 7l 0y.yx( 7l 0x.yzx)) ═+
         4└ 0                      4┘
        4┌ 0        4┐ 0  4┌ 0                   4┐ 0  4┌ 0        4┐ 0  4┌ 0            4┐
       ═+ 0│{x}\{z}│ 7u 0│FV(yx( 7l 0x.yzx))\{y}│ ═+ 0│{x}\{z}│ 7u 0│{y,x,z}\{y}│={x,z}.
        4└ 0        4┘ 0  4└ 0                   4┘ 0  4└ 0        4┘ 0  4└ 0            4┘
         4┌ 0                      4┐ 0    4┌ 0     4┐ 0    4┌ 0              4┐
    22.  0CV│ 2( 7l 0z.x 2)( 7l 0y.yx 2( 7l 0x.yzx 2)) 0│ ═+ 0CV│ 7l 0z.x│ 7u 0CV│ 7l 0y.yx( 7l 0x.yzx)│ ═+
         4└ 0                      4┘ 0    4└ 0     4┘ 0    4└ 0              4┘
                        4┌ 0           7)
       ═+ 0{z} 7u 0CV(x) 7u 0{y} 7u 0CV│yx( 7l 0x.yzx) 72 ═+ 0{z,y} 7u 0{x}={x,y,z}.
                        4└ 0           70

 ш1.2
               3Работа с примерами решённых упражнений
 ш1.1
   См. Пример 1.

 ш1.2

   -- Демонстрация функции, возвращающей множество
   -- связанных переменных заданного терма.

>  mn_notfree:: Lambda -> [[Char]]
>  mn_notfree (Var y)     = []
>  mn_notfree (App e1 e2) = povto (mn_notfree e1 ++ mn_notfree e2)
>  mn_notfree (Lam y e)   = povto ([y] ++ mn_notfree e)

>  -- Функции для представления лямбда-термов:

>  lam51 = App (Lam "x" (App (Var "x") (Var "y")))
>              (Lam "y" (Var "y"))

>  lam52 = Lam "x" (Lam "y" (App (Var "z")
>                                (Lam "z" (App (Var "z")
>                                         (Lam "x" (Var "y"))))))

>  lam53= App (Lam "y" (App (App (Var "x") (Var "y"))
>                           (Var "z")))
>             (Lam "z" (Lam "x" (App (Var "x") (Var "y"))))

>  lam54 = App (Lam "x" (Lam "y" (App (Var "x")
>                                     (Lam "z" (App (Var "y")
>                                                   (Var "z"))))))
>              (Lam "x" (Lam"y" (Var "z")))

>  test5 =   mn_notfree lam51 == ["x","y"]
>         && mn_notfree lam52 == ["x","y","z"]
>         && mn_notfree lam53 == ["y","z","x"]
>         && mn_notfree lam54 == ["x","y","z"]

    2Определение 0 ( 1важное 0) (по [Барендрегт,1985,с.36]).
 ш1.1
    _ 1Комбинатором . 0 ( _ 1замкнутым .  7l 0- _ 1термом . 0) назовём  7l 0-терм M, для которого
 ш1.0

   FV(M)= 7' 0.

 ш1.2
    3Замечание 0.
 ш1.1
   Множество связанных переменных часто обозначают BV (англ.   1boun-
 1ded 0 -  1ограниченный 0) или CV (англ.  1combined variable 0 - связанная пе-
ременная).

 ш1.2
                      23. 0  3Операция 0  3"подстановка"
   Определим фундаментальную для  7l 0-исчисления операцию
 ш1.0

    7( 0  7) 0∙
   │∙ 72 0 : 7L& 0G 41 7&L 0─ 76L 0,
    79 0  70 0∙

 ш1.2
которую будем называть  _ 1подстановкой . 0  7l 0- _ 1терма . 0  1N 0  _ 1вместо всех свободных
 _ 1вхождений предметной переменной . 0  1x 0  _ 1в . 0  7l 0- _ 1терм . 0  1M 0.
   Пусть x, y, z - буквы метаязыка, обозначающие  предметные  пере-
менные, M,M 41 0,M 42 0,N 7еL 0.
    2Определение 0 ( 1по Х.Б 0. 1Карри 0)
               [Барендрегт,1985,с.89,567; Хиндли,1991,с.122].
 ш1.1
    _ 1Результат подстановки . 0  7l 0- _ 1терма . 0  1N 0  _ 1вместо всех свободных  вхождений
 _ 1предметной переменной . 0  1x 0  _ 1в . 0  7l 0- _ 1терм . 0  1M 0 обозначается (M) 5x 4N 0 и определяет-
ся индуктивно следующим образом:
 ш1.0

         4┌ 0  4┐x
    2(p 41 2)  0│x│  ═+ 0N;
         4└ 0  4┘ 5N
         4┌ 0  4┐x 0                          4┌ 0  4┐x
    2(p 42 2) 0 │M│  ═+ 0M, если x 7Е 0FV(M);   2(p 42 2') 0 │y│  ═+ 0y, если x  1графически 0 не
         4└ 0  4┘ 5N 0                          4└ 0  4┘ 5N 0    совпадает с y.
         4┌ 0     4┐x 0  4┌ 0   4┐x┌ 0   4┐x
    2(p 43 2) 0 │M 41 0M 42 0│  ═+ 0│M 41 0│ │M 42 0│ ;
         4└ 0     4┘ 5N 0  4└ 0   4┘ 5N 4└ 0   4┘ 5N
         4┌ 0     4┐y
    2(p 44 2) 0 │ 7l 0y.M│  ═+ 7l 0y.M;
         4└ 0     4┘ 5N

    2(p 45 2) 0  _ 1подстановка без коллизии . 0:

         4┌ 0     4┐x 0     4┌ 0  4┐x
        │ 7l 0y.M│  ═+ 7l 0y.│M│ , если y 7Е 0FV(N);
         4└ 0     4┘ 5N 0     4└ 0  4┘ 5N

    2(p 46 2) 0  _ 1устранение коллизии имён переменных при подстановке . 0:

         4┌ 0     4┐x 0     4┌┌ 0  4┐y┐x
        │ 7l 0y.M│  ═+ 7l 0z.││M│ │ , если y 7е 0FV(N), z 7Е 0FV(M) 7u 0FV(N).
         4└ 0     4┘ 5N 0     4└└ 0  4┘ 5z 4┘ 5N

 ш1.2
    2Примеры 0 ( 1выполнения операции "подстановка" 0).
 ш1.0

       4┌ 0       4┐y 0  5(p6) 0    4┌ 0    4┐y 0  5(p3,p1,p2,p2')
    21. 0 │ 7l 0x.fxy│    ═+ 0   7l 0z.│fzy│         ═+ 0        7l 0z.fzx.
       4└ 0       4┘ 5x 0         4└ 0   5  4┘ 5x

       4┌ 0      4┐x 0  5(p6)    4┌┌ 0   4┐y┐x┐ 5(p3,p1,p2') 0    4┌ 0   4┐x 0  5(p3)
    22. 0 │ 7l 0y.yx│    ═+ 0   7l 0z.││yx│ │ │  4     ═+ 4  0   4   7l 0z.│zx│  4   ═+
       4└ 0      4┘ 5y 0         4└└ 0   4┘ 5z 4┘ 5y 4┘ 0     4        0   4 └ 0   4┘ 5y

                     4┌ 0  4┐x┌ 0  4┐x 0  5(p2') 0     4┌ 0  4┐x 0  5(p1)
                 ═+ 7l 0z.│z│ │x│     ═+ 0   7l 0z.z│x│    ═+ 0   7l 0z.zy.
                     4└ 0  4┘ 5y 4└ 0  4┘ 5y 0           4└ 0  4┘ 5y

       4┌ 0     4┐x  5(p5) 0    4┌ 0  4┐x 0  5(p1)
    23. 0 │ 7l 0y.x│    ═+ 0   7l 0y.│x│   4  ═+ 4   7l 0y.N, если y 7Е 0FV(N).
       4└ 0     4┘ 5N 0         4└ 0  4┘ 5N

       4┌ 0     4┐x  5(p6) 0    4┌┌ 0  4┐y┐x┐ 5(p2') 0    4┌ 0  4┐x 0  5(p1)
    24. 0 │ 7l 0y.x│    ═+ 0   7l 0z.││x│ │ │  4  ═+ 4   7l 0z.│x│  4   ═+ 4   7l 0z.N, если y 7е 0FV(N).
       4└ 0     4┘ 5N 0         4└└ 0  4┘ 5z 4┘ 5N 4┘ 0     4    └ 0  4┘ 5N

       4┌ 0      4┐x 0  5(p5) 0    4┌ 0   4┐x 0  5(p3,p2',p1)
    25. 0 │ 7l 0y.yx│     ═+ 0  7l 0y.│yx│   4      ═+ 4      7l 0y.(yN), если y 7Е 0FV(N).
       4└ 0      4┘ 5N 0         4└ 0   4┘ 5N

       4┌ 0      4┐x 0  5(p6) 0    4┌┌ 0   4┐y┐x┐ 5(p3,p1,p2') 0   4┌ 0   4┐x 0  5(p3,p2',p1)
    26. 0 │ 7l 0y.yx│    ═+ 0   7l 0z.││yx│ │ │  4     ═+ 4     7l 0z.│zx│  4       ═+
       4└ 0      4┘ 5N 0         4└└ 0   4┘ 5z 4┘ 5N 4┘ 0     4         └ 0   4┘ 5N

                 ═+ 7l 0z.(zN), если y 7е 0FV(N).

       4┌ 0          4┐x 0      4┌ 0       4┐x
    27. 0 │ 7l 0y. 7l 0x.fxy│   ═+ 7l 0z.│ 7l 0x.fxz│   ═+ 7l 0z. 7l 0x.fxz.
       4└ 0          4┘ 52y 0     4└ 0       4┘ 52y

 ш1.2
   В связи  с  приведённым выше определением результата подстановки
 7l 0-терма  1N 0 вместо всех свободных вхождений предметной переменной x в
 7l 0-терм M, можно (!) принять следующее
    _ 1Соглашение Барендрегта 0  1об именах переменных
                 ( 1Barendregt convention 0) [Барендрегт,1985,с.38-39].
 ш1.1
   Если в определённом математическом контексте (определении, дока-
зательстве) встречаются  7l 0-термы 4, 0 то подразумевается, что:
   (1)  1связанные  переменные  в  них выбраны отличными от свободных
 1переменных 0;
   (2) имена связанных переменных должны быть различными.

 ш1.2
   Используя это соглашение,  можно работать с  7l 0-термами  "наивным 2"
образом, т.е. выполнять операцию подстановки над  7l 0-термами, не про-
веряя наличие коллизии переменных при подстановке.
    2Пример 0.
 ш1.1
   Пусть принимается  соглашение Барендрегта и необходимо выполнить
операцию " 1подстановка 0"
 ш1.0

    4┌ 0     4┐x
   │ 7l 0y.M│ .
    4└ 0     4┘ 5N

 ш1.1
   Тогда очевидно, что y 7Е 0FV(N) и применяется  1подстановка без колли-
 1зии переменных 0.
 ш1.0

>  -- Соглашение Барендрегта можно интерпретировать так:
>  -- abc x x = x

   ERROR abc.hs  - Repeated variable "x" in pattern

   -- Демонстрация функции, реализующей операцию "подстановка
   -- лямбда-терма n вместо всех свободных вхождений предмет-
   -- ной переменной х в лямбда-терм".

>  podstanovka :: Lambda -> String -> Lambda -> Lambda
>  podstanovka (Var p) x lam | x==p = lam
>                            | True = Var p
>  podstanovka (App m1 m2) x lam = App (podstanovka m1 x lam)
>                                      (podstanovka m2 x lam)
>  podstanovka (Lam p m) x lam
>          | x==p = Lam p m
>          | p `inside` lam
>                 = Lam (p ++ x) (podstanovka
>                                   (podstanovka m p (Var (p ++ x)))
>                                   x
>                                   lam)
>          | True = Lam p (podstanovka m x lam)
>       where inside :: String -> Lambda -> Bool
>             s `inside` (Var x)   = x==s
>             s `inside` (App m n) = s `inside` m || s `inside` n
>             s `inside` (Lam _ n) = s `inside` n

>  t1 = Lam "x" (App (Var "x") (Var "y"))   -- \x.xy
>  t2 = Lam "x" (App (Var "x") (Lam "y" (App (Var "y") (Var "z"))))
>                                           -- \x.x(\y.yz)
>  t3 = Lam "x" (App (Var "x") 
>                    (App (Var "y") 
>                         (App (Var "z")
>                              (Lam "y" (App (Var "y") 
>                                            (Var "x"))))))
>                                           -- \x.x(y(z(\y.yx)))
> --------------------------------------------------------------
>  test6 =  podstanovka t1 "x" (Var "y") == t1
>        && podstanovka t1 "y" (Var "z") ==
>                            Lam "x" (App (Var "x") (Var "z"))

>        && podstanovka t1 "y" (Var "x") ==
>                            Lam "xy" (App (Var "xy") (Var "x"))
>        && podstanovka t2 "z" (Var "k") ==
>                            Lam "x" (App (Var "x")
>                                         (Lam "y"
>                                             (App (Var "y")
>                                                  (Var "k"))))
>        && podstanovka t3 "y" (Var "x") ==
>               Lam "xy" (App (Var "xy")
>                             (App (Var "x")
>                                  (App (Var "z")
>                                       (Lam "y"
>                                          (App (Var "y")
>                                               (Var "xy"))))))
>        && podstanovka t3 "x" (Var "y") == t3
>        && podstanovka t3 "z" (Var "k") ==
>               Lam "x" (App (Var "x")
>                            (App (Var "y")
>                                 (App (Var "k")
>                                      (Lam "y" (App (Var "y")
>                                                    (Var "x"))))))
>        && podstanovka t3 "z" (Var "y") ==
>               Lam "x" (App (Var "x")
>                            (App (Var "y")
>                                 (App (Var "y")
>                                      (Lam "yz" (App (Var "yz")
>                                                     (Var "x"))))))
>  test7 =   podstanovka (Lam "x" (Var "x")) "y" (Var "z")
>                 == Lam "x" (Var "x")
>         && podstanovka
>               (Lam "y" (App (Var "z") (App (Var "x") (Var "y"))))
>               "x"
>               (Lam "x" (Var "x"))
>                 == Lam "y" (App (Var "z")
>                                 (App (Lam "x" (Var "x"))
>                                      (Var "y")))
>         && podstanovka
>               (Lam "x" (App (Var "y") (Var "x")))
>               "x"
>               (App (Var "v") (Var "x"))
>                 == Lam "x" (App (Var "y") (Var "x"))
>         && podstanovka
>               (Lam "y" (App (Var "y") (Var "x")))
>               "x"
>               (App (Var "v") (Var "x"))
>                 == (Lam "y" (App (Var "y")
>                             (App (Var "v") (Var "x"))))

 ш1.2
                  24. 0  3Представление об интерпретации
                              7l 3-термов
   Напомним, что  для  задания функции достаточно указать множества
X, Y и  1правило сопоставления 0, которое записывается в виде:
 ш1.0

   x├─ 76 0f(x),

 ш1.2
и по  которому  каждый  x 7е 0X  объединяется в пару с некоторым y 7е 0Y (в
частности, эти пары могут быть просто перечислены).
    2Определение 0.
 ш1.1
    _ 1Теоретико-множественной интерпретацией . 0  7l 1- _терма
 ш1.0

    7l 0x. 2( 0fx 2)

называется  1правило сопоставления 0 x├─ 76 0f(x).

 ш1.2
   Приведём  1содержательную  теоретико-множественную 0    1интерпретацию
 7l 0-термов с помощью нескольких примеров:
 ш1.1
   (1) ( 7l 0x.x) интерпретируется тождественной функцией y=x со значе-
нием, равным её аргументу;
   (2) ( 7l 0x.f(gx)) интерпретируется композицией функций f и g,  т.е.
функцией со значением, равным f(g(x)) для аргумента x;
   (3) ( 7l 0x.(fg)x) интерпретируется применением  1функционала 0 f к двум
аргументам: функциональному  - g и "обычному" - x.  Этот способ ин-
терпретации позволяет описывать  1функции высших 0  1порядков 0;
   (4) ( 7l 0f. 7l 0x.fx) интерпретируется функцией высшего порядка, значе-
нием которой для функции f и аргумента x является значение f(x).

 ш1.2
    3Замечание 0.
 ш1.1
   В C++11 включена поддержка 7 l 0-функций. Это анонимные функции, ко-
торые  используются  только  один раз (часто в качестве аргументов)
другой функции. Например,
 ш1.0

   int main()
   {
     int a=fun([=] (int x) { return x*x*x; });
     ...
   }

 ш1.1
   Синтаксис 7 l 0-функций аналогичен синтаксису любой другой  функции,
только место имени занимает выражение [=], а тип возвращаемого зна-
чения обычно задавать не надо - компилятор  выведет  его  самостоя-
тельно.

 ш1.2
               25. 0  3Кванторы в содержательной математике
                       3и 0  3математической логике
   Нетрудно видеть,  что слово   7l 0x  имеет  такие  же  "связывающие"
свойства, что и слово  7А 0x в языке формальной системы первого порядка
или 7 3 0f(x)dx в математическом анализе.
   В связи с  этим  представляет  интерес  перечисление   1кванторов 0,
встречающихся  в языках  содержательной математики и математической
логики (по [Непейвода,1997,с.66,158; 2000,с.46,145]):
   (1)  _ 1квантор образования множества . 0:
 ш1.0

   {x│P(x)},

 ш1.2
где P(x)  -  предикат.  Этот квантор конструирует множество всех x,
обладающих свойством P(x);
   (2) операции  _ 1произведения . 0,  _ 1суммы . 0,  _ 1вычисление предела . 0,  _ 1вычисление
 _ 1интеграла . 0,  _ 1объединение множеств . 0:
 ш1.0

    n          n                   y
   ┬─┬         7░▒ 0                    7! 0           7$
   │ │(x 52 0+y),   7▓ 0(x 52 0+y),  1lim 0(x 52 0+y),  72 0(x 52 0+z)dx,  ═░ 0 A 4k 0;
   ┴ ┴         7│┤ 0        x 76 01 5        0  71 0          4k=1
   x=0        x=0                  0

 ш1.2
   (3)  _ 1квантор минимизации
 ш1.0

   ( 7m 0x 7е 0X)P(x),

 ш1.2
обозначающий наименьшее число в множестве натуральных чисел X,  об-
ладающее данным свойством P(x).  Этот  квантор  появляется  в  силу
 1принципа  наименьшего  числа 0 (поскольку это наименьшее число одно и
только одно в каждом непустом множестве натуральных чисел);
   (4)  _ 1квантор "тот самый . 0  1x" 0:
 ш1.0

    7i 0xP(x),

 ш1.2
где P(x) - формула языка первого порядка,  которая должна принимать
значение " 1истина 0" для единственного x, которое и является значением
терма  7i 0xP(x);
   (5)  _ 1квантор функциональности . 0:
 ш1.0

    7l 0x.t(x), либо x├─ 76 0t(x),

 ш1.2
где t(x) - терм.  Этот квантор конструирует по терму t(x)  функцию,
вычисляющую  значения этого терма.  Квантор часто встречается в ин-
форматике; в программировании ему  соответствует  описание  функции
(t - тело функции, x - её формальный параметр).
                       3Биографические сведения
 ш1.1
    _ 1Чёрч Алонзо . 0 (14.06.1903-11.08.1995) - американский логик и мате-
матик, член Американской академии искусств.
   Родился в Вашингтоне. Окончил Принстонский университет (1927).
   В 1927-1928 был стипендиатом по математике в Гарвардском универ-
ситете, в 1928-1929 слушал лекции в Гёттингенском,  в 1929 - в Амс-
тердамском университетах. С 1929 работал в Принстонском университе-
те (с 1939 - профессор математики, с 1961 - профессор философии), с
1967 - профессор Калифорнийского университета в Лос-Анжелесе.
   Основные исследования относятся к математической логике.  Разра-
ботал (1932-1933) систему аксиом для общей теории логики и дал пер-
вую формулировку теории,  названо позже исчислением   7l 0-преобразова-
ния.  Исследовал  (1936)  класс  вычислимых функций,  выделив класс
 7l 0-определимых функций.  В том же году сформулировал  1тезис Чёрча 0,  в
котором утверждается, что для логики предикатов нельзя дать никако-
го общего метода решения вопроса относительно общезначимости  неко-
торой формулы. Ряд работ по математической и символической логике.
 ш1.2

             2ПРИМЕРЫ РЕШЕНИЯ НЕКОТОРЫХ ТИПОВ УПРАЖНЕНИЙ
    2Пример 1. 0  Укажите множества связанных и свободных переменных  в
 7l 0-терме
 ш1.0

    2( 7l 0x.xy 2)( 7l 0y.y 2) 0.

 ш1.2
    _ 1Решение . 0. Воспользуемся индуктивными определениями функций FV() и
CV():
 ш1.0
      4┌ 0              4┐
   FV│( 7l 0x.xy)( 7l 0y.y)│ ═+ 0FV( 7l 0x.xy) 7u 0FV( 7l 0y.y) ═+ 0(FV(xy)\{x}) 7u 0(FV(y)\{y}) ═+
      4└ 0              4┘
                     ═+ 0((FV(x) 7u 0FV(y))\{x}) 7u 0({y}\{y}) ═+

                     ═+ 0({x} 7u 0{y})\{x}) 7u' ═+ 0{y};
      4┌ 0              4┐
   CV│( 7l 0x.xy)( 7l 0y.y)│ ═+ 0CV( 7l 0x.xy) 7u 0CV( 7l 0y.y) ═+ 0{x} 7u 0CV(xy) 7u 0{y} 7u 0CV(y) ═+
      4└ 0              4┘
                     ═+ 0{x,y} 7u 0CV(x) 7u 0CV(y) ═+ 0{x,y}.
 ш1.2

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 0.
 ш1.0

 ш1.2

    2Пример 1.
 ш1.0

 ш1.2

               2УПРАЖНЕНИЯ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ
                21. 0  3Язык 0  7l 0- 3термов 0  3как язык в алфавите
    21. 0 Докажите, что следующие слова являются  7l 0-термами:
 ш1.0

   (а) (x 41 0x 41 0);            (д) (x 41 0( 7l 0x 41 0.( 7l 0x 42 0.x 43 0)));

   (б) ( 7l 0x 42 0.x 42 0);          (е) ((x 42 0x 41 0)( 7l 0x 41 0.( 7l 0x 41 0.x 41 0)));

   (в) ( 7l 0x 41 0.(x 41 0x 41 0));      (ж) (( 7l 0x 42 0.x 42 0)( 7l 0x 43 0.(x 43 0x 42 0)));

   (г) ( 7l 0x 41 0.(x 41 0(x 42 0x 42 0)));  (з) ( 7l 0x 41 0.( 7l 0x 42 0.((x 42 0x 41 0)( 7l 0x 43 0.x 43 0)))).

 ш1.2
    _ 1Решение . 0.
 ш1.0

   (а)      (б)        (в)            (г)

   x 41 0  x 41 0   x 42 0    x 42 0         x 41 0  x 41 0             x 42 0  x 42
   ──────   ────────         ──────             ──────
   (x 41 0x 41 0)   ( 7l 0x 42 0.x 42 0)   x 41 0    (x 41 0x 41 0)         x 41 0  (x 42 0x 42 0)
                       ────────────         ──────────
                       ( 7l 0x 41 0.(x 41 0x 41 0))   x 41 0    (x 41 0(x 42 0x 42 0))
                                      ────────────────
                                      ( 7l 0x 41 0.(x 41 0(x 42 0x 42 0)))

 ш1.2
    22. 0 Докажите, что следующие слова не являются  7l 0-термами:
 ш1.0

   (а) ((х 42 0)(х 41 0х 43 0));          (г) ((х 43 0х 42 0x 43 0)( 7l 0x 41 0.( 7l 0x 41 0.х 41 0)));

   (б) ( 7l 0x 42 0. 7l 0x 42 0.(х 42 0х 42 0));      (д) ((х 41 0х 42 0).( 7l 0x 41 0.х 41 0));

   (в) (( 7l 0x 43 0.х 43 0х 42 0)( 7l 0x 42 0.х 42 0));  (е) ( 7l 0x 41 0.( 7l 0х 42 0((х 42 0x 41 0)( 7l 0х 43 0.х 43 0)))).

 ш1.2
    _ 1Решение . 0.
 ш1.0

   (а)           (б)                 (в)
    4Не является 0        4Отсутствуют 0       4Отсутствуют
    7д 4-термом 0           4внешние скобки 0    4внешние скобки

      7^ 0                      7^ 0                7^
   (х 42 0)  (х 41 0х 43 0)  x 42     7l 0x 42 0.(х 42 0х 42 0)    x 43    0х 43 0х 42
   ────────────   4──────────────── 0     4──────────
   ((х 42 0)(х 41 0х 43 0))  ( 7l 0x 42 0. 7l 0x 42 0.(х 42 0х 42 0))    ( 7l 0x 43 0.х 43 0х 42 0) 4   0( 7l 0x 42 0.х 42 0)
                                      4────────────────────
                                     (( 7l 0x 43 0.х 43 0х 42 0)( 7l 0x 42 0.х 42 0))

 ш1.2
    23. 0 Опустите скобки в следующих  7l 0-термах,  пользуясь  1соглашениями
 1об обозначениях 0:
 ш1.0

   (а) (( 7l 0x 41 0.( 7l 0x 42 0.(х 42 0х 41 0)))( 7l 0x 43 0.х 41 0));

   (б) ((х 41 0х 42 0)( 7l 0x 43 0.(х 43 0(х 44 0х 42 0))));

   (в) ( 7l 0x 43 0.(( 7l 0x 41 0.(( 7l 0x 42 0.х 42 0)х 43 0))х 46 0));

   (г) (( 7l 0x 45 0.(х 41 0х 41 0))( 7l 0x 43 0.( 7l 0x 44 0.х 44 0)));

   (д) (((х 42 0х 42 0)(х 43 0( 7l 0x 41 0.х 41 0)))(х 44 0х 43 0));

   (е) ((((х 42 0( 7l 0x 43 0.х 43 0))( 7l 0x 45 0.( 7l 0x 46 0.х 45 0)))х 41 0)х 41 0).

 2   0ш1.2
    _ 1Решение . 0. Скобки,  которые можно опустить,  выделены жирным шриф-
том.
 2   0ш1.0

   (а)  2( 0( 7l 0x 41 0. 2( 7l 0x 42 0. 2( 0х 42 0х 41 2)) 0) 2( 7l 0x 43 0.х 41 2)) 7= 0( 7l 0x 41 0x 42 0.х 42 0х 41 0) 7l 0x 43 0.х 41 0;

   (б)  2(( 0х 41 0х 42 2) 0( 7l 0x 43 0. 2( 0х 43 0(х 44 0х 42 0) 2) 0) 2) 7= 0х 41 0х 42 0( 7l 0x 43 0.х 43 0(х 44 0х 42 0));

   (в)  2( 7l 0x 43 0.( 2( 7l 0x 41 0. 2( 0( 7l 0x 42 0.х 42 0)х 43 2) 0)х 46 2)) 7=l 0x 43 0.( 7l 0x 41 0.( 7l 0x 42 0.х 42 0)х 43 0)х 46 0.

 ш1.2
    24. 0 Восстановите скобки в следующих  7l 0-термах,  пользуясь  1соглаше-
 1ниями об обозначениях 0:
 ш1.0

   (а) ( 7l 0x 41 0х 42 0х 43 0.х 43 0х 43 0)х 42 0х 44 0(х 45 0х 45 0);  (г) х 41 0х 41 0(х 43 0х 43 0)х 45 0( 7l 0x 46 0.х 46 0);

   (б) (х 42 0х 43 7l 0x 42 0.х 42 0)х 45 0( 7l 0x 46 0.х 46 0х 47 0);  (д) ( 7l 0x 42 0.х 43 0х 42 0)(х 44 0х 44 0)( 7l 0x 45 0.х 46 0х 45 0х 44 0);

   (в) ( 7l 0x 43 0х 44 0.(х 46 0х 47 0) 7l 0x 48 0.х 48 0);      (е) х 41 0(х 42 7l 0x 43 0х 45 0.х 45 0)х 46 0х 48 0х 49 0.

 ш1.2
    _ 1Решение . 0. Восстановленные скобки выделены жирным шрифтом.
 ш1.0

   (а) ( 7l 0x 41 0х 42 0х 43 0.х 43 0х 43 0)х 42 0х 44 0(х 45 0х 45 0) 7=

                          7= 2((( 0( 7l 0x 41 0. 2( 7l 0х 42 0. 2( 7l 0х 43 0. 2( 0х 43 0х 43 2))) 0)х 42 2) 0х 44 2) 0(х 45 0х 45 0) 2) 0;

   (б) (х 42 0х 43 7l 0x 42 0.х 42 0)х 45 0( 7l 0x 46 0.х 46 0х 47 0) 7= 2(( 0( 2( 0х 42 0х 43 2)( 7l 0x 42 0.х 42 2) 0)х 45 2) 0( 7l 0x 46 0. 2( 0х 46 0х 47 2) 0) 2) 0;

   (в) ( 7l 0x 43 0х 44 0.(х 46 0х 47 0) 7l 0x 48 0.х 48 0) 7= 0( 7l 0x 43 0. 2( 7l 0х 44 0. 2( 0(х 46 0х 47 0) 2( 7l 0x 48 0.х 48 2))) 0).

 ш1.2
                 22. 3 Свободные и связанные переменные
    21. 0 (По [Барендрегт,1985,с.37])
   Пусть M ═+ 7l 0x.xy 2( 7l 0z.y 2) 0. Установите верно ли, что
 ш1.0

    2( 0xy 2) 7е 1Sub 0(M), z 7е 1Sub 0(M)  2( 0y 2( 7l 0z.y 2)) 7е 1Sub 0(M)?

 ш1.2
    22. 0 Укажите множества свободных и связанных переменных для следу-
ющих  7l 0-термов:
 ш1.0

   (а) ( 7l 0x.xy)( 7l 0y.y);        (г) y( 7l 0y.yx)( 7l 0x.x);

   (б)  7l 0x. 7l 0y.z( 7l 0z.z( 7l 0x.y));  (д) ( 7l 0x. 7l 0y.xz(yz))( 7l 0x.y( 7l 0y.y));

   (в) ( 7l 0y.xyz)( 7l 0z. 7l 0x.xy);   (е) ( 7l 0x. 7l 0y.x( 7l 0z.yz))( 7l 0x. 7l 0y.z).

 ш1.2
    _ 1Решение . 0.
 ш1.0

   (а) FV(( 7l 0x.xy)( 7l 0y.y)) ═+ 0FV( 7l 0x.xy) 7u 0FV( 7l 0y.y) ═+

            ═+ 0(FV(xy)\{x}) 7u 0(FV(y)\{y}) ═+ 0((FV(x) 7u 0FV(y))\{x}) 7u 0({y}\{y}) ═+

            ═+ 0({x} 7u 0{y})\{x}) 7u' ═+ 0{y};

       CV(( 7l 0x.xy)( 7l 0y.y)) ═+ 0CV( 7l 0x.xy) 7u 0CV( 7l 0y.y) ═+ 0{x} 7u 0CV(xy) 7u 0{y} 7u 0CV(y) ═+

            ═+ 0{x,y} 7u 0CV(x) 7u 0CV(y) ═+ 0{x,y}.

 ш1.2
                      23. 0  3Операция 0  3"подстановка"
                           3в 2  7l 2- 3исчислении
    21 4* 2. 0 Выполните операцию "подстановка":
 ш1.0

        4┌ 0      4┐x 0         4┌ 0           4┐x
   (а) 2  0│ 7l 0y.yx│  ;  (в) │( 7l 0z.x)(xy)│ ;
        4└ 0      4┘ 5zx 0  5   0     4└ 0           4┘ 5z
        4┌ 0      4┐x 0         4┌ 0         4┐x
   (б) 2  0│ 7l 0y.yx│  ;  (г) │ 7l 0y.z(xy)│    .
        4└ 0      4┘ 5yx 0        4└ 0         4┘ 7Д 5x.x

 ш1.2
    _ 1Решение . 0.
 ш1.0

        7( 0      7) 4x   (p5) 0    7( 0   7) 4x  (p3,p2',p1)
    2(а)  0│ 7l 0y.yx 72 0     2  ═+ 4   7l 0y.│yx 72 0      4  0   ═+ 0    4   7l 0y.y(zx);
        79 0      70 5(zx) 0        79 0   70 5(zx)

 ш1.2
    22 4* 2. 0 Выполните операцию " 1подстановка 0":
 ш1.0

        4┌ 0           4┐x 0        5  0    4┌ 0        4┐x
   (а) 2  0│ 7l 0x. 7l 0y. 7l 0z.x│     ;  5  0(в) │ 7l 0z. 7l 0x.x│ ;
        4└ 0           4┘ 7Д 5x.zx 0     5  0   4└ 0        4┘ 5y
        4┌ 0         4┐x 0              4┌ 0          4┐x
   (б) 2  0│ 7l 0y. 7l 0z.yx│    ;     (г) │ 7l 0z. 7l 0y.xyz│     .
        4└ 0         4┘ 7Д 5y.x  0          4└ 0          4┘ 7Д 5y.xz

 ш1.2
    _ 1Решение . 0.
 ш1.0

        7( 0           7) 4x 0      4(p4)
    2(а)  0│ 7l 0x. 7l 0y. 7l 0z.x 72 0        ═+ 7l 0x. 7l 0y. 7l 0z.x;
        79 0           70 5( 7Д 5x.zx)

 ш1.2
                 24. 3 Компьютерное моделирование 0  3языка
                  7l 3-исчисления как языка в алфавите
    21. 0 Проведите тестирование программ из раздела  "Демонстрационные
примеры" по полученным результатам решения задач.
    22. 0 Составьте программу для построения древесного  доказательства
того, что данное слово является  7l 0-термом.
    23. 0 Составьте программу для определения ранга  7l 0-терма.
    24. 0 Составьте  программу для определения того факта,  являются ли
два терма дизъюнктными.
    25. 0 Составьте программу, реализующую операцию " 1подстановка  7l 1-тер-
 1ма  N  вместо  всех  свободных  вхождений предметной переменной х в
 7l 1-терм M 0".
    26. 0 Составьте программу-транслятор, переводящий:
   (1) сокращённую запись  7l 0-терма в запись  7l 0-терма со всеми скобка-
ми и абстракциями по соглашению об обозначениях  7l 0-термов;
   (2)  7l 0-терм  в сокращённую запись,  опуская скобки и астракции по
соглашению об обозначениях  7l 0-термов.
    27. 0 Составьте  программу,  моделирующую квантор функциональности,
конструирующего по терму функцию, вычисляющую значения этого терма.

                       3Вспомогательные функции

>  instance Show Lambda where
>     show (Var x)   = x
>     show (App x y) = case y of
>                        App _ _ -> showLam x ++ "(" ++ show y ++ ")"
>                        _       -> showLam x ++ showLam y
>           where showLam l@(Lam _ _) = "(" ++  show l  ++ ")"
>                 showLam x           = show x
>     show (Lam x e)  = "\\" ++ x ++ "." ++ show e

>  povto []  = []
>  povto [x] = [x]
>  povto (x:y:lst) | x==y = povto1 [x] []  lst
>                  | True = povto1 [x] [y] lst

>  povto1 lst1      []       []    = reverse lst1
>  povto1 lst1    (y:lst2)   []    = povto1 ([y] ++ lst1) [] lst2
>  povto1 (x:lst1) lst2   (y:lst3)
>                   | x==y = povto1 (x:lst1) lst2          lst3
>                   | True = povto1 (x:lst1) (lst2 ++ [y]) lst3

>  test8 = povto [1,2,3,4,1,2,3,4]
>  test9 = povto [1,2,3,4]

