                   3Функциональные структуры данных
    2Пример 0 [Марлоу,2014,с.235].
 ш1.1
   Реализуем структуру данных  " 1Очередь 0",  поддерживающую  операции
извлечения из  начала очереди и добавления в конец очереди со слож-
ностью 7 O 0(1).  Известен следующий способ представления очереди с та-
кими свойствами,  идеей которого является хранение очереди  в  виде
двух списков  xs  и  ys так,  чтобы содержимое очереди совпадало со
списком (xs ++ reverse ys).
   Теперь для того,  чтобы  _ 1извлечь . 0 элемент из  начала  очереди,  мы
извлекаем его из списка xs,  а для  _ 1добавления . 0 элемента в конец оче-
реди, мы помещаем его в начало списка ys.  При этом сложность обеих
операций есть  7O 0(1). Если же список xs оказывается пустым, а необхо-
димо извлечь элемент, то обращённый список (reverse ys) превращает-
ся в новый список xs.
   Итак, большую часть времени сложность извлечения элемента из на-
чала очереди есть  7O 0(1) и только изредка  7O 0(n).

 ш1.2
.
   Все ошибки будут не дальше трёх операторов в ту или другую  сто-
рону от места последнего изменения программы.
                                                  Закон отладки Джо

   Ленивость Haskell ...  сильно влияет на то, как пишут программы,
поскольку позволяет  так осуществить декомпозицию задачи,  как едва
ли возможно иными способами.  Я люблю представлять это как  _ 1преобра-
 _ 1зование времени в пространство . 0.
   Например, вместо того,  чтобы думать о том,  как последовательно
(время) возвращать значения,  я могу вернуть список, содержащий все
значения (пространство),  и ленивость гарантирует,  что значения  в
списке будут вычисляться по одному, как и требуется.
   Работать с пространством часто бывает легче,  чем  со  временем:
пространство можно визуализировать непосредственно, тогда как визу-
ализация времени требует анимации...
   Поэтому применение ленивости может существенно изменить подход к
задаче. Примером служат ... комбинаторы парсеров, которые возвраща-
ют список всех возможных результатов анализа:  ленивость гарантиру-
ет, что этот список будет составляться по мере надобности.  В част-
ности, если вас удовлетворит первый результат, остальные и не будут
генерироваться.
                                                           Ф.Уодлер
.
                3Основные операции образования функций
    21. 0  _ 1Аппликация . 0.
   Применение функции f (имя функции) к значению аргумента x (любое
выражение, значение которого вычисляется перед применением функции)
имеет следующую запись:
    1в математике 0:                     f(x);
    1в языке бестипового 7 l 1-исчисления 0: (fx);
    1в языке программирования Haskell 0: (f x).

    22. 0  _ 1Абстракция . 0.
   Запись функции без имени с одним параметром x  (переменная  абс-
тракции), телом которой может быть любое выражение для вычисления:
    1в языке бестипового 7 l 1-исчисления 0:  7l 0x.x;
    1в языке программирования Haskell 0: \x -> x.

   Запись функции без имени со множеством параметров:
    1в языке бестипового 7 l 1-исчисления 0:  7l 0xy.gxy или  7l 0x. 7l 0y.gxy;
    1в языке программирования Haskell 0:
 ш1.0

 >  g = (+)
 >  z = \x y -> g x y

или

 >  z1 = \x -> \y -> g x y

 ш1.2
                        3Каррированные функции
    _ 1Каррированными функциями . 0  называются  функции y=f(x 41 0,x 42 0,...,x 4n 0),
синтаксически представимые в виде
 ш1.0

   (...(f(x 41 0) x 42 0)...) x 4n 0.

 ш1.2
   В качестве синонима слова " 1карринг 0" используются термины  _ 1частич-
 _ 1ное применение функции . 0 и  _ 1частичная параметризация . 0.
    _ 1Преимущества частично применённых функций . 0:
   (1) карринг  позволяет уменьшить число скобок при записи выраже-
ния;
   (2) употребление карринговых функций позволяет сделать программу
значительно "функциональнее".
    1В языке бестипового 7 l 1-исчисления 0 существует соглашение о восста-
новлении скобок по ассоциативности влево: слово метаязыка
 ш1.0

   fx 41 0...x 4n

является сокращённой записью  7l 0-терма

   (...((fx 41 0)x 42 0)...x 4n 0);

 ш1.1
    1В языке программирования Haskell 0 содержатся два функционала:
 ш1.0

 >  curry:: ((a,b) -> c) -> (a -> b -> c)
 >  curry f x y = f (x,y)

 >  uncurry:: (a -> b -> c) -> ((a,b) -> c)
 >  uncurry f (x,y) = f x y

 ш1.2
                             3Комбинаторы
    21. 0  _ 1Тождественный комбинатор . 0.
    1В языке бестипового 7 l 1-исчисления 0:  2I ═+ 7l 0x.x
    1В языке программирования Haskell 0:
 ш1.0

   id:: a -> a  ║
   id x         ║  \x -> x

 ш1.2
    22. 0  _ 1Комбинатор образования константы . 0.
    1В языке бестипового 7 l 1-исчисления 0:  2K ═+ 7l 0x. 7l 0y.x
    1В языке программирования Haskell 0:
 ш1.0

   const:: a -> b -> a  ║
   const k _ = k        ║  \x y -> x

 ш1.2
    23. 0  _ 1Элементарный коммутатор . 0.
    1В языке бестипового 7 l 1-исчисления 0:  2C ═+ 7l 0xyz.xzy
    1В языке программирования Haskell 0:
 ш1.0

   flip:: (a -> b -> c) -> b -> a -> c  ║
   flip f x y = f y x                   ║  \x y z -> x z y

 ш1.2
    24.  _ 1Элементарный композитор . 0.
    1В языке бестипового 7 l 1-исчисления 0:  2B ═+ 7l 0xyz.x(yz)
    1В языке программирования Haskell 0:
 ш1.0

   (.):: (a -> b) -> (c -> a) -> (c -> b)  ║
   (.) f g x = f (g x)                     ║  \x y z -> x (y z)

 ш1.2
                      3Рекурсивные функции
                             ...

.
   - построить fix-foldr-представление оператора примитивной
     рекурсии на на натуральных числах по рекурсивному
     представлению:

     prRec g h x 0     = g x,
     prRec g h x (y+1) = h x y (prRec g h x y)

.
   F# -  _ 1статически типизированный язык . 0 с поддержкой определения ти-
пов.  Это означает,  что все конструкции имеют известный тип уже на
этапе компиляции, а не на этапе выполнения программы.
   Кроме того,  F# -  _ 1язык со строгой типизацией . 0,  т.е. в выражениях
отсутствует неявное приведение типов.
.
   [Марков,2016,с.183]
   Термином " 1эллипсис 0" в программировании называют умолчание  коли-
чества параметров.
   Например, в Visual Prolog  эллипсис  даёт  возможность  передачи
предикату произвольного количества параметров.
   Необходимость использования эллипсиса возникает тогда, когда не-
обходимо передать на обработку заранее неизвестное количество пара-
метров определённого типа.
.
           1Функциональное программирование - это ставка  на  долёкий
           1успех.  Это в корне иной взгляд на программирование в це-
           1лом.  Из-за этого его трудно изучать, и даже после изуче-
           1ния трудно принять,  поскольку различие носит революцион-
           1ный, а не эволюционный характер. 0
           1До сих пор неясно сможет ли функциональное программирова-
           1ние стать в итоге ведущим стилем. Зато ясно, что функцио-
           1нальное  программирование оказало влияние на ведущие язы-
           1ки, и это влияние растёт. Вот вам примеры 0: 1 сборка мусора,
           1полиморфные типы (генерики),  итераторы, LINQ, безымянные
           1функции и т.д. 0
                                                      1С.Пейтон-Джонс

   Haskell - это чисто функциональный и ленивый язык,  т.е.  в  нём
невозможны ни присваивания,  ни циклы. Вообще отсутствует всё импе-
ративное.  Это даёт кучу преимуществ, но является своеобразной про-
пастью для изучения. Хотя там и можно начинать писать сразу же яко-
бы императивно, это совсем не то, чем кажется.
   Чтобы полностью понять Haskell (если до того долго  программиро-
вал  на  императивных языках и нет математического образования) до-
вольно сложно (но не невозможно),  требуется значительная настойчи-
вость. Зато с определённой уверенностью можно утверждать, что после
него  не  будет уже языка программирования (не обязательно функцио-
нального!), который бы не учился за полдня.
   Зато в смысле отдачи получаешь невероятную мощь всего,  что при-
думало computer science в области языков за последние 30  лет  плюс
самая большая, видимо, надёжность кода.
   Например:
 ш1.1
   (1)  _ 1сборка мусора . 0:  появилась в LISP (1958), стала мэйнстримом в
1995 (Java);
   (2)  _ 1замыкания . 0:  появились в Scheme (1975),  стали мэйнстримом  в
2000-х (C#, JavaScript);
   (3)  _ 1Ленивая обработка . 0:  появилась в Miranda (1985),  стала мэйн-
стримом в 2000-е (LINQ);
   (4)  _ 1параметрический полиморфизм . 0:  появился в 1983,  сейчас мэйн-
стрим в Java, C#, C++;
   (5)  _ 1функции высшего порядка . 0:  появились в LISP, сейчас мэйнстрим
везде, кроме Java;
   (6)  _ 1вывод типов . 0:  появился в ML (1979),  стал мэйнстримом в 2007
(C#, Scala, C++0x).

 ш1.2
   Недостатки: очень  долго Haskell был исключительно академическим
языком, т.е.  развивали его люди, которым это нужно было не для то-
го, чтобы писать программное обеспечение,  а  _ 1для того, чтобы писать
 _ 1научные работы . 0.
   Правда, сейчас это стремительно меняется.
.
   Идея технологии  программирования:  ленивые вычисления позволяют
писать  _ 1генераторы . 0. Если вы генерируете всю последовательность приб-
лижений к ответу решаемой задачи,  то   _ 1потребитель . 0  говорит,  когда
нужно остановиться.  Поэтому отделив генераторы от потребителя,  мы
получаем модульное строение программы.
   Модульность означает,  что в разных местах идут разные процессы,
которые можно комбинировать.
.
                            3Инкапсуляция
   [Роганова,2002,с.223]...
.
   -- Демонстрация определения нового типа данных и работы с ним.
   -- Тип данных: пара целочисленных элементов.
   -- Операция: сложение двух целых чисел 
   --------------------------------------
   type Pair = (Int,Int)
   ---------------------
   addTwo:: Pair -> Int
   addTwo (first,second) = first + second
   --------------------------------------
   -- Неудачные тестовые примеры:
   ---------------------------------
   test =   addTwo (3,4)     ==    7
         && addTwo (-3,4)    ==    1
         && addTwo (-1,-100) == -101
         && addTwo (0,123)   ==  123
.
   ML представляет собой универсальный функциональный язык, который
Р.Милнер и возглавляемая им команда разработчиков создали  в  Эдин-
бургском  университете в 1970-х.  Он возник из металингвистического
проекта, целью которого было описание математических доказательств.
   Язык разрабатывался для доказательства теорем.  При этом  оказа-
лось,  что доказательство теорем - настолько требовательная задача,
что язык ML превратился в универсальный.
   Возможно самым  ценным  вкладом ML в проектирование языков прог-
раммирования стал алгоритм Хиндли-Милнера для вывода типов,  приме-
няемый во многих системах со статическими типами.
   Язык послужил прообразом для Standard ML, Caml, Haskell, F 1# 0.
.
                               3Charity
   Существуют языки программирования, в которых этот способ опреде-
ления рекурсии является единственным;  в частности,  упомянем  язык
программирования   2Charity 0,  который является реализацией идей  1обоб-
 1щённого функционального программирования 0  (англ.   1Total  Functional
 1Programming 0).  Язык  содержит  1данные 0 и  1коданные 0,  а также всего две
конструкции fold и unfold (все остальные выводятся с их помощью).
   Любая  1примитивно  рекурсивная  функция 0 выразима на Charity (нес-
мотря на то,  что в языке отсутствует оператор  рекурсии).  Поэтому
язык  не  является  полным  по  Тьюрингу,  зато обладает тем важным
свойством, что  1любая 0 программа завершается.
    3Замечание 0.
 ш1.1
   Для знакомства с языком Charity воспользуйтесь интерпретатором:
 ш1.0

   http://pll.cpsc.ucalgary.ca/charity1/www/home.html

   См. пример реализации функции Аккермана на Charity:

   ftp://ftp.cpsc.ucalgary.ca/pub/projects/charity/literature/
         papers_and_reports/about_charity.ps
 ш1.2
.
    _ 1Препроцессор . 0 - это компьютерная программа, принимающая данные на
входе и выдающая данные, предназначенные для входа другой программы
(например, компилятора). Говорят, что  _ 1данные на выходе препроцессо-
 _ 1ра находятся в препроцессорной форме . 0,  пригодной для обработки пос-
ледующими программами (например, компилятором).
   Результат и вид обработки зависят от вида препроцессора: некото-
рые  препроцессоры могут только выполнить простую текстовую подста-
новку,  другие способны по возможностям сравниться с языками  прог-
раммирования.  Наиболее частый случай использования препроцессора -
обработка исходного кода перед передачей его на следующий шаг  ком-
пиляции.
   Языки программирования C/C++ и система компьютерной вёрстки  TeX
используют препроцессоры, значительно расширяющие их возможности.
   В некоторых языках программирования этап компиляции и трансляции
получили название "препроцессинг".
.
