    2ЛАБОРАТОРНАЯ РАБОТА 8.
    2ОТЛОЖЕННЫЕ ВЫЧИСЛЕНИЯ И ИХ МОДЕЛИРОВАНИЕ С ПОМОЩЬЮ  ЛЕНИВЫХ  ВЫ-
 2ЧИСЛЕНИЙ: потенциально бесконечные списки

 ш1.0
                       1Разум неистощим в  соображении  понятий,  как
                       1язык  неистощим в соединении слов.  Все слова
                       1находятся в лексиконе ... мысли же могут быть
                       1разнообразны до бесконечности. 0
                                                          1А.С.Пушкин
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Знать . 0:
 ш1.0
   - понятия  " 1актуальная бесконечность 0",  " 1потенциальная бесконеч-
 1ность 0";
   - вызов функции по значению, вызов функции по необходимости;
   - понятие " 1отложенные 0  1вычисления 0";
   - понятия " 1строгий язык программирования 0", " 1нестрогий язык прог-
 1раммирования 0";
   - понятие " 1строгая функция 0" (в функциональном программировании);
   - синтаксис и семантику операции " 1строгая аппликация 0" ($!);
   - понятие " 1корекурсия 0";
   - конструирование потенциально бесконечных списков с помощью ко-
рекурсии, паттерны корекурсии;
   - способы конструирования потенциально бесконечных списков с по-
мощью двух точек "..".

    _ 1Уметь . 0:
   - пользоваться конструкторами потенциально  бесконечных  списков
из библиотеки Prelude.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ

 ш1.0
            1Так и приходится нам постоянно  _изобретать язык .,  способ-
            1ный  всё  тоньше  и искусней передать словами структуру,
            1присущую математическому объекту,  и "строить" с помощью
            1этого  языка,  постепенно  и  целиком "теории",  которые
            1должны дать отчёт о том,  что мы поняли и увидели. Маят-
            1ник  движется без остановки между 0  _ 1пониманием . 0  1вещей и  _вы-
            _ 1ражением . понятого на языке,  который отшлифовывает и пе-
            1ресоздаёт  сам  себя  в процессе работы,  под постоянным
            1давлением насущной необходимости. 0
                                        1А.Гротендик. Урожаи и посевы
 ш1.2

    2Определение 0 [Словарь,2004,с.46].
 ш1.1
    2(1) 0  _ 1Бесконечность . 0  ( 1в широком смысле 0) - это философская  катего-
рия, используемая для описания неисчерпаемости материи и движения.
    2(2) 0  _ 1Бесконечность . 0 ( 1в узком смысле 0) - одно из  важнейших  понятий
философии математики,  в которой принято разделять два вида  беско-
нечности:   _ 1потенциальную . 0, состоящую в возможности постепенного уве-
личения конечного,  и  _ 1актуальную . 0, состоящую в допущении существова-
ния бесконечного множества как завершённого.

 ш1.2
   В философском смысле бесконечность может быть естественно  опре-
делена через понятие конечного,  а именно как возможность выхода за
пределы конечного,  которая неизбежно предполагается  уже  в  самых
первых представлениях арифметики и геометрии. Эта же идея лежит и в
основе более строгих математических определений бесконечного, кото-
рые формулируются по-разному в различных математических теориях.
   Математическое мышление органически связано с идеей бесконечного
в том смысле, что без допущений о возможности выхода за пределы ко-
нечного математическое рассуждение вообще не могло бы осуществлять-
ся.
   Современная философия математики не связывает понятие " 1бесконеч-
 1ность 0" в математике с какой-либо содержательной основой,  с сущест-
вованием  реальной бесконечности в мире.  Она исходит из того,  что
бесконечность в математике - исключительно  мысленная  конструкция,
выполняющая  определённую  функцию  в систематизации математических
операций,  которая была бы необходимой даже в том случае,  если  бы
мироздание оказалось конечным в неком существенном смысле. Это зна-
чит, что современная философия математики берёт это понятие преиму-
щественно  в  гносеологическом плане,  рассматривая его как элемент
понятийных систем, и отделяет проблему математической бесконечности
от проблемы бесконечности в физике и философии.

                        3Отложенные вычисления

 ш1.0
                           1Делать что-либо  хорошо - зачастую  пона-
                           1прасно терять время.
                                                              1Р.Бирн
                           1Получив приказ, не торопись его выполнять
                           1- дождись команды "отставить".
                                                  1Армейская мудрость
 ш1.2

   В языках  императивного  программирования  (например,  С)  вызов
функции приводит к вычислению значений всех переданных на вход  ар-
гументов.  Константы в качестве аргументов передаются в функцию не-
посредственно. Переменные означиваются, и в самой функции использу-
ются значения этих переменных, которые они получили на момент пере-
дачи в качестве параметров в функцию. Если среди аргументов имеется
вызов  функции,  то  сначала  происходит запуск процесса вычисления
этой функции, а полученный результат уже передаётся внутрь исходно-
го вычислительного процесса.
   В языках  1императивного программирования 0 известны  значения  всех
входных параметров на момент входа в процесс вычислений,  описанный
функцией, что позволяет в ходе вычислительного  процесса  не  забо-
титься  о том,  что во время вычислений какой-либо из входных аргу-
ментов может изменить своё значение. Этот момент вызова функции на-
зывается  _ 1вызовом функции по значению . 0.
   Ясно, что  если  какой-либо аргумент не использовался в функции,
то результат его вычисления "пропадает", следовательно, сами вычис-
ления произведены "напрасно".
   Противоположностью вызова  по значению является  _ 1вызов функции по
 _ 1необходимости . 0. При этом аргумент вычисляется только в  том  случае,
если он нужен для вычисления результата, возвращаемого функцией.
    _ 1Первым примером . 0 подобных вычислений являются  1конструкции  услов-
 1ного перехода 0 (примеры приведите самостоятельно!).
    _ 1Вторым примером . 0 является операция " 1логическое И 0" (&&) в языке С,
которая не вычисляет значение второго аргумента,  если первый аргу-
мент имеет значение,  равное 0;  аналогично не вычисляется значение
второго операнда  операции " 1логическое ИЛИ 0" (||),  если первый опе-
ранд принимает значение, отличное от 0.
   Поэтому можно написать следующий код:
 ш1.0

   false && (x/0)

 ш1.2
(несмотря на  то что вычисление второго операнда приведёт к возник-
новению ошибки " 1деление на нуль 0", ошибка не возникает).
   Итак, происходит автоматическое прекращение вычислений в случае,
если результат вычислений уже известен; подобный способ организации
вычислений иногда называется  1логикой короткого замыкания 0.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 0 41 0.

 ш1.2
   Описанный случай  вызова по необходимости в языках императивного
программирования является, скорее, исключением, чем общим принципом
построения таких языков.
   Вызов по необходимости в языках функционального программирования
называется  _ 1отложенными вычислениями . 0.
   Отметим, что свойство отложенности вычислений характеризует иск-
лючительно функциональные языки программирования  (правда,  не  все
функциональные языки поддерживают это важное свойство).
    2Определение 0 ( 1неформальное 0).
 ш1.1
    2(1) 0  _ 1Отложенные  вычисления . 0  ( 1в  программировании 0) - это подход в
некоторых языках программирования,  при котором вычисления отклады-
ваются до тех пор, пока их результаты не понадобятся.
    2(2) 0  _ 1Отложенными 0  1вычислениями . 0 называется организация процесса вы-
числений, для которой характерно отсутствие вычислений в тех случа-
ях, когда результат этих вычислений не требуется.

 ш1.2
   Итак, в языках функционального программирования можно определять
и использовать конструкции, подобные следующей:
 ш1.0

   x = constant bot
     where bot        = bot
           constant n = 1

 ш1.2
   На вход функции constant подаётся функция bot, которая определя-
ет бесконечный рекурсивный вызов самой себя.  Однако это не вызовет
никаких последствий для транслятора языка  Haskell,  т.к.  значение
функции constant равно 1.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 0 42 0, Пример 0 43 0.

 ш1.2
    2Определение 0.
 ш1.1
    2(1) 0  _ 1Строгим . 0 ( _ 1энергичным . 0)  _ 1языком функционального программирования
называется  язык функционального программирования,  который не под-
держивает  1отложенных вычислений 0, т.е. порядок вычисления строго оп-
ределён.
   Примерами  1строгих 0 языков являются Caml, Scheme, Standard ML.
    2(2) 0  _ 1Нестрогим . 0 ( _ 1ленивым . 0)  _ 1языком функционального  программирования
называется язык, который поддерживает  1отложенные вычисления 0.
   Примерами  1нестрогих 0 языков являются Miranda, Haskell.

 ш1.2
   Часто строгие языки включают в себя средства поддержки некоторых
полезных возможностей,  присущих нестрогим языкам (например, беско-
нечные списки); так, например:
 ш1.1
   (1) в Standard ML присутствует специальный модуль для  поддержки
отложенных вычислений;
   (2) Objective Caml поддерживает  дополнительное  ключевое  слово
lazy и специальную конструкцию для списков значений, вычисляемых по
необходимости.

 ш1.2
    2Пример 0 ( 1отложенных вычислений в  7l 1-исчислении 0).
 ш1.1
   Пусть Imp ═+ 7l 0x. 7l 0y.xy 2T 0,  2T ═+ 7l 0x. 7l 0y.x,  2F ═+ 7l 0x. 7l 0y.y. Приведём к нормальной
форме  7l 0-терм Imp 2FF 0:
 ш1.0

   Imp 2FF ═+ 0( 7l 0x. 7l 0y.xy 2T 0) 2FF 0─ 76и 0( 7l 0y. 2F 0y 2T 0) 2F 0─ 76и 2FFT 0.

 ш1.1
   "Ленимся до  последнего",  но  теперь откладывать "вычисление"  2F
уже нельзя,  поэтому используем имеющийся " 1переходник 0" (определение
см. ниже), которым в данном случае является определение  2F 0:
 ш1.0

    2FFT ═+ 0( 7l 0x. 7l 0y.y) 2FT 0─ 76и 0( 7l 0y.y) 2T 0─ 76и 2T 0.

 ш1.2
   Нестрогие языки программирования часто также поддерживают  1свойс-
 1тво чистоты языка 0.
   Напомним, что   _ 1чистой  функцией . 0  называется функция,  вычисление
значения которой не влияет  на  результаты  работы  других  функций
(другими словами,  1функция не имеет побочных эффектов 0).

                  3Нестрогие 0  3функции в языке Haskell

 ш1.0
                                        1Под москитную сетку
                                        1запустил к себе светлячков -
                                        1ну что за прелесть 0! 1..
                                                 1Ё.Бусон  0( 11716-1783 0)
 ш1.2

    3Соглашение  0( 1об обозначениях 0).
 ш1.1
    _ 1Неопределённое значение . 0 ( 1в теоретическом программировании 0) обоз-
начается ┴ (читается: " 1основание 0", " 1неопределённость 0").

 ш1.2
    2Определение 0.
 ш1.1
    2(1) 0 Говорят, что  _ 1функция является строгой по аргументу . 0, если для
вычисления её значения требуется обязательное  вычисление  значения
этого аргумента.
    2(2) 0  _ 1Строгой  функцией . 0 называется функция,  являющаяся строгой по
всем аргументам.
    2(3) 0  _ 1Строгой функцией . 0 ( 1в функциональном программировании 0) называ-
ется функция  ═f 0, для которой  ═f 0(┴)=┴.

 ш1.2
    3Замечание 0.
 ш1.1
   В языке программирования С операции && и || являются строгими по
первому аргументу и нестрогими по второму аргументу.
   Библиотечные функции языка C являются строгими функциями.

 ш1.2
    2Определение 0.
 ш1.1
    _ 1Строгим языком программирования . 0 называется  язык  программирова-
ния, в котором все компоненты некоторой структуры данных вычисляют-
ся до их помещения в эту структуру.

 ш1.2
   Для дальнейшего воспользуемся функциями языка Haskell, позволяю-
щими моделировать  _ 1неопределённое значение . 0:
 ш1.0

    2error 0:: String -> a,  2undefined 0:: a.

 ш1.2
   Например:
 ш1.0

   Prelude> "123" ++ error "1"
   "123
   Program execution error: 1

 ш1.2
    2Примеры 0 ( 1демонстрации нестрогих вычислений в Haskell 0).
 ш1.0

    21. 0 Prelude> head ['a',error "123"]
      'a' :: Char                            => head('a',┴)='a'

      Prelude> head ['a',undefined]
      'a' :: Char                            => head('a',┴)='a'

      Prelude> (\x n -> x) 1 (error "123")
      1 :: Integer                           => (\x n -> x)(1,┴)=1

 ш1.1
   Другими словами,  если  отсутствует  необходимость  в вычислении
 1значения 0 второго элемента списка, то он и не будет вычисляться.
   Тем не менее, иногда функция head ведёт себя как строгая функция:
 ш1.0

   Prelude> head [error "" :: Int]

    22. 0 Prelude> tail ['a',error "123"]
      "
      Program execution error: 123          => tail('a',┴)=┴

      Prelude> tail ['a',undefined]
      "
      Program execution error: {undefined}  => tail('a',┴)=┴

      Prelude> tail (tail ['a',error ""])
      "" :: [Char]                          => tail(tail('a',┴))=""

 ш1.1
   Итак, если есть необходимость в вычислении  1значения 0 второго эле-
мента списка, то он, естественно, будет вычисляться.

 ш1.2
   Теперь можно утверждать, что язык Haskell осуществляет  вычисле-
ния, интерпретируя равенства как  _ 1объявления . 0 (или  _ 1определения . 0), а не
как  _ 1присваивания . 0 в языках императивного программирования.
   Например, рассмотрим выражение x=1/0.
   Тогда его интерпретация:
 ш1.1
   (1) как  1присваивания 0 означает "вычислите 1/0 и сохраните резуль-
тат в x";
   (2) как  1равенства 0 означает "определите x как 1/0", т.е. значение
1/0 будет вычисляться только тогда,  когда оно необходимо (только в
этот момент возникнет ошибка " 1Деление на 0 0").  Само по себе это оп-
ределение не подразумевает каких-либо вычислений.
 ш1.2

                  3Моделирование 0  3строгих вычислений
                           3в языке Haskell

 ш1.0
                                              1Ирис над водой -
                                              1как же всё-таки похоже
                                              1отражение 0!
                                                  1М.Басё (1644-1694)
 ш1.2

    _ 1Строгая функция . 2 seq 0 имеет сигнатуру типа
 ш1.0

    2seq 0 :: a -> b -> b

 ш1.2
и " 1вычисляет 0" ( 1в смысле, указанном ниже 0) значение первого аргумента
(типа a), а затем возвращает значение второго аргумента (типа b).
   Другими словами, функция seq определена следующим образом:
 ш1.0

    7( 0seq(┴,b)=┴;
    7*
    79 0seq(a,b)=b, если a 7- 0┴,

 ш1.2
причём первый аргумент вычисляется лишь до  _ 1слабой заголовочной нор-
 _ 1мальной формы . 0 (англ. " 3W 1eak  3H 1ead  3N 1ormal  3F 1orm 0").
   Например, слабой заголовочной нормальной формой для списка [1..]
является 1:_.
    2Примеры 0 ( 1вызова функции seq 0).
 ш1.0

   (а) Prelude> seq 1 sin 3
       0.14112                         => seq(1,sin(3))=0.14112

   (б) Prelude> seq (sin 4) 5
       5 :: Integer                    => seq(sin(4),5)=5

   (в) Prelude> seq [1..] 5
       5 :: Integer                    => seq([1..],5)=5

   (г) Prelude> seq (length [1..]) 5
       "CTRL+Break"                    => 1 не завершаются 0...

   (д) Prelude> seq (error "123") 5
       Program execution error: 123    => seq(┴,5)=┴

   (е) Prelude> seq 1 "3" ++ (error "2")
       "3
       Program execution error: 2      => seq(1,┴)=┴

   (ж) Prelude> seq ("0" ++ error "1")
                    ("0" ++ error "2")
       "0
       Program execution error: 2      => seq(┴,┴)=┴

 ш1.2
   Итак, функция
 ш1.0

   seq :: a -> b -> b

 ш1.2
возвращает свой  второй  аргумент  и  ведёт  себя почти как функция
const.  Однако у выражения (seq x y) вначале вычисляется x до WHNF,
после чего работа продолжается со вторым параметром y.
   Заметим, что в выражении (const x y) второй параметр y вообще не
рассматривается, а x вычисляется без промедления.
   Ещё одним способом моделирования строгих вычислений в языке Has-
kell является использование операции ($!).
    2Определение 0.
 ш1.1
    _ 1Операция строгой аппликации . 0 ($!) определяется так:
 ш1.0

   f $! x = x `seq` (f x)

 ш1.2
    2Определение 0 ( 1повторение 0).
 ш1.1
    _ 1Операция нестрогой аппликации . 0 ($) определяется так:
 ш1.0

   f $ x = f x

 ш1.2
                       3Понятие "утечка памяти"
   Укажем важное применение строгой функции  2seq 0 для борьбы с "утеч-
кой памяти".  Суть проблемы заключается в том,  что  объём  памяти,
требуемый  1ещё невычисленному выражению 0, может значительно отличать-
ся от размера его  1заголовочной нормальной формы 0 (WHNF).
   Например,
 ш1.0

   ((((0 + 1) + 2) + 3) + 4)

 ш1.2
займёт для хранения больше памяти,  чем его  1нормальная форма 0, кото-
рой является 10.
   Однако имеются исключения, связанные с использованием " 1синтакси-
ческого сахара": рассмотрим невычисленное выражение
 ш1.0

   enumFromTo 1 1000,

 ш1.2
и его вычисленное значение [1..1000].
   Применение функции содержит всего три узла, отчего занимает зна-
чительно меньше памяти,  чем список [1..1000], содержащий как мини-
мум 1000 элементов.
    2Определение 0 ( 1описательное 0).
 ш1.1
   Говорят, что  _ 1происходит утечка памяти . 0,  если в процессе вычисле-
ний невычисленное выражение неуклонно увеличивает  свои  размеры  в
памяти.

 ш1.2
   Исправлением ситуации является вмешательство программиста в про-
цесс вычисления; для этого воспользуемся функцией 2 seq 0.
    2Пример 0 ( 1строгая левая свёртка и утечка памяти 0).
 ш1.1
   Рассмотрим вызов функции
 ш1.0

   foldl (+) 0 [1..100],

 ш1.1
которая определена в Prelude следующим образом:
 ш1.0

   foldl :: (a -> b -> a) -> a -> [b] -> a
   foldl f a []     = a
   foldl f a (x:xs) = foldl f (f a x) xs,

а процесс вычислений выглядит так:

   foldl (+) 0 [1..100] =>
       => foldl (+)   0                 (1 : [2..100]) =>
       => foldl (+)  (0 + 1)            [2..100]       =>
       => foldl (+)  (0 + 1)            (2 : [3..100]) =>
       => foldl (+) ((0 + 1) + 2)       [3..100]       =>
       => foldl (+) ((0 + 1) + 2)       (3 : [4..100]) =>
       => foldl (+) ( _((0 + 1) + 2) + 3 .) [4..100]       =>
       => ...

 ш1.1
   Размер параметра-аккумулятора неуклонно возрастает,  т.е.  1проис-
 1ходит классическая утечка памяти 0.  Чтобы её  избежать,  потребуется
гарантия постоянного нахождения аккумулятора в WHNF.
   Следующая версия свёртки foldl (модуль Data.List в интерпретато-
ре GHCi) делает это:
 ш1.0

   foldl' :: (a -> b -> a) -> a -> [b] -> a
   foldl' f a []     = a
   foldl' f a (x:xs) = let a' = f a x
                       in seq a' (foldl' f a' xs)

   Теперь процесс вычисления выглядит так:

   foldl' (+) 0 [1..100]
       => foldl' (+)  _0 . (1 : [2..100])
       => let a' = 0 + 1 in seq a' (foldl' (+) a' [2..100])
       => let a' = 1     in seq a' (foldl' (+) a' [2..100])
       => foldl' (+)  _1 . [2..100]
       => foldl' (+) 1 (2 : [3..100])
       => let a' = 1 + 2 in seq a' (foldl' (+) a' [3..100])
       => let a' = 3     in seq a' (foldl' (+) a' [3..100])
       => foldl' (+)  _3 . [3..100]
       => ...

 ш1.1
   Итак, в процессе вычисления выражение имеет постоянный размер.
   Использование функции  2seq 0 гарантирует постоянное "принуждение" к
вычислению WHNF  для  аккумулирующего параметра до того,  как будет
рассмотрен следующий элемент списка.
   Таким образом,  функция foldl склонна к  1утечкам памяти 0,  так что
лучше использовать вместо неё свёртки foldl' или foldr.

 ш1.2
   Функция foldl1 также имеет строгий аналог, имеющий имя  2foldl1' 0.

               3Конструирование потенциально бесконечных
                     3списков с помощью корекурсии

 ш1.0
               _ 1Сепульки . - важный элемент цивилизации ардридов   0( 1см. 0)
               1на планете Энтеропии. См.  _Сепулькарии ..
               _ 1Сепулькарии . - предметы, служащие для сепуления  0( 1см. 0) 1.
               _ 1Сепуление . -  деятельность  Ардридов   0( 1см. 0) 1 на планете
               1Энтеропии  0( 1см. 0) 1. См.  _Сепульки ..
                               1С.Лем. Звёздные дневники Ийона Тихого
 ш1.2

   Понятие " 1корекурсия 0" определяется с помощью понятия " 1коданные 0".
    2Определение 0 ( 1описательное 0) [Душкин,2007,с.37].
 ш1.1
    _ 1Коданные . 0 обладают следующими свойствами:
   (1) они скрывают свою структуру (в отличие от данных);
   (2) они не содержат атрибутов, имеющих смысл " 1значение 0";
   (3) они обладают только методами доступа,  некоторые из  которых
возвращают данные, некоторые - коданные;
   (4) они обычно являются  1бесконечными структурами 0.

 ш1.2
   В языке  Haskell  интерпретацией  коданных  являются  1рекурсивные
 1абстрактные типы данных 0, например, списки.
   Отметим, что в языке Haskell  _ 1идиома коданных . 0 отсутствует; други-
ми  словами,  это понятие в языке не определено в явном виде (здесь
под  _ 1идиомой . 0 (лингв.) понимается оборот  речи,  употребляющийся  как
некоторое целое, не подлежащий дальнейшему разложению.)
   Поэтому мы  будем  моделировать  коданные с помощью  1потенциально
 1бесконечных списков 0,  которые ещё называются  _ 1потоками . 0 или   _ 1ленивыми
 _ 1списками . 0 (от англ.  1lazy lists 0).
    2Определение 0 ( 1содержательное 0).
 ш1.1
    _ 1Корекурсия . 0 ( 1в  программировании 0) - это тип операции,   1дуальной 0 к
рекурсии. Более точно, правило использования  1корекурсии на 0  1коданных
дуально правилу применения  1рекурсии на данных 0:
   (1) рекурсия "сворачивает" структуру данных, исходя из начально-
го значения аргумента, т.е. рекурсия анализирует и порождает конеч-
ные структуры данных.  Другими словами, рекурсивные определения ра-
ботают с  1данными 0, осуществляя "спуск" от начальных значений входных
параметров к  таким значениям,  на которых происходит остановка ре-
курсивного процесса;
   (2) корекурсия "разворачивает" результат  на  основе  начального
значения аргумента, т.е. корекурсия порождает  1бесконечные 0 структуры
данных. Другими словами, корекурсия работает с  1коданными 0, производя
"накрутку" значений на начальные величины входных  параметров,  ни-
когда не останавливаясь;
   (3) рекурсия не применима к  1коданным 0,  поскольку процесс анализа
может никогда не остановиться;
   (4) корекурсия не может применяться в случаях,  если результатом
её работы должны являться данные, поскольку данные всегда конечны.

 ш1.2
    2Определение 0.
 ш1.1
    _ 1Корекурсивное определение . 0 - это рекурсивное определение,  не со-
держащее  1базисного пункта 0, но содержащее  1индуктивный пункт 0.
   Оно всегда определяет бесконечные объекты;  другими словами, ре-
зультатом применения корекурсии являются  1коданные 0.

 ш1.2
   Механизм корекурсии используется с  1механизмом отложенных  вычис-
 1лений 0 для генерации потенциально бесконечных структур данных на ба-
зе потенциально бесконечных списков (потоков).
    2Примеры 0 ( 1классические 0).
 ш1.0

   -- Функция конструирует потенциально бесконечный
   -- список натуральных чисел вида [1,1,1,...]
   --------------------------------------------
   ones:: [Integer]
   ones = 1 : ones
   -- ***********************************************
   -- Функция конструирует  потенциально  бесконечный
   -- список натуральных чисел вида [n+1,n+2,n+3,...]
   --------------------------------------------------
   subNats:: Integer -> [Integer]
   subNats n = n : subNats (n+1)

 ш1.2
   Выделим  _ 1паттерны корекурсии . 0, основанные на использовании функци-
оналов map, iterate, zipWith.
    2Пример 0 ( 1паттерна корекурсии map 0).
 ш1.0

   -- Функция конструирует потенциально бесконечный
   -- список натуральных чисел вида [1,1,1,...]
   --------------------------------------------
   ones':: [Integer]
   ones' = 1 : map id ones'
   -- ***********************************************
   -- Функция конструирует  потенциально  бесконечный
   -- список натуральных чисел [0,1,2,...]
   ---------------------------------------
   nats:: [Integer]
   nats = 0 : map (+ 1) nats
   -- ***********************************************
   -- Функция конструирует  потенциально  бесконечный
   -- список нечётных натуральных чисел [1,3,5,...]
   ------------------------------------------------
   odds:: [Integer]
   odds = 1 : map (+ 2) odds
   -- ***********************************************
   -- Функция конструирует  потенциально  бесконечный
   -- список чётных натуральных чисел  [0,2,4,...]  с
   -- помощью комбинатора неподвижной точки (y)
   --------------------------------------------
   evens:: [Integer]
   evens = y (\f -> 0 : map (+ 2) f)
      where y f = f (y f)

 ш1.2
   Функционал iterate определим с помощью корекурсии так:
 ш1.0

   iterate f x = x : iterate f (f x)

 ш1.2
   Важно, что  первые n элементов получающегося бесконечного списка
вычисляются за 7 O 0(n) шагов.
    2Пример 0 ( 1паттерна корекурсии iterate 0).
 ш1.0

   -- Демонстрация моделирования потенциально беско-
   -- нечных списков с помощью функционала iterate
   --
   --  iterate f x = x : iterate f (f x)
   --
   -- ***********************
   theOnes  = iterate  id   1
   theNats  = iterate (+ 1) 0
   theOdds  = iterate (+ 2) 1
   theEvens = iterate (+ 2) 0

 ш1.2
    2Пример 0 ( 1паттерна корекурсии zipWith 0).
 ш1.0

   -- Функция конструирует  потенциально бесконечный
   -- список натуральных чисел [0,1,2,...] с помощью
   -- функционала zipWith
   -- *************************************
   theNats1 = 0 : zipWith (+) ones theNats1

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1, Пример 2.

 ш1.2
   Корекурсию удобно использовать для генерации потоков, содержащих
решения линейных и нелинейных  1рекуррентных соотношений 0.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 3.

 ш1.2
   Построим корекурсивные функционалы, используя, например, функци-
онал comap:
 ш1.0

   comap f (x:xs) = f x : comap f xs
   ------------------------------------------
   test1 = take 10 (comap (\x -> x^2) [1..5])
   test2 = take 10 (comap (\x -> x^2) [1..])
   test3 = take 10 (map   (\x -> x^2) [1..])

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   Формально понятия " 1коданные 0" и " 1корекурсия 0" определяется в   1тео-
 1рии категорий 0.
 ш1.2

               3Конструирование потенциально 0  3бесконечных
                  3списков с помощью 0  3двух точек ".."

 ш1.0
                          1Математика - наука о бесконечном.
                                               1А.Вейль. Открытый мир

                          1Бесконечность - это такое полезное прибли-
                          1жение сверху к очень большому конечному. 0
                                                       1В.А.Успенский
 ш1.2

   В языке  Haskell  существует  возможность создавать списки с по-
мощью двух точек "..",  моделирующих потенциально бесконечные мате-
матические последовательности.
   При задании   _ 1потенциально бесконечного списка . 0 его последний эле-
мент не указывается, т.е.
 ш1.0

   [a..]

 ш1.2
    3Замечание 0.
 ш1.1
   [1..] - синтаксический сахар  для   1арифметической  прогрессии 0  с
разностью равной 1.

 ш1.2
   При задании  _ 1потенциально бесконечного списка . 0, моделирующего  1бес-
 1конечную арифметическую прогрессию 0, разность прогрессии определяет-
ся при помощи указания первого и второго элементов:
 ш1.0

   [a,b..]

 ш1.2
   При отсутствии  указания  второго  элемента  списка моделируется
арифметическая прогрессия, разность которой равна 1.
    2Примеры 0 ( 1задания потенциально бесконечных списков 0).
 ш1.1
    21. 0 Список натуральных чисел: [1..].
    22. 0 Список нечётных чисел   : [1,3..].

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 4.

 ш1.2
   Разумеется, " 1бесконечность 0  - это не порок",  главное чтобы ког-
да-нибудь при её использовании цепочка вычислений  реально  оборва-
лась.

                3Конструкторы потенциально 0  3бесконечных
                      3списков из модуля Prelude

 ш1.0
              1- ... Составляйте список гостей.
              1- Кого же мне пригласить 0?
              1- Всех 0!
                   1А.Дюма. Виконт де Бражелон, 0  1или Десять лет спустя 0
 ш1.2

    21. 0 Функция, конструирующая  1потенциально бесконечный список 0, сос-
тавленный из заданного элемента:
 ш1.0

    2repeat 0:: a -> [a]
    2repeat x

   Например:

   > repeat 2   > repeat ['a']   > repeat [1,2]      > repeat 'a'
   [2,2,...]    ["a","a",...]    [[1,2],[1,2],...]   "aa..."

 ш1.2
    22. 0 Функция, конструирующая  1потенциально бесконечный список 0, сос-
тоящий из повторения элементов исходного списка:
 ш1.0

    2cycle 0:: [a] -> [a]
    2cycle lst

   Например:

   > cycle [2]        > cycle [1,2,3]     > cycle [[1],[2,3]]
   [2,2,...]          [1,2,3,1,2,3,...]   [[1],[2,3],[1],[2,3],...]

   > cycle ['a','b']
   "abab..."

 ш1.2
    23. 0 Функция, конструирующая  1потенциально бесконечный список 0, эле-
менты  которого  образуют   _ 1арифметическую прогрессию . 0 с разностью 1,
начиная с заданного положительного элемента:
 ш1.0

    2enumFrom 0:: Real a => a -> [a]
    2enumFrom n

   Например:

   > enumFrom 1
   [1,2,3,4,5,6,7,8,9,10,11,...]

 ш1.2
    24. 0 Функция, конструирующая  1потенциально бесконечный список 0, эле-
менты которого образуют  _ 1арифметическую прогрессию . 0 с разностью,  оп-
ределяемую двумя начальными положительными значениями:
 ш1.0

    2enumFromThen 0:: Real a => a -> a -> [a]
    2enumFromThen m n

   Например:

   > enumFromThen 3 10
   [3,10,17,24,31,...]
 ш1.2

                    3Стратегия ленивых вычислений

 ш1.0
                            1Ленивые вычисления основаны на той идее,
                            1что функция не вычисляет свои аргументы.
                                                      1С.Пейтон-Джонс
 ш1.2

   Нестрогий язык  программирования  (по  определению) поддерживает
отложенные вычисления,  которые в Haskell  моделируются  с  помощью
следующей  _ 1стратегии ленивых вычислений . 0.
   Вычисления, не являющиеся ленивыми,  называются  _ 1немедленными вы-
 _ 1числениями . 0 (англ.  1eagerly 0).
    21. 0 Вычисление выражений максимально откладывается, т.е. трансля-
тор Haskell вычисляет выражение до тех пор,  пока не  будет  найден
конструктор.  Остальная часть значения не вычисляется; её место за-
нимает  1местозаполнитель 0, показывающий, как может быть вычислено это
конкретное поле,  и  называемый   _ 1переходником . 0 или " _ 1задумкой . 0" (англ.
 1thunk 0) и представляющий собой небольшой программный код,  выполняю-
щий требуемые преобразования.
    22. 0 После  вычисления  переходника  результат  сохраняется на тот
случай, если он где-нибудь снова понадобится,  поэтому  второй  раз
его вычислять уже не нужно. Итак, каждое выражение в программе нуж-
но вычислять только один раз.
    23. 0 Транслятор Haskell помогает в совместном использовании  пере-
ходников,  ссылающихся  на одни и те же выражения,  а это означает,
что он позволяет многократно использовать вычисления  из  какой-ни-
будь части программы в других местах.
    2Пример 0  21 0.
 ш1.1
   Применим описанный  выше порядок действий для вычисления выраже-
ния head [1..]:
   (а) вначале будут созданы лишь конструктор  (:)  с  переходником
для  элемента  1  и  с ещё одним переходником для остального списка
[2..];
   (б) когда  к  списку  применяется функция head,  то возвращается
первый переходник;
   (в) если  нужно вывести значение на экран,  то переходник должен
быть "развёрнут",  и за рецептом создания значения должно  последо-
вать создание значения, т.е. 1.
   Изобразим сказанное схематически:
 ш1.0

                               (:)
                       7( 0┌─────┐ ═о 0    ═K 0┌─────┐ 7) 0      ┌─────┐   1Вывод
                       72 0│ 1thunk 0│     │ 1thunk 0│ 72 0  1head 0 │ 1thunk 0│ 1 на 0  1экран
   head [1..] => head  72 0│  1  │     │[2..]│ 72 0  =>  │  1  │     =>   21
                       72 0└─────┘     └─────┘ 72 0      └─────┘
                       79 0                    70

 ш1.2
   Стратегия ленивых  вычислений  зачастую  является  полезной,  но
иногда может принести неприятности.  Как это обычно бывает в  прог-
раммировании,  свои компромиссы есть и в стратегии ленивых вычисле-
ний: откладывание вычислений пока не понадобится их результат,  мо-
жет  привести  к меньшему объёму вычислений,  а также даёт право на
жизнь некоторым  1идиомам программирования 0, недоступным в других язы-
ках.
   В то же время при этом может создаваться множество переходников,
что  вызывает излишнее расходование памяти и вынуждает операционную
систему активно использовать "подкачку" страниц памяти,  что  может
замедлить выполнение программы.
    2Пример 0  22 0 [Мена,2015,с.148].
 ш1.1
   Изобразим процесс вычисления значения функции

   foldr (+) 0 [1,2,3],

чётко обозначая  переходники;  каждый  переходник  будет  содержать
внутри себя рецепт его преобразования в конкретное значение:
 ш1.0

                            ┌────────────────────────┐
   ┌───────────────────┐    │  1thunk 0┌─────────────────┤
   │        1thunk 0       │    │      │       1thunk 0      │
   │foldr (+) 0 [1,2,3]│ => │(+) 1 │foldr (+) 0 [2,3]│ =>
   └───────────────────┘    └──────┴─────────────────┘
                            ┌─────────────────────────────┐
                            │  1thunk 0┌──────────────────────┤
                            │      │  1thunk 0┌───────────────┤
                            │      │      │      1thunk 0     │
                         => │(+) 1 │(+) 2 │foldr (+) 0 [3]│ =>
                            └──────┴──────┴───────────────┘
                            ┌───────────────────────────────────┐
                            │  1thunk 0┌────────────────────────────┤
                            │      │  1thunk 0┌─────────────────────┤
                            │      │      │  1thunk 0┌──────────────┤
                            │      │      │      │              │
                         => │(+) 1 │(+) 2 │(+) 3 │foldr (+) 0 []│ =>
                            └──────┴──────┴──────┴──────────────┘
                            ┌─────────────────────┐
                            │  1thunk 0┌──────────────┤
                            │      │  1thunk 0┌───────┤
                            │      │      │  1thunk 0 │
                         => │(+) 1 │(+) 2 │(+) 3 0│ =>
                            └──────┴──────┴───────┘
                            ┌──────────────┐
                            │  1thunk 0┌───────┤    ┌───────┐
                            │      │  1thunk 0 │    │  1thunk 0 │
                         => │(+) 1 │(+) 2 3│ => │(+) 1 5│ =>  26
                            └──────┴───────┘    └───────┘

 ш1.1
   Итак, неформально  порядок  вычисления  с использованием функции
foldr можно представить так:
 ш1.0

   (1 + (2 + (3 + (... +  1Переходник 0)))),

 ш1.1
поэтому пока  интерпретатор не доберётся до финального этапа вычис-
ления функции foldr,  он не может перейти к сложению. Это означает,
что для каждого элемента в списке создаётся новый переходник.
   Проверьте в интерпретаторе GHCi
 ш1.0

   foldr (+) 0 [1..1000000000]

 ш1.2
   Итак, использование функционалов foldr и foldl приводит  к  воз-
растанию количества  переходников,  что в итоге приводит к эффекту,
который мы ранее назвали  _ 1утечкой памяти . 0.
    2Примеры 0 ( 1ленивых вычислений в интерпретаторе GHCi 0).
 ш1.1
   Вначале напомним основные моменты стратегии ленивых вычислений:
   (1) определение  выражения (с помощью let) приводит к формирова-
нию в памяти переходника, представляющего это выражение;
   (2) переходник остаётся невычисленным до тех пор, пока не потре-
буется его значение;
   (3) будучи однажды вычисленным,  переходник в дальнейшем  просто
заменяется на своё значение.
    1Отладчик 0  1интерпретатора 0 GHCi предоставляет несколько  команд,  с
помощью которых можно проинспектировать структуру выражений на язы-
ке Haskell, не разрушая её.
   Команда  2:sprint 0 выводит значение выражения, не пытаясь его пред-
варительно вычислить. Например:
 ш1.0

   > let x = 1 + 2 :: Int
   > :sprint x
   x = _

 ш1.1
   Специальный символ "_" означает " 1не вычислено 0" (другие термины -
" 1переходник 0", " 1задумка 0")  и соответствует объекту в памяти,  предс-
тавляющему  _ 1невыполненное вычисление . 0 1+2. Переходник, представляющий
x, будет вычислен, как только потребуется соответствующее значение.
   Проще всего что-либо вычислить - это вывести  значение,  поэтому
поступим просто:
 ш1.0

   > x
   3

 ш1.1
   Если теперь проинспектировать значение x с помощью  :sprint,  то
станет ясно, что оно уже вычислено:
 ш1.0

   > :sprint x
   x = 3

 ш1.1
   Напомним также,  что  функция  seq  вычисляет первый параметр до
 _ 1слабой заголовочной нормальной формы . 0 (WHNF).
 ш1.0

    21. 0 > let x = 1 + 2    22. 0 > let x = 1 + 2    23. 0 > let x = 1 + 2
      > :sprint x          > let y = x + 1      > let z = (x,x)
      x = _                > :sprint x          > :sprint z
      > x                  x = _                z = (_,_)
      3                    > :sprint y
      > :sprint x          y = _
      x = 3                > seq y ()
                           ()
                           > :sprint x
                           x = 3
                           > :sprint y
                           y = 4

    24. 0 > import Data.Tuple       25. 0 > let xs = map (+ 1) [1..5]
      > let x = 3                 > :sprint xs
      > let z = swap (x,x+1)      xs = _
      > :sprint z                 > seq xs ()
      z = _                       ()
      > seq z ()                  > :sprint xs
      ()                          xs = _:_
      > sprint z                  > length xs
      z = (_,_)                   5
      > seq x ()                  > :sprint xs
      ()                          xs = [_,_,_,_,_]
      > sprint z                  > xs
      z = (_,3)                   xs = [2,3,4,5,6]

 ш1.2
    3Замечание 0 ( 1повторение 0).
 ш1.1
   Строгие вычисления - это синоним " 1вызова по значению 0"  в  языках
программирования.
   О ленивых вычислениях иногда говорят как о " 1вызове по  необходи-
 1мости 0", что  является частным случаем более общей стратегии " 1вызова
 1по имени 0", в которой аргументы функции не вычисляются до тела функ-
ции, а непосредственно подставляются.
   Разница в том,  что при " 1вызове по имени 0" одно и то же выражение
может вычисляться более одного раза,  а при "вызове по необходимос-
ти" для однократного вычисления используются  1переходники 0.
 ш1.2

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 0  21.
 ш1.0

 ш1.2

    2Пример 0  22.
 ш1.0

 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                1Галактика неслась сквозь бесконечность, имеющую кри-
                1визну,  сжималась и вновь  расширялась  пульсирующая
                1Вселенная.  А  на крохотной планете Земля,  зачем-то
                1разгороженной границами,  обыватели копошились в со-
                1тах своих жилищ, ничего не слыша, не видя. 0
                                              1Д.Гранин. Иду на грозу
 ш1.2

    20. 0 (По [Анисимов,Пупышев,2006,с.287,№16.188])
   Найдите ошибки,  описки, неточности и прочие изъяны в данной ла-
бораторной работе.
                 21. 3 Конструирование 0  3конечных списков
    21 4* 2. 0 Укажите,  не используя интерпретатор Haskell,  результат вы-
полнения следующих функций:
 ш1.0

   (1) [(x,y) | x <- [1..3],y <- [1..3]];

   (2) [x+y | x <- [1..4],y <- [1..x],even x].

 ш1.2
    22. 0 (По [Душкин,2007])
   Напишите рекурсивную функцию, конструирующую  1конечный 0 n-элемент-
ный список n 7е ═N 0:
 ш1.1
   (1) натуральных чисел;          (5) факториалов;
   (2) нечётных натуральных чисел; (6) степеней числа 3;
   (3) чётных натуральных чисел;   (7) треугольных чисел Ферма;
   (4) кубов натуральных чисел;    (8) пирамидальных чисел Ферма.

 ш1.2
                   22. 3 Конструирование потенциально
                    3бесконечных списков 2 ( 3потоков 2)
    21 4* 2. 0 Укажите,  не используя интерпретатор Haskell,  результат вы-
полнения следующей функции:
 ш1.0

   take 5 [2*x | x <- [1..], x^2>3]

 ш1.2
    22. 0 Напишите  корекурсивную  функцию,  генерирующую  потенциально
бесконечные списки (потоки):
 ш1.1
   (1) квадратов натуральных чисел;
   (2) кубов натуральных чисел;
   (3) степеней пятёрки;
   (4) факториалов натуральных чисел;
   (5) мультифакториалов натуральных чисел;
   (6) вторых суперстепеней натуральных чисел;
   (7) третьих суперстепеней натуральных чисел.

 ш1.2
    23. 0 (По [Андерсон,2003,с.198])
   Напишите функцию, конструирующую потенциально бесконечный список
элементов, вычисляемых с помощью рекурсивной функции:
 ш1.0

        7( 0f(0)=1;                          7( 0f(0)=2;
   (1)  7* 0f(1)=3;                     (6)  7* 0f(1)=4;
        79 0f(k)=2f(k-1)-f(k-2);             79 0f(k)=3f(k-1)-2f(k-2);

        7( 0f(0)=0;                          7( 0f(0)=1;
   (2)  7* 0f(1)=1;                     (7)  7* 0f(1)=2;
        79 0f(k)=(f(k-1)) 52 0-(f(k-2)) 52 0;        79 0f(k)=(f(k-1))!-(f(k-2))!;

        7( 0f(0)=1;                          7( 0f(0)=0;
   (3)  7* 0f(1)=2;                     (8)  7* 0f(1)=2;
        79 0f(k)=(f(k-1)) 52 0-f(k-2)+k 52 0;        79 0f(k)=(f(k-1))! 7_ 0(f(k-2))!;

        7( 0f(0)=1;                          7( 0f(0)=10;
   (4)  7* 0f(1)=2;                     (9)  7* 0f(1)=20;
        79 0f(k)=(f(k-1)-f(k-2))*k!;         79 0f(k)=└(f(k-1)+f(k-2))/k!┘;

        7( 0f(0)=-1;                          7( 0f(0)=-1;
   (5)  7* 0f(1)=1;                     (10)  7* 0f(1)=1;
        79 0f(k)=f(k-1) 7_ 0f(k-2);               79 0f(k)=f(k-1) 7_ 0(f(k-2)) 52 0.
 ш1.2
