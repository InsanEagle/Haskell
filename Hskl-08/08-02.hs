   -- Демонстрация конструирования потенциально бесконечных
   -- списков (потоков, коданных) с помощью корекурсии
   -- ************************************************
   import List
   -- ****************************************************
   -- Функция конструирует потенциально бесконечный список
   -- чисел Фибоначчи вида [0,1,1,2,3,5,8,...]
   -- (первый способ)
   ------------------
   fibLst1 = abc 0 1
      where abc x0 x1 = x0 : abc x1 (x0 + x1)

   -- ****************************************************
   -- Функция конструирует потенциально бесконечный список
   -- чисел Фибоначчи вида [0,1,1,2,3,5,8,...]
   -- (второй способ)
   ----------------------------------------------------
   fibLst2 = 0 : 1 : zipWith (+) fibLst2 (tail fibLst2)

   -- ****************************************************
   -- Функция конструирует потенциально бесконечный список
   -- чисел Фибоначчи вида [0,1,1,2,3,5,8,...]
   -- (третий способ)
   -----------------------------------------------------
   fibLst3 = map fst $ iterate (\(a,b) -> (b,a+b)) (0,1)

   -- ****************************************************
   -- Функция конструирует потенциально бесконечный список
   -- чисел Фибоначчи вида [0,1,1,2,3,5,8,...]
   -- (четвёртый способ)
   ------------------------------
   fibo = nub (map fst fibopairs)
   ----------------------------------------------------------
   fibopairs = (0,1) : (1,2) : [(y,x+y) | (x,y) <- fibopairs]

   -- ****************************************************
   -- Функция конструирует потенциально бесконечный список
   -- чисел вида [-1,1,-1,1,-1,1,1-,...]
   -------------------------------------
   abc = pr fibLst1
      where pr (x1:x2:x3:lst) = x1*x3-x2*x2 : pr (x2:x3:lst)

   -- ************************************************
   -- Функция возвращает список простых чисел из [2..]
   -- (первый способ)
   ------------------------------
   sieve:: [Integer] -> [Integer]
   sieve (0:xs) = sieve xs
   sieve (n:xs) = n : sieve (mark xs 1 n)
       where mark (y:ys) k m | k==m = 0 : mark ys   1   m
                             | True = y : mark ys (k+1) m
   -- ***************************************************
   -- Функция возвращает список простых чисел из [2..]
   -- (второй способ)
   ----------------------
   primes' = sieve' [2..]
      where sieve' (n:xs) = n : sieve' (filter (\m -> rem m n/=0)
                                               xs)

   -- **********************************************
   -- Функция выводит поток строк, которые конструи-
   -- руются по следующим правилам:
   --
   --   (1) s ="0";  (2) s   =s ++ inv s ,
   --        1            k+1  k        k 
   --   
   -- где функция inv инвертирует все "биты" аргумента.
   --
   --   Автор: Швецкий М.В. (08.12.2013, 20:25-20:32)
   -- ***********************************************
   morse = iterate inv "0"  
        where inv str = str ++ map (\x -> if x=='1'
                                            then '0' else '1') str

   -- *******************************
   -- Неудачные тестовые примеры:
   -----------------------------------
   test1 = take 20 $ zip fibLst1 [0..]
   test2 = take 20 $ zip fibLst2 [0..]
   test3 = take 20 $ zip fibLst3 [0..]
   test4 = (fibLst1 !! 100,fibLst2 !! 100,nth 100 fibLst3)
   test5 =   take 10 fibo == [0,1,2,3,5,8,13,21,34,55]
          && take 13 fibo == [0,1,2,3,5,8,13,21,34,55,89,144,89+144]
   test6 = take 200 fibo
   ----------------------------------------------------------
   test7  = (==) (take 2000 $ abc) (take 2000 $ cycle [-1,1])
   test8  = take 100 (sieve [2..])
   test9  = take 100 primes'
   test10 = take 10 morse
