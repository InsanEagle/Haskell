    2УПРАЖНЕНИЕ 0.
    2ИНДУКТИВНЫЕ ОПРЕДЕЛЕНИЯ ОПЕРАЦИЙ И ПРЕДИКАТОВ,  ЗАДАННЫХ НА МНО-
 2ЖЕСТВАХ СЛОВ: построение и доказательство правильности

 ш1.0
                                              1Слова - хамельоны,
                                              1Они живут спеша.
                                              1У них свои законы,
                                              1Особая душа
                                              1Они спешат меняться,
                                              1Являя все цвета;
                                              1Поблекнут - обновятся,
                                              1И в том их красота...
                                                          1К.Бальмонт
 ш1.2

    _ 1Знать понятия . 0:
 1   0ш1.1
   -  1натуральная индукция, полная индукция  0( 1повторение 0);
   -  1базовые операции над словами в алфавите  0( 1повторение 0) 1.

 1   0ш1.2
    _ 1Основные понятия . 0:
 1   0ш1.0
    1- вполне упорядоченное множество,  трансфинитная индукция, прин-
 1цип трансфинитной индукции 0;
    1- язык структурированных программ 0;
    1- синтез программ на языке функционального  программирования  из
 1индуктивных определений.

 1   0ш1.2
    _ 1Уметь . 0:
 ш1.1
    1- 0 осуществлять построение индуктивных операций и предикатов, за-
данных на множествах слов;
   - доказывать правильность индуктивных операций и предикатов, за-
данных на множествах слов.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                        3Натуральная индукция.
                           3Полная индукция
    _ 1Метод математической индукции . 0 (от лат.   1inductio 0 -  1наведение 0)  -
это  основной  метод  доказательства в математике,  применяемый для
исследования характеристических свойств множеств слов в алфавите.
    _ 1Натуральная индукция . 0 - это разновидность  метода  математической
индукции; более точно,  _ 1натуральной индукцией . 0 называется метод дока-
зательства утверждений в математике,  основанный  на  использовании
 1принципа  0( 1аксиомы 0)  1математической индукции 0.
   Пусть 7 R 0 - некоторое свойство натуральных чисел.
    2Определение 0 ( 1принцип математической индукции 0) 2.
 ш1.1
   Допустим, что доказаны следующие утверждения:
   (1) натуральное число 0 обладает свойством  7R 0;
   (2) если  какое-нибудь натуральное число n обладает свойством  7R 0,
то и следующее за ним число n' ═+ 0n+1 также обладает свойством  7R 0.
   Тогда каждое натуральное число обладает свойством  7R 0.

 ш1.2
    2Теорема 0 ( 1полная индукция 0,  1возвратная индукция 0).
 ш1.1
   Пусть свойство  7R 0 таково,  что для любого натурального числа n из
того, что этим свойством обладают все натуральные числа, меньшие n,
следует, что им обладает и число n.
   Тогда свойством  7R 0 обладают все натуральные числа.
 ш1.2

                   3Вполне упорядоченное множество

 ш1.0
                         1... за душу каждого математика борются  ан-
                         1гел топологии и дьявол абстрактной алгебры.
                                                             1А.Вейль
 ш1.2

    2Определение 0.
 ш1.1
    2(1)  _ 1Вполне упорядоченным множеством . 0  называется  множество X, на
котором определено бинарное отношение <, обладающее свойствами:
 ш1.1
   (а) если х,y,z 7е 0Х, а х<y и y<z, то х<z;
   (б) для  х,y 7е 0Х справедлива одна и только одна из трёх возможнос-
тей: либо х<y, либо y<х, либо х=y;
   (в) любое  непустое  подмножество Х содержит  _ 1наименьший элемент . 0,
т.е.  если А - любое непустое подмножество Х,  то в множестве А су-
ществует некоторый элемент х,  такой,  что для любого y 7е 0А либо х=y,
либо x<y.

 ш1.1
    2(2) 0 Будем говорить, что  _ 1бинарное отношение . 0 <  _ 1вполне упорядочива-
 _ 1ет множество . 0 Х, если X является вполне упорядоченным множеством.

 ш1.2
    2Определение 0.
 ш1.1
   Пусть S - частично упорядоченное множество,  и пусть любая  воз-
растающая  последовательность x 41 7, 0x 42 7,777 0 в S стационарна,  т.е.  су-
ществует такое n 7е ═N 0, что x 4n 0=x 4n+1 0= 7777 0.
   Тогда говорят, что  _ 1множество . 0  1S  _удовлетворяет условию обрыва воз-
 _ 1растающих цепочек . 0 (англ.  1ascending chain condition 0,  1ACC 0).

 ш1.2
    2Теорема 0 ( 1условие обрыва возрастающих цепочек 0).
 ш1.1
   Условие обрыва возрастающих цепочек равносильно существованию  в
произвольном непустом подмножестве S  1максимального 0 элемента.

 ш1.2
    2Доказательство 0. 1 Упражняйтесь 0.
    2Определение 0.
 ш1.1
   Пусть S - частично упорядоченное множество с упорядочением  7. 0,  и
пусть любая убывающая последовательность x 41 7. 0x 42 7.777 0 в S стационарна,
т.е. существует такое n 7е ═N 0, что x 4n 0=x 4n+1 0= 7777 0.
   Тогда говорят,  что  _ 1S .  _удовлетворяет условию обрыва убывающих це-
 _ 1почек . 0 (англ.  1descending chain condition 0,  1DCC 0).

 ш1.2
    2Теорема 0 ( 1условие обрыва убывающих цепочек 0).
 ш1.1
   Условие обрыва  убывающих  цепочек  равносильно  существованию в
произвольном непустом подмножестве S  1минимального 0 элемента.

 ш1.2
    2Доказательство 0. 1 Упражняйтесь 0.
    2Теорема 0.
 ш1.1
   Для любого частично упорядоченного множества X перечисленные ни-
же условия эквивалентны.
   (1)  _ 1Условие минимальности . 0. Всякое непустое подмножество множест-
ва X обладает хотя бы одним минимальным элементом.
   (2)  _ 1Условие обрыва убывающих цепей . 0. Всякая строго убывающая пос-
ледовательность a 41 0>a 42 0>...>a 4n 0>...  элементов из X (называемая 2  _ 1цепоч-
 _ 1кой . 0) не может быть бесконечной.
   (3)  _ 1Условие индуктивности . 0.  Пусть для всякого x 7е 0X задано некото-
рое высказывание S(x). Все высказывания S(x), x 7е 0X, справедливы, ес-
ли будут выполнены два требования:
   (а) если x 40 0 - минимальный элемент в  X,  то  высказывание  S(x 40 0)
справедливо;
   (б) если  x не минимальный элемент в X,  и для всякого у<х (у 7е 0X)
высказывание S(у) справедливо, то справедливо и S(x).

 ш1.2
    2Доказательство 0.
    2(1)  0Пусть множество X удовлетворяет условию  (1);  покажем,  что
тогда выполнено (3). Предположим, что это не так.
   Пусть А 7" 0{х│х 7е 0Х, S(x)  1ложно 0}. Если S(x) не справедливо для всех х
в Х,  то А - непустое подмножество Х. Т.к. X вполне упорядочено, то
известно, что А содержит наименьший элемент а 40 0. По определению, это
наименьший элемент Х, для которого S(x) не справедливо. Таким обра-
зом,  S(y) справедливо для всех у (если они есть),  удовлетворяющих
условию у<а 40 0. Если а 40 0 - наименьший элемент в Х, то S(a 40 0) справедли-
во,  что следует из первого положения.  В противном случае из спра-
ведливости  S(y)  для  всех у<а 40 0 и второго положения вытекает,  что
S(а 40 0) справедливо.  Но это противоречит предположению, состоящему в
том, что а 40 0 принадлежит А и S(а 40 0) ложно. Единственный способ устра-
нить это противоречие - считать А пустым множеством,  т.е.  в Х нет
элементов, для которых высказывание S(x) ложно.
    2(2)  0Пусть выполнено (3), покажем выполнение (2).
   Условие индуктивности применим к высказываниям S(x) (x 7е 0Х): "вся-
кая строго убывающая цепочка элементов из S,  начинающая с элемента
x, конечна". Высказывание S(x) справедливо для всякого минимального
элемента x 40 7е 0Х,  т.к. любая строго убывающая цепочка указанного вида
состоит  из одного элемента x 40 0.
   Пусть x - не минимальный элемент в Х,  а для всех у<x (у 7е 0Х) выс-
казывания S(у) справедливы. Тогда для произвольной строго убывающей
цепочки x>a 42 0>a 43 0>...,  ввиду справедливости S(a 42 0), получаем, что це-
почка a 42 0>a 43 0>...  конечна, а потому конечна и вся цепочка, т.е. выс-
казывание S(x) справедливо.
   Согласно (3), высказывания S(x) справедливы для всех x 7е 0Х.
    2(3)  0Пусть выполнено (2), покажем, что выполнено и (1).
   Предположим противное,  т.е.  некоторое  непустое подмножество A
множества Х не имеет минимальных элементов. Тогда для произвольного
a 41 7е 0A существует a 42 7е 0A, такой, что a 41 0>a 42 0, и т.к. a 42 0 - не минимальный,
то существует a 43 7е 0A, такой что a 41 0>a 42 0>a 43 0 и т.д. Этот процесс бесконе-
чен, т.к. ни один элемент из A по предположению не минимальный.
   Но тогда построена бесконечная цепочка a 41 0>a 42 0>a 43 0..., что противо-
речит (2).
    1Теорема доказана.
    2Определение 0.
 ш1.1
    2(1) 0 [Верещагин,Шень,2002,с.62]  _ 1Фундированными множествами . 0 (англ.
 1well-founded  set 0) называются множества,  удовлетворяющие свойствам
(1)-(3) предыдущей Теоремы.
    2(2) 0 Частично упорядоченное множество S называется  _ 1фундированным . 0,
если любое его непустое подмножество имеет минимальный элемент.

 ш1.2
   Последняя Теорема  показывает,  что  понятие " 1фундированное мно-
 1жество 0" эквивалентно понятию частично  упорядоченного  множества  с
условием обрыва убывающих цепочек.
    2Примеры 0 ( 1фундированных множеств 0)
           (по [Верещагин,Шень,2002,с.62-64]).
 ш1.1
    21. 0 Множество  натуральных чисел  ═N 0 со стандартным упорядочением  7,
является фундированным множеством.
    22. 0 Множество  ═N 7& ═N 0 пар натуральных чисел (меньше та пара,  у кото-
рой второй член меньше; в случае равенства сравниваем первые).
    23. 0 Множество  ═N 7& ═N 7& 0... 7& ═N 0, где  ═N 0 встречается k раз.
    24. 0 Множество всех слов русского алфавита (точнее,  всех конечных
последовательностей русских букв, независимо от смысла) с  1лексиког-
 1рафическим порядком 0.
    _ 1Лексикографический порядок . 0 соджержательно  определим  так:  если
слово x является началом слова y, то x 7, 0y (например, кант 7, 0кантор).
   Если же ни одно из слов не является началом  другого,  посмотрим
на первую по порядку букву,  в которой слова отличаются:  то слово,
где эта буква меньше в алфавитном порядке и будет меньше.

 ш1.2
    2Определение 0 (по [Верещагин,Шень,2002,с.64]).
 ш1.1
    _ 1Вполне упорядоченными множествами . 0 называются множества,  которые
являются:
   (а) фундированными;
   (б) линейно упорядоченными.
 ш1.2

                   3Принцип трансфинитной индукции

 ш1.0
            1Индукция - это познаваемость идеальных конструкций с по-
            1мощью изучения реально доступных стандартных объектов. 0
                                                            1Н.Гудмен
 ш1.2

   Метод математической индукции применяется для доказательства ут-
верждений о индуктивно заданных множествах.  При этом способ индук-
тивного задания множества подсказывает,  какой разновидностью мате-
матической индукции можно воспользоваться.
   Ответим вначале на следующий естественный вопрос: для каких час-
тично упорядоченных множеств имеет место  утверждение,  аналогичное
принципу полной математической индукции?
    2Определение 0 (по [Математический,1995]).
 ш1.1
    _ 1Трансфинитная индукция . 0 - это способ математических доказательств
(называемый   1принципом трансфинитной индукции 0),  обобщающий принцип
математической индукции на произвольные  1вполне  упорядоченные  мно-
 1жества 0.

 ш1.2
   Фактически для доказательства правильности индуктивных определе-
ний всегда применяется  _ 1трансфинитная индукция . 3  0(либо её частные слу-
чаи: натуральная или полная индукция) (англ.  1transfinite induction 0).
    2Теорема  0( 1принцип трансфинитной индукции 0).
 ш1.1
    2(1)  0Пусть  S(x)  -  некоторое высказывание об элементе x 7е 0Х,  Х -
 1вполне упорядоченное множество 0, и доказаны следующие утверждения:
   (а) S(x 40 0), где x 40 0 - наименьший элемент в Х;
   (б) для  всех х 7е 0Х,  для которых x>x 40 0,  если справедливо S(y) для
всех у<х, то справедливо и S(x).
   Тогда имеет место S(x) для всех х 7е 0Х.
    2(2) 0 Пусть  A  -  фундированное множество и B - подмножество мно-
жества A.  Если для любого  7aе 0A из того, что  7bе 0B для всех  7b 0< 7a 0 следу-
ет, что  7aе 0B, то A=B.
   Заметим, что по определению  7b 0< 7g 0, если  7b 0<= 7g 0 и  7b-g 0.
    2(2) 0 [Математический,1995,с.586]  Если  некоторое   предположение
верно для первого элемента  1вполне упорядоченного множества 0 X и если
из того, что оно верно для всех элементов множества X, предшествую-
щих данному элементу x из множества X, следует его справедливость и
для элемента x,  то это предположение верно  для  каждого  элемента
множества X.

 ш1.2
    2Примеры 0 ( 1трансфинитной индукции 0) 2  0(по [Математический,1995]).
 ш1.1
    21. 0 Принцип  математической  индукции  является  частным  случаем
принципа трансфинитной индукции, если положить A= ═N 0.
    22. 0  1Полная индукция 0 на множестве  ═N 0.
    23.  0Индукция по параметру,  который пробегает множество всех слов
в данном алфавите, упорядоченных лексикографически.
    24.  0Индукция по построению формул в логико-математическом языке.

 ш1.2
   Отметим также,  что в случае индуктивных определений функций или
предикатов,  имеющих  два или более аргументов,  обычно оказывается
полезным использование  _ 1лексикографического порядка . 0 в качестве впол-
не упорядочивающего бинарного отношения.
    3Замечание 0.
 ш1.1
    1Программисты 0 часто  называют  трансфинитную индукцию  _ 1структурной
 _ 1индукцией . 0 (видимо,  это связано с тем,  что индукция осуществляется
обычно "по структуре данных", обрабатываемой программой).

 ш1.2
                   3Рекурсивные определения функций
    2МетаОпределение 0  22  0(по [Марков,Нагорный,1996,с.43-44]).
 ш1.1
    _ 1Рекурсивными определениями . 0 ( 1в математике 0) называются индуктивные
определения операций и предикатов.

 ш1.2
    2Определение 0 (по [Верещагин,Шень,2002,с.66]).
 ш1.1
   Если линейно упорядоченное множество A разбито на две (непересе-
кающиеся) части B и C, причём любой элемент B меньше любого элемен-
та C, то B называют  _ 1начальным отрезком множества . A 0.
   Другими словами, подмножество B линейно упорядоченного множества
A является начальным отрезком,  если любой элемент B меньше  любого
элемента A\B.
   Ещё одна переформулировка: B 7с 0A является начальным отрезком, если
из a,b 7е 0A, b 7е 0B и a 7, 0b следует a 7е 0B.

 ш1.2
   В частности,  начальным отрезком вполне упорядоченного множества
A является множество элементов A, меньших x (обозначается: [0,x)).
   Пусть A  - вполне упорядоченное множество.  Мы хотим дать рекур-
сивное определение некоторой функции f:A─ 76 0B, где B - некоторое мно-
жество. Такое определение должно связывать значение f(x) на некото-
ром элементе x 7е 0A со значениями f(y) при всех y<x.
   Другими словами,  рекурсивное определение задаёт f(x), предпола-
гая известным ограничение функции f на начальный отрезок [0,x).
   Вот точная формулировка.
    2Теорема 0 (по [Верещагин,Шень,2002,с.70]).
 ш1.1
   Пусть A  -  вполне  упорядоченное множество,  а B - произвольное
множество.  Пусть имеется некоторое  _ 1рекурсивное правило . 0, т.е. отоб-
ражение   1F 0,  которое  ставит  в соответствие элементу x 7е 0A и функции
g:[0,x)─ 76 0B некоторый элемент множества B.
   Обозначим f│ 4[0,x) 0  -  ограничение функции f на начальный отрезок
[0,x) - мы отбрасываем все значения функции на  элементах,  больших
или равных x.
   Тогда существует единственная функция f:A─ 76 0B, для которой
 ш1.0

          7( 0          7)
   f(x)= 1F 72 0x,f│ 4[0,x) 72
          79 0          70

при всех x 7е 0A.

 ш1.2
    2Определение 0 (по [Энциклопедия,1951,с.146]).
 ш1.1
    _ 1Индуктивным определением . 0 (или  _ 1построением . 0)  _ 1функции . 0 f(a) на  мно-
жестве натуральных  чисел  называется  её  определение по следующим
двум свойствам:
   (1) задано значение функции f(0)=x 40 0 для числа 0;
   (2) значение функции f(a) для натурального числа a>0  однозначно
выражено через её значения f(b) для натуральных чисел b<a при помо-
щи данных рекурсивных правил.

 ш1.2
    2Теорема 0 ( 1о законности индуктивного определения 0)
           (по [Энциклопедия,1951,с.146]).
 ш1.1
   При заданных рекурсивных правилах существует одна и только  одна
функция f(a),  заданная на множестве всех натуральных чисел и обла-
дающая свойствами (1) и (2), указанными в предыдущем определении.
 ш1.2

                   3Язык структурированных программ

 ш1.0
                      1Сначала пишите программу на простом псевдоязы-
                      1ке, затем переводите её на используемый язык. 0
                                               1Б.Керниган, Ф.Плоджер
 ш1.2

   Иногда мы будем записывать  индуктивные  определения  функций  и
предикатов на упрощённом языке программирования,  который будем на-
зывать  _ 1языком структурированных программ . 0.  Каждая структурированная
программа  предназначена  для вычисления значения некоторой функции
y= 1F 0(x 41 0,...,x 4n 0) для заданных значений аргументов x 41 0,...,x 4n 0.
    _ 1Структурированные программы . 0  состоят из последовательности опре-
делений функций, каждое из которых имеет следующий вид:
 ш1.1

    1F 0(x 41 0,...,x 4n 0) 7" 0IF < 1Предикат_1 0>
                  THEN < 1Терм_1 0>
                  ELSE IF < 1Предикат_2 0>
                         THEN < 1Терм_2 0>
                         ...
                         ELSE IF < 1Предикат_m 0>
                                THEN < 1Терм_m 0>
                                ELSE OTHERWISE < 1Терм_ 0( 1m+1 0)>

 ш1.2
   Для каждой структурированной программы  необходимо  ещё  указать
 _ 1тип функции . 0, т.е. её область определения и множество значений.
   Опишем содержательную операционную  семантику  структурированной
программы.
    2Определение 0.
 ш1.1
   Сначала вычисляется значение предиката < 1Предиката_1 0>.  Если пре-
дикат истинен,  то значением  функции   1F 0  является  значение  терма
< 1Терм_1 0>.  Если значение предиката ложно, то переходим к рассмотре-
нию предиката < 1Предикат_2 0>.  Процесс идет таким образом до тех пор,
пока не будет обнаружен первый из предикатов, который истинен.
   Если ни один из предикатов не окажется  истинным,  то  значением
функции является значение терма < 1Терм_ 0( 1m+1 0)>.

 ш1.2
   Введём  _ 1рекурсию . 0 в язык структурированных программ следующим  об-
разом: функция  1F 0, определяемая в структурированной программе, может
входить как часть в любое из выражений (термов)  или  предикатов  в
программе.  Такое появление  1F 0 является фактически рекурсивным обра-
щением к этой же функции.
   Выполнение программы заключается в  её  применении  к  некоторым
конкретным данным из области определения.
    2Пример 0.
 ш1.1
   Рассмотрим структурированную программу,  предназначенную для вы-
числения значений  _ 1функции Аккермана . 0 с типом  1A 0: ═N 7& ═N 0─ 76 ═N 0:
 ш1.0

    1A 0(x 41 0,x 42 0) 7" 0IF x 41 0=0
              THEN x 42 0+1
              ELSE IF x 42 0=0
                     THEN  1A 0(x 41 0-1,1)
                     ELSE OTHERWISE  1A 0(x 41 0-1, 1A 0(x 41 0,x 42 0-1)).

 ш1.1
   Вычислим значение функции  1A 0(1,2),  пользуясь описанной  содержа-
тельной операционной семантикой:
 ш1.0

    1A 0(1,2) 7" 1A 0(0, 1A 0(1,1)) 7" 1A 0(0, 1A 0(0, 1A 0(1,0))) 7" 1A 0(0, 1A 0(0, 1A 0(0,1))) 7"
          7" 1A 0(0, 1A 0(0,2)) 7" 1A 0(0,3) 7" 04.

   Приведём также индуктивное определение на языке LISP:

   (DEFUN Akkerman (LAMBDA (m n)
      (COND ( (EQ m 0) (+ n 1) )
            ( (EQ n 0) (Akkerman (- m 1) 1) )
            (  T  (Akkerman (- m 1) (Akkerman m (- n 1))) ))
   ))
 ш1.2

          3Синтез программ на языке функционального 0  3програм-
                3мирования 0  3из индуктивных определений

 ш1.0
              1... для натурального числа n
                    7(
                    72 0( 1x 52 0) 5n/2 1, если n чётно,
                 1x 5n 1= 7*
                    72 0  1x 0( 1x 52 0) 5n/2 1, если n нечётно.
                    79
              1Он приводит к алгоритмам двух типов. Первый, получаемый
              1без вычислений из вышеприведённого определения, являет-
              1ся рекурсивным алгоритмом и не требует никакого обосно-
              1вания,  поскольку он - результат непосредственного при-
              1менения безупречного определения.  Второй является ите-
              1ративным алгоритмом, который требует доказательства. 0
                                                    1П.Ноден, К.Китте
 ш1.2

   Нетрудно видеть,  что язык структурированных программ  изоморфен
по  структуре языку функционального программирования LISP,  поэтому
появляется возможность  1осуществлять синтез программ на классическом
 1языке  функционального  программирования LISP из содержательных ин-
 1дуктивных определений 0,  пользуясь (если это,  конечно,  необходимо)
языком структурированных программ, как промежуточным (методическим)
языком представления.
   Теперь у нас появляются следующие возможности:
 ш1.1
   (1) после  доказательства  правильности индуктивного определения
функции или предиката можно  _ 1сразу предъявить . 0  ( 1синтезировать 0)   _ 1пра-
 _ 1вильную программу на языке функционального программирования . 0;
   (2) используя язык функционального программирования,  можно тес-
тировать содержательные индуктивные определения (правильность кото-
рых ещё не доказана) на предмет обнаружения ошибок;
   (3) если  каким-то  образом  доказана  правильность программы на
языке функционального программирования,  то тем самым можно утверж-
дать  о правильности соответствующих содержательных индуктивных оп-
ределений функций или предикатов.

 ш1.2
                    3Базовые 0  3операции над словами
                             3в алфавите
   Вспомним следующие обозначения:
 1   0ш1.1
   (1)  7A 0 - алфавит,  7A 5+ 0 - множество всех непустых слов в алфавите  7A 0,
 7A 5* 0 - множество всех слов в алфавите  7A 0, включая  7L 0;
   (2) a 7еA 0,  7aеA 5* 0;
   (3)  77 0: 7A&A 5* 0─ 76A 5* 0 - операция левого присоединения буквы из  7A 0 к сло-
ву в  7A 0.

 1   0ш1.2
    2Определение 0.
 ш1.1
    2(1) 0  _ 1Головой слова из . 0  1A 5+ 0 назовём отображение  1Head 0: 7A 5+ 0─ 76A 0, если
 ш1.0

    1Head 0(a 77a 0) 7" 0a.

    2(2) 0  _ 1Хвостом слова из . 0  1A 5+ 0 назовём отображение  1Tail 0: 7A 5+ 0─ 76A 5* 0, если

    1Tail 0(a 77a 0) 7"a 0.
 ш1.2

             2ПРИМЕРЫ РЕШЕНИЯ НЕКОТОРЫХ ТИПОВ УПРАЖНЕНИЙ

 ш1.0
                                 1Почему я пишу такие короткие фразы?
                                 1Потому что мне не хватает слов. 0
                                          1Е.Лец. Непричёсанные мысли
 ш1.2

    2Пример 1. 0  Напишите  индуктивное  определение функции  1len 0: 7A 5* 0─ 76 ═N 0,
позволяющей найти длину слова в алфавите  7A 0.
    _ 1Решение . 0. Вначале выскажем гипотезу об индуктивном определении:
    1len 0: 7A 5* 0─ 76 ═N 0 и
 ш1.0

           7(
           72 00, если  7a 0= 7L 0;
    1len 0( 7a 0) 7"* 0      7( 0        7)
           72 01+ 1len 72 1Tail 0( 7a 0) 72 0, если  7a-L 0.
           79 0      79 0        70

 ш1.2
   Разумеется, для подтверждения гипотезы необходимо привести дока-
зательство.
    2Предложение 0.
 ш1.1
   Функция  1len 0: 7A 5* 0─ 76 ═N 0, определённая следующим индуктивным образом:
 ш1.0

           7( 00, если  7a 0= 7L 0;
    1len 0( 7a 0) 7"* 0    7( 0        7)
           79 1len 72 1Tail 0( 7a 0) 72 0+1, если  7a-L 0,
               79 0        70

определяет длину слова  7a 0.

 ш1.2
    2Доказательство 0. Воспользуемся  полной  индукцией  по  количеству
букв в слове.
   Очевидно, что  1len 0( 7L 0)=0 ( _ 1база индукции . 0),  т.к. пустое слово - это
слово, не содержащее букв.
   Докажем, что если функция правильно вычисляет  длину  слова   7a 0',
имеющего на одну букву меньше, чем слово  7a 0, то функция  1len 0 правиль-
но вычисляет длину слова  7a 0. Пусть  1len 0( 7a 0')=n ( _ 1гипотеза индукции . 0).
   Докажем, что  1len 0( 7a 0)=n+1. Т.к. n+1 7. 01, то  7a-L 0. Следовательно,
 ш1.0

    1len 0( 7a 0)= 1len 0( 1Tail 0( 7a 0))+1.

 ш1.2
   Известно, что функции  1Head 0( 7a 0) и  1Tail 0( 7a 0)  определены,  т.к.   7a-L 0,
однако  1Tail 0( 7a 0) содержит все буквы слова  7a 0, кроме первой. Поэтому по
гипотезе индукции можно предполагать, что  1len 0( 1Tail 0( 7a 0))=n.
   Таким образом,  добавив одну букву ( 1Head 0( 7a 0)) к слову  1Tail 0( 7a 0), мы
получим исходное слово  7a 0, причём  1len 0( 7a 0)=n+1.
    1Предложение доказано.
   Теперь мы можем  _ 1синтезировать программу на языке функционального
 _ 1программирования . LISP  _из индуктивного определения . 0. Другими словами,
теперь можем записать индуктивное определение на языке LISP:
 ш1.0

   (DEFUN Len (LAMBDA (LST)
     (COND ( 1  0(NULL LST) 0 1  0)
           (  1  0T 1  0 (+ 1 (Len (CDR LST))) 1  0))))

 ш1.2
   Мы можем также синтезировать программу на  языке  продукционного
программирования Рефал из индуктивного определения.  Другими слова-
ми,  можем записать индуктивное определение следующим образом:
 ш1.0

   $use STDIO;
   $use ARITHM;
   $func Len e = s;
   Main {
           = <Print "Введите слово: ">,
             <PrintLn "Количество букв в слове: "
                      <Len <Read-Line>>>;
        };
   Len  {
           e1 s2 e3 = <"+" 1 <Len e3>>;
           e1       = 0;
        };
 ш1.2

    2Пример 2. 0  Напишите индуктивное определение функции   1Last 0: 7A 5+ 0─ 76A 0,
позволяющей найти последнюю букву слова в алфавите  7A 0.
    _ 1Решение . 0. Вначале выскажем гипотезу об индуктивном определении:
 ш1.0

            7( 1Head 0( 7a 0), если  1Tail 0( 7a 0)= 7L 0;
    1Last 0( 7a 0) 7"*
            79 1Last 0( 1Tail 0( 7a 0)), если  1Tail 0( 7a 0) 7-L 0.

 ш1.2
   Разумеется, для подтверждения гипотезы необходимо привести дока-
зательство.
    2Предложение 0.
 ш1.1
   Построенное индуктивное определение правильно.

 ш1.2
    2Доказательство 0. Воспользуемся  _ 1индукцией по длине слова . 0  7a 0.
   Пусть  1len 0( 7a 0)=1. Тогда по базисному пункту индуктивного определе-
ния значение  1Last 0( 7a 0) совпадает с  7a 0, т.е. с единственной буквой.
   Пусть для всех слов, длина которых меньше некоторого натурально-
го n>1, построенное индуктивное определение правильно.
   Рассмотрим слово a 77a 0, длина которого равна n. Тогда из индуктив-
ного  определения  1Last 0(a 77a 0) 7" 1Last 0( 7a 0),  а по сделанному предположению
 1Last 0( 7a 0) возвращает последнюю букву слова  7a 0.
    1Предложение доказано.
   Теперь мы можем  _ 1синтезировать программу на языке функционального
 _ 1программирования . LISP  _из индуктивного определения . 0. Другими словами,
можем записать индуктивное определение на языке LISP:
 ш1.0

   (DEFUN Last (LAMBDA (LST)
     (COND ( 1  0(NULL (CDR LST)) (CAR LST) 1  0)
           (  1  0T 1  0 (Last (CDR LST)) 1  0))))

   Запись индуктивного определения на языке программирования Рефал:

   $use STDIO;
   $func Last e = e;
   Main {
           = <Print "Введите слово: ">,<Read-Line>::e1,
             <PrintLn <Last e1>>;
        };
   Last {
           s1    = s1;
           s1 e2 = <Last e2>;
        };
 ш1.2

    2Пример 3. 0 Напишите индуктивное определение предиката
 ш1.0

   =: 7A 5* 7&A 5* 0─ 76B 42 0,

 ш1.2
устанавливающего равенство двух заданных слов  7a 0, 7bеA 5* 0.
    _ 1Решение . 0. Вначале выскажем гипотезу об индуктивном определении:
 ш1.0

        7( 2И 0, если  7a 0= 7L 0& 7b 0= 7L 0;
       │
    7a 0= 7b"* 1Head 0( 7a 0)= 1Head 0( 7b 0)& 1Tail 0( 7a 0)= 1Tail 0( 7b 0), если  7a-L 0& 7b-L 0;
       │
        79 2Л 0, если ( 7a-L 0& 7b 0= 7L 0) 7v 0( 7a 0= 7L 0& 7b-L 0).

 ш1.2
   Разумеется, для подтверждения гипотезы необходимо привести дока-
зательство.
   Теперь мы можем  _ 1синтезировать программу на языке функционального
 _ 1программирования . LISP  _из индуктивного определения . 0. Другими словами,
можем записать индуктивное определение на языке LISP:
 ш1.0

   (DEFUN = (LAMBDA (LST1 LST2)
     (COND ( 1  0(AND (NULL LST1) (NULL LST2)) T 1  0)
           ( 1  0(AND (NOT (NULL LST1)) (NOT (NULL LST2)))
                    (AND (EQ (CAR LST1) (CAR LST2))
                         (= (CDR LST1) (CDR LST2))) )
           (  1  0T NIL 1  0))))

   Запись индуктивного определения на языке программирования Рефал:

   $use STDIO;
   $func Rav e (e) = e;
   Main {
          = <Print "Введите два слова: ">,<Read-Line>::e1,
            <Read-Line>::e2,<PrintLn <Rav e1 (e2)>>;
        };
   Rav  {
           ()            = <Print "Слова равны.">;
           s1 e2 (s1 e3) = <Rav e2 (e3)>;
              e2 (e3)    = <Print "Слова не равны.">;
           e1 ()         = <Print "Слова не равны.">;
              (e1)       = <Print "Слова не равны.">;
        };
 ш1.2

    2Пример 4. 0 Напишите индуктивное определение алгебраической опера-
ции ∙: 7A 5* 7&A 5* 0─ 76A 5* 0, позволяющей приписать слово  7bеA 5* 0 к слову  7aеA 5* 0.
    _ 1Решение . 0. Пусть  a 77a 0 обозначает результат операции левого присое-
динения буквы a 7еA 0 к слову  7a 0.  Тогда можно высказать гипотезу об ин-
дуктивном определении:
 ш1.0

        7(b 1, 7  0если  7a 0= 7L 0;
    7a 0∙ 7b"* 0         7( 0          7)
        79 1Head 0( 7a 0) 772 1Tail 0( 7a 0)∙ 7b2 1, 0 если  7a-L 0.
                 79 0          70

 ш1.2
   Разумеется, для подтверждения гипотезы необходимо привести дока-
зательство.
    2Предложение 0.
 ш1.1
   Построенное индуктивное определение правильно.

 ш1.2
    2Доказательство 0. Воспользуемся  _ 1индукцией по длине слова . 0  7a 0.
   Пусть  1len 0( 7a 0)=0. Тогда по базисному пункту индуктивного определе-
ния значение  7a 0∙ 7b 0 совпадает с  7b 0.
   Пусть для всех слов, длина которых меньше некоторого натурально-
го n>0, построенное индуктивное определение правильно.
   Рассмотрим слово a 77a 0, длина которого равна n. Тогда из индуктив-
ного определения
 ш1.0

    7a 0∙ 7b 0=(a 77a 41 0)∙ 7b" 0a 77 0( 7a 41 0∙ 7b 0),

 ш1.2
а по  сделанному предположению  7a 41 0∙ 7b 0 возвращает конкатенацию слов  7a 41
и  7b 0. Остаётся не забыть приписать вначале букву a и получить конка-
тенацию слов  7a 0 и  7b 0.
    1Предложение доказано.
   Теперь мы можем  _ 1синтезировать программу на языке функционального
 _ 1программирования . LISP  _из индуктивного определения . 0. Другими словами,
можем записать индуктивное определение на языке LISP:
 ш1.0

   (DEFUN ConCat (LAMBDA (LST1 LST2)
      (COND ( 1  0(NULL LST1) LST2)
            ( 1  0 T 1  0 (CONS (CAR LST1) (ConCat (CDR LST1) LST2)) 1  0))
   ))

   Запись индуктивного определения на языке программирования Рефал:

   $use STDIO;
   $func ConCat e (e) = e;
   Main   {
             = <Print "Введите два слова: ">,<Read-Line>::e1,
               <Read-Line>::e2,<PrintLn <ConCat e1 (e2)>>;
          };
   ConCat {
              (e1)       = e1;
              s1 e2 (e3) = s1 <ConCat e2 (e3)>;
          };
 ш1.2

    2Пример 5. 0 Напишите индуктивное определение функции
 ш1.0

    1Reverse 0: 7A 5* 0─ 76A 5* 0,

 ш1.2
позволяющей осуществить обращение слова  7aеA 5* 0.
    _ 1Решение . 0. Вначале выскажем гипотезу об индуктивном определении:
 ш1.0

               7(
               72L 0, если  7a 0= 7L 0,
    1Reverse 0( 7a 0) 7"* 0        7( 0        7)
               72 1Reverse 72 1Tail 0( 7a 0) 727 1Head 0( 7a 0), если  7a-L 0.
               79 0        79 0        70

 ш1.2
   Разумеется, для подтверждения гипотезы необходимо привести дока-
зательство.
   Теперь мы можем  _ 1синтезировать программу на языке функционального
 _ 1программирования . LISP  _из индуктивного определения . 0. Другими словами,
можем записать индуктивное определение на языке LISP с  использова-
нием встроенных функций APPEND и LIST:
 ш1.0

   (DEFUN Reverse1 (LAMBDA (LST)
     (COND ( 1  0(NULL LST) NIL 1  0)
           (  1  0T 1  0 (APPEND (Reverse1 (CDR LST)) (LIST (CAR LST))) 1  0))
   ))

 ш1.2
   Запись индуктивного  определения  на языке программирования LISP
без использования встроенных функций APPEND и LIST такова:
 ш1.0

   (DEFUN Reverse1 (LAMBDA (LST)
     (COND ( 1  0(NULL LST) NIL 1  0)
           (  1  0T 1  0 (ConCat (Reverse1 (CDR LST))
                         (CONS (CAR LST) NIL)) 1  0))))
   ; ----------------------------------------------
   (DEFUN ConCat (LAMBDA (LST1 LST2)
     (COND ( 1  0(NULL LST1) LST2 1  0)
           (  1  0T 1  0 (CONS (CAR LST1) (ConCat (CDR LST1) LST2)) 1  0))))

   Запись индуктивного определения на языке программирования Рефал:

   $use STDIO;
   $func Reverse1 e = e;
   Main     {
              = <Print "Введите слово: ">,<READ-LINE>::e1,
                <PrintLn <Reverse1 e1>>;
            };
   /* ----- */
   Reverse1 {
               s.X e.Rest = <Reverse1 e.Rest> s.X;
                          = ;
            };
 ш1.2

    2Пример 6. 0 Определите семантику и докажите правильность индуктив-
ного определения следующей функции:
 ш1.0

                         7( 01, если n=1;
    1F 0: ═N 0\{0}─ 76 ═N 0\{0},  1F 0(n) 7"*
                         79 0n+ 1F 0(n-1), если n>1.

 ш1.2
    _ 1Решение . 0.
    2Предложение 0.
 ш1.1
   Определение описывает функцию,  вычисляющую сумму n первых нату-
ральных чисел; другими словами,
 ш1.0

    1F 0(n)=n+(n-1)+ 7777 0+1=n(n+1)/2.

 ш1.2
    2Доказательство 0. Воспользуемся натуральной индукцией.
 ш1.0

    1F 0(1)=1 ( _ 1база индукции . 0).

 ш1.2
   Предположим, что  функция правильно вычисляет сумму n первых по-
ложительных целых чисел для каждого из чисел 1,2,...n.
   Докажем (для любого положительного числа n), что если справедли-
во равенство  1F 0(n)=n 77 0(n+1)/2 ( _ 1предположение индукции . 0), то
 ш1.0

    1F 0(n+1)=(n+1)+n+(n-1)+...+1=(n+1) 77 0((n+1)+1)/2.

   Так как n - положительное число, то n+1>1 и

    1F 0(n)  7" 0 n+ 1F 0(n-1)  7" 0 n+(n-1) 77 0n/2=(2n+n 52 0-n)/2=n(n+1)/2.

 ш1.2
    1Предложение доказано.
   Попутно доказана правильность следующей функции,  написанной  на
языке функционального программирования LISP:
 ш1.0

   (DEFUN F (LAMBDA (N)
       (COND ( 1  0(EQ N 1) 1 1  0)
             ( 1  0 T 1  0 (+ N (F (- N 1))) 1  0))
   ))
 ш1.2

    2Пример 7. 0  Рассмотрим следующее рекурсивное определение числовой
функции (эту функцию привёл в качестве примера Дж.Маккарти, и обыч-
но её называют  _ 1функцией .-91 0  _ 1Маккарти . 0), n 7е 0Z:
 ш1.0

         7( 0n-10, если n>100;
    1F 0(n) 7"*
         79 1F 0( 1F 0(n+11)), если n 7, 0100.

   Докажите, что

         7( 0n-10, если n>100;
    1F 0(n)= 7*
         79 091, если n 7, 0100.

 ш1.2
    _ 1Решение . 0. Базисный пункт  индуктивного  определения  относится  к
значениям аргумента n>100, поэтому рассмотрим множество
 ш1.0

   M 7" 0{n│n 7е 0Z&n 7, 0100}

 ш1.2
и определяем  отношение вполне упорядоченности <' на этом множестве
следующим образом:  n 41 0<'n 42 0,  если и только если n 41 0>n 42 0, где > - знак
бинарного отношения " 1больше 0" для целых чисел.
   На множестве, упорядоченном указанным образом, с помощью  _ 1принци-
 _ 1па трансфинитной индукции . 0 докажем, что
 ш1.0

         7( 0n-10, если n>100;
    1F 0(n)= 7*
         79 091, если n 7, 0100.

 ш1.2
   Очевидно, что если n>100, то  1F 0(n)=n-10.
   Таким образом, остаётся показать, что  1F 0(n)=91 при n 7, 0100.
   При использовании  принципа  трансфинитной индукции,  необходимо
доказать, что:
 ш1.1
   (1)  1F 0(n)=91 для наименьшего элемента множества 1  0M. При упорядоче-
нии, задаваемом <', наименьшим элементом будет 100. В самом деле:
 ш1.0

    1F 0(100)= 1F 0( 1F 0(100+11))= 1F 0( 1F 0(111))= 1F 0(101)=91;

 ш1.1
   (2) если 100<'n и  1F 0(n')=91 для всех n'<'n (другими словами,  для
n<n' 7, 0100) ( _ 1предположение индукции . 0), то F(n)=91.

 ш1.2
   Так как n<100, то мы должны иметь
 ш1.0

    1F 0(n)= 1F 0( 1F 0(n+11)).

 ш1.2
   Если (n+11) 7е 0M, то n+11<'n (другими словами, n<n+11 7, 0100).
   Теперь воспользуемся индуктивным определением и заключаем, что
 ш1.0

    1F 0(n)= 1F 0( 1F 0(n+11))= 1F 0(91).

 ш1.2
   Если (n+11) 7е 0M,  то  n+11 7, 0100,  или n 7, 089,  но в этом случае 91<'n
(т.е. n<91), и опять можно воспользоваться предположением индукции:
 ш1.0

    1F 0(n)= 1F 0( 1F 0(n+11))= 1F 0(91)=91.

 ш1.2
   Если (n+11) 7Е 0M,  то предположением индукции  для   1F 0( 1F 0(n+11))  уже
пользоваться нельзя.  Однако, в этом случае известно, что n+11>100,
и поэтому имеем
 ш1.0

    1F 0(n)= 1F 0( 1F 0(n+11))= 1F 0(n+11-10)= 1F 0(n+1).

 ш1.2
   Теперь (n+1) 7е 0M,  ибо n<100, и, следовательно, n+1 7, 0100. Кроме то-
го, n+1<'n (другими словами,  n<n+1 7, 0100), и, применяя предположение
индукции, получаем
 ш1.0

    1F 0(n)= 1F 0( 1F 0(n+11))= 1F 0((n+11)-10)= 1F 0(n+1)=91,

 ш1.2
т.е.  1F 0(n)=91 при n 7, 0100.

    2Пример 8. 0  Рассмотрим рекурсивное определение,  задающее  _ 1функцию
 _ 1Аккермана . 0:
 ш1.0

    1A 0(x 41 0,x 42 0) 7" 0IF x 41 0=0
              THEN x 42 0+1
              ELSE IF x 42 0=0
                     THEN  1A 0(x 41 0-1,1)
                     ELSE  1A 0(x 41 0-1,A(x 41 0,x 42 0-1)),

где х 41 0 и х 42 0 - неотрицательные целые числа.

 ш1.2
   Докажите, что  вычисление  значения  функции  1А 0 заканчивается для
всех пар неотрицательных целых чисел (x 41 0,x 42 0).
    _ 1Решение . 0. При первом рекурсивном обращении к  1А 0 уменьшается первый
аргумент, а при втором рекурсивном обращении уменьшается первый ар-
гумент  внешнего обращения и,  кроме того,  во внутреннем обращении
уменьшается второй аргумент.  Это наводит на мысль, что имеет смысл
применить   _ 1трансфинитную  индукцию . 0  по  множеству упорядоченных пар
(х 41 0,х 42 0) неотрицательных целых чисел.
   Упорядочение зададим  1лексикографическим порядком 0 <,  который оп-
ределяется следующим образом:
 ш1.0

   (х 41 0',x 42 0')<(x 41 0,x 42 0), если и только если x 41 0'<x 41 0 или x 41 0'=x 41 0&x 42 0'<x 42 0.

 ш1.2
   Докажем с помощью принципа трансфинитной индукции,  что вычисле-
ние  1А 0 для следующих пар неотрицательных чисел x 41 0 и x 42 0  заканчивает-
ся. Для этого необходимо доказать, что:
 ш1.1
   (1)  1А 0(х 41 0,х 42 0)  заканчивается для наименьшего элемента  1вполне упо-
 1рядоченного множества 0.  Но наименьшим элементом является (0,0), и в
этом случае вычисление  1А 0(0,0) заканчивается;
   (2) для всех пар неотрицательных целых чисел (х 41 0,х 42 0)>(0,0): если
вычисление    значения     1А 0(х 41 0',х 42 0')    заканчивается   для   любых
(х 41 0',х 42 0')<(х 41 0,х 42 0), то заканчивается и вычисление значения  1А 0(х 41 0,х 42 0).

 ш1.2
    _ 1Предположение индукции . 0.  Пусть мы имеем некоторую пару (х 41 0,х 42 0) и
знаем,  что  вычисление  значения  1А 0(х 41 0',х 42 0') заканчивается для всех
(х 41 0',х 42 0')<(х 41 0,х 42 0).
   Если х 41 0=0,  то очевидно, что вычисление значения  1А 0(х 41 0,х 42 0) закан-
чивается. Если же х 41 7- 00 и х 42 0=0, то по индуктивному определению
 ш1.0

    1А 0(х 41 0,х 42 0)= 1А 0(х 41 0-1,1).

 ш1.2
   Однако (х 41 0-1,1)<(х 41 0,х 42 0)  и  по предположению индукции вычисление
значения  1А 0(х 41 0-1,1) заканчивается,  а следовательно, заканчивается и
вычисление значения  1А 0(х 41 0,х 42 0).
   Если теперь х 41 7- 00 и х 42 7- 00, то
 ш1.0

    1А 0(х 41 0,х 42 0)= 1А 0(х 41 0-1, 1А 0(x 41 0,х 42 0-1)).

 ш1.2
   На следующем шаге вычислим  1А 0(х 41 0,х 42 0-1),  но (х 41 0,х 42 0-1)<(х 41 0,х 42 0),  и
по предположению индукции вычисление  1А 0(х 41 0,х 42 0-1) должно закончиться.
   После этого требуется вычислить значение  1А 0(х 41 0-1,z),  где z - по-
лученное значение  1А 0(x 41 0,x 42 0-1).
   Каким бы ни было значение z, имеет место
 ш1.0

   (x 41 0-1,z)<(x 41 0,x 42 0).

 ш1.2
   Следовательно, по  предположению индукции заканчивается и вычис-
ление  1А 0(x 41 0-1,z).
   Итак, после вычисления значений  1А 0(х 41 0,х 42 0-1)=z и  1А 0(x 41 0-1,z)  закан-
чивается вычисление значения  1А 0(х 41 0,х 42 0).
   Отметим, что одновременно доказана завершаемость вычисления зна-
чений LISP-функции
 ш1.0

   (DEFUN Akkerman (LAMBDA (M N)
      (COND ( (EQ M 0) (+ N 1) )
            ( (EQ N 0) (Akkerman (- M 1) 1) )
            (   T  (Akkerman (- M 1) (Akkerman M (- N 1))) ))
   ))
 ш1.2

    2Пример 9. 0 Рассмотрим рекурсивное определение функции, применимой
к любому списку слов X и списку слов L:
 ш1.0

    1Member1 0(X,L) 7"
         7" 0IF L=NIL
           THEN FALSE
           ELSE IF X=CAR(L)
                  THEN TRUE
                  ELSE IF ATOM(CAR(L))
                         THEN  1Member1 0(X,CDR(L))
                         ELSE IF  1Member1 0(X,CAR(L))
                                THEN TRUE
                                ELSE OTHERWISE  1Member1 0(X,CDR(L)),

 ш1.2
где TRUE (T - "истина"), FALSE (NIL - "ложь").
   LISP-функция с эквивалентной семантикой такова:
 ш1.0

   (DEFUN Member1 (LAMBDA (X L)
       (COND ( (NULL L) NIL )
             ( (EQ X (CAR L)) T )
             ( (ATOM (CAR L)) (Member1 X (CDR L)) )
             ( (Member1 X (CAR L)) T )
             (  T  (Member1 X (CDR L)) )
       )
   ))
   (RDS)

 ш1.2
   Тестирование программы позволило сформулировать гипотезу, состо-
ящую в том, что  1данная программа является правильной 0.
   Превратите гипотезу в теорему.
    _ 1Решение . 0.
    2Предложение 0.
 ш1.0

                 7( 2И 0, если Х встречается в качестве элемента
    1Member1 0(X,L) 7"* 0  7   0списка L (на следующем уровне);
                 79 2Л 0  в противном случае.

 ш1.2
    2Доказательство 0. Воспользуемся  индукцией  по  общему  числу n(L)
вхождений скобок и атомов в список L.
   Например, если список имеет следующее представление
 ш1.0

   L 7" 0((A B) C ((B A))),

то число скобок и атомов равно n(L)=13, а для списка

   CAR(L)=(A B)

 ш1.2
число скобок и атомов равно n(L)=4.
   Наименьшее из возможных значений общего числа скобок и атомов  в
списках достигается для пустого списка NIL=() и равно 2.
   Пусть n(L)=2. Тогда L=NIL и
 ш1.0

    1Member1 0(X,L)= 1Member1 0(X,NIL)= 2Л 0 ( _ 1база индукции . 0).

 ш1.2
   Докажем для  всех  n>2,  что если значение функции  1Member1 0(X,L')
вычисляется правильно для любого списка L' с общим числом скобок  и
атомов  n'<n+1,  то значение  1Member1 0(X,L) также будет правильно вы-
числяться для списка с общим числом скобок и атомов, равным n+1.
   Предположим, что значение   1Member1 0(X,L')  вычисляется  правильно
для любого списка L' c n'<n+1 ( _ 1предположение индукции . 0),  а L - спи-
сок, содержащий n+1 вхождение скобок и атомов.
   Ясно, что L 7- 0NIL, т.к. n+1>2 при n 7. 02.
   Если X=CAR(L), то  1Member1 0(X,L)= 2И 0, а это верно, ибо Х встречается
в качестве элемента списка L.
   Если Х=CAR(L) и ATOM(CAR(L))= 2И 0, то
 ш1.0

    1Member1 0(X,L)= 1Member1 0(X,CDR(L)).

 ш1.2
   Однако CDR(L) - список,  содержащий n'<n+1  вхождений  скобок  и
атомов.  Поэтому  по  предположению индукции  1Member1 0(X,CDR(L)) пра-
вильно вычисляет значение  2И 0 или  2Л 0 в зависимости от того,  входит  Х
или не входит в число элементов (любого уровня) списка CDR(L).
   Так как X=CAR(L) и ATOM(CAR(L))= 2И 0, то мы знаем, что Х будет вхо-
дить  как  элемент  в L,  если и только если Х входит как элемент в
CDR(L).
   Таким образом,  в зависимости от того,  входит или нет Х в число
элементов L, мы будем получать верное значение.
   Если X=CAR(L) и ATOM(CAR(L))= 2Л 0,  1Member1 0(X,CAR(L))= 2И 0, то
 ш1.0

    1Member1 0(X,L)= 2И 0,

 ш1.2
что опять правильно,  ибо известно, что в этом случае СAR(L) - спи-
сок,  содержащий n'<n+1 скобок и атомов.  Из предположения индукции
можно заключить,  что  значение   1Member1 0(X,CAR(L)) вычисляется пра-
вильно, и если  1Member1 0(X,CAR(L))= 2И 0,  то Х действительно встречается
в качестве элемента в CAR(L), а следовательно, и в L.
   Наконец, если
 ш1.0

   Х 7- 0CAR(L), АТОМ(CAR(L))= 2Л 0,  1Member1 0(X,CAR(L))= 2Л 0, то

    1Member1 0(X,L)= 1Member1 0(X,CDR(L)).

 ш1.2
   Однако, т.к.  CDR(L) - список с n'<n+1 вхождениями скобок и ато-
мов, то из предположения индукции можно заключить, что функция
 ш1.0

    1Member1 0(X,CDR(L))

 ш1.2
правильно вычисляет значения  2И 0 или  2Л 0 в зависимости от того,  входит
Х в число элементов CDR(L)  или  нет.  А  так  как  в  этом  случае
X 7- 0CAR(L) и ATOM(CAR(L))= 2Л 0,   1Member1 0(X,CAR(L))= 2Л 0, то Х будет элемен-
том L, если и только если Х является элементом CDR(L).
   Следовательно, и в этом случае значение
 ш1.0

    1Member1 0(X,L)= 1Member1 0(X,CDR(L)

 ш1.2
будет вычисляться верно.
    1Предложение доказано.

    2Пример 10. 0  Рассмотрим программу, которая применима к любым двум
спискам L 41 0 и L 42 0,  состоящих из целых чисел, расположенных в возрас-
тающем порядке:
 ш1.0

    1IntOrd 0(L 41 0,L 42 0) 7"
     7" 0IF L 41 0=NIL
       THEN L 42
       ELSE IF L 42 0=NIL
              THEN L 41
              ELSE IF CAR(L 41 0)<CAR(L 42 0)
                     THEN CONS(CAR(L 41 0), 1IntOrd 0(CDR(L 41 0),L 42 0)
                     ELSE IF CAR(L 42 0)<CAR(L 41 0)
                            THEN CONS(CAR(L 42 0), 1IntOrd 0(L 41 0,CDR(L 42 0))
                            ELSE OTHERWISE
                            CONS(CAR(L 41 0),
                             CONS(CAR(L 42 0), 1IntOrd 0(CDR(L 41 0),CDR(L 42 0))))

   LISP-функция с эквивалентной семантикой такова:

   (DEFUN INTORD (LAMBDA (L1 L2)
      (COND ( 1  0(NULL L1) L2 1  0)
            ( 1  0(NULL L2) L1 1  0)
            ( 1  0(< (CAR L1) (CAR L2))
                 (CONS (CAR L1) (INTORD (CDR L1) L2)) 1  0)
            ( 1  0(< (CAR L2) (CAR L1))
                 (CONS (CAR L2) (INTORD L1 (CDR L2))) 1  0)
            ( T (CONS (CAR L1)
                      (CONS (CAR L2) (INTORD (CDR L1) (CDR L2))))))
   ))

 ш1.2
   Тестирование программы позволило сформулировать гипотезу, состо-
ящую в том, что  1данная программа является правильной 0.
   Превратите гипотезу в теорему.
    _ 1Решение . 0.
    2Предложение 0.
 ш1.1
   Для любых  двух упорядоченных по возрастанию списков L 41 0 и L 42 0 ре-
зультат вызова функции  1IntOrd 0(L 41 0,L 42 0) представляет собой упорядочен-
ный по возрастанию список элементов, входящих в списки L 41 0 и L 42 0.

 ш1.2
    2Доказательство 0. При рекурсивных обращениях к IntOrd() либо  пер-
вый,  либо второй, либо оба аргумента становятся проще. Поэтому ес-
тественно использовать принцип трансфинитной индукции по парам воз-
можных  длин (Len1,Len2) для списков L 41 0 и L 42 0 лексикографически упо-
рядоченных с помощью "<".
    _ 1Лексикографический порядок . 0 "<" определяется следующим образом:
 ш1.0

   (Len1',Len2')<(Len1,Len2)

 ш1.2
если и только если Len1'<Len1 или Len1'=Len1&Len2'<Len2.
   Докажем для пары упорядоченных списков L 41 0  и  L 42 0  с  наименьшими
длинами,  что функция работает правильно.  Но наименьшие длины есть
(0,0), т.е. L 41 0 и L 42 0 - пустые списки. Следовательно, утверждение
 ш1.0

    1IntOrd 0(NIL,NIL)=NIL

 ш1.2
верно ( _ 1база индукции . 0).
   Докажем для всех пар длин (Len1,Len2)>(0,0),  что если для  всех
списков L 41 0' и L 42 0', таких что
 ш1.0

   (Len1',Len2')<(Len1,Len2),

 ш1.2
правильно работает   1IntOrd 0(L 41 0',L 42 0')  ( _ 1предположение  индукции . 0),  то
правильно работает и  1IntOrd 0(L 41 0,L 42 0) (L 41 0 и  L 42 0  имеют  соответственно
длины Len1 и Len2).
   Предположим, что списки L 41 0 и L 42 0 являются такими,  какие нам тре-
буются,  и предположение индукции верно.  Легко проверить, что если
либо  L 41 0,  либо L 42 0 есть NIL,  то утверждение  1IntOrd 0(L 41 0,L 42 0)=NIL пра-
вильно. Поэтому будем предполагать, что L 41 7- 0NIL и L 42 7- 0NIL.
   Возможен один из трёх случаев:
 ш1.0

   (1) CAR(L 41 0)<CAR(L 42 0); (2) CAR(L 41 0)>CAR(L 42 0); (3) CAR(L 41 0)=CAR(L 42 0).

   Рассмотрим их последовательно.

   (1)  1IntOrd 0(L 41 0,L 42 0)= 1IntOrd 0(CDR(L 41 0),L 42 0).

   Однако длина CDR(L 41 0) меньше длины L 41 0, и, следовательно,

   (Длина CDR(L 41 0),Длина L 42 0)<(LENGHT1,LENGHT2)

 ш1.2
из-за лексикографической упорядоченности.
   Таким образом,  применимо предположение индукции, и, следователь-
но,  1IntOrd 0(CDR(L 41 0),L 42 0) - действительно упорядоченный список всех чи-
сел,  входящих в качестве элементов и в CDR(L 41 0),  и в  L 42 0.  Так  как
CAR(L 41 0)<CDR(L 42 0)  и  списки L 41 0,  L 42 0 упорядочены,  то,  следовательно,
CAR(L 41 0) не входит в список L 42 0.  Отсюда вытекает,  что  упорядоченный
список  всех чисел,  которые являются элементами как CDR(L 41 0),  так и
L 42 0,  совпадает с упорядоченным списком всех чисел,  которые являются
элементами как L 41 0, так и L 42 0.
   Следовательно, в этом случае утверждение
 ш1.0

    1IntOrd 0(L 41 0,L 42 0)= 1IntOrd 0(CDR(L 41 0),L 42 0)

справедливо.

   (2)  1IntOrd 0(L 41 0,L 42 0)= 1IntOrd 0(L 41 0,CDR(L 42 0)).

   Длина CDR(L 42 0) меньше длины L 42 0, и, следовательно,

   (Длина L 41 0,Длина CDR(L 42 0))<(Len1,Len2)

 ш1.2
из-за лексикографического  порядка.  Поэтому  к   1IntOrd 0(L 41 0,CDR(L 42 0))
применимо предположение индукции,  и можно,  используя соображения,
аналогичные для случая (1), заключить, что и в этом случае
 ш1.0

    1IntOrd 0(L 41 0,L 42 0)

"работает" правильно.

   (3)  1IntOrd 0(L 41 0,L 42 0)=CONS(CAR(L 41 0), 1IntOrd 0(CDR(L 41 0),CDR(L 42 0)).

 ш1.2
   Обе длины CDR(L 41 0) и CDR(L 42 0) меньше соответственно длин L1 и  L2,
и, следовательно, к  1IntOrd 0(CDR(L 41 0),CDR(L 42 0)) применимо предположение
индукции.   1IntOrd 0(CDR(L 41 0),CDR(L 42 0)) представляет собой упорядоченный
список всех чисел,  которые входят как в CDR(L 41 0),  так и в CDR(L 42 0).
Кроме того, CAR(L 41 0)=CAR(L 42 0), и, следовательно CAR(L 41 0) (или CAR(L 42 0))
должен входить в качестве элемента в результирующий список.
   Однако CONS(CAR(L 41 0), 1IntOrd 0(CDR(L 41 0),CDR(L 42 0))) состоит из
 ш1.0

   In 1tOrd 0(CDR(L 41 0),CDR(L 42 0)),

 ш1.2
содержащего в заданном порядке общие для CDR(L 41 0) и CDR(L 42 0)  элемен-
ты,  и одного дополнительного элемента CAR(L 41 0). Это именно тот спи-
сок,  который требуется, следовательно, в этом случае  1IntOrd 0() "ра-
ботает" правильно.
    1Предложение доказано.

               2УПРАЖНЕНИЯ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 3   0ш1.0
                                    1Ум человека ограничен, надо идти
                                    1по 0  1ту 0  1сторону 0  1ума, т.е. за ум.
                                                             1Д.Хармс
 3   0ш1.2

                   3Вполне упорядоченные множества
    21. 0 Выясните,  какие из следующих множеств являются вполне упоря-
доченными множествами: (а) множество всех целых чисел; (б) множест-
во  всех натуральных чисел;  (в) множество всех рациональных чисел;
(г) множество всех неотрицательных рациональных чисел.
    22. 0 Превратится ли множество  ═N 0 во вполне упорядоченное множество,
если отношение порядка ввести следующим образом:  (а) (n,m) 7еr 0, если
n  и  m взаимно просты;  (б) 7З 0(n,m) 7еr 0,  если n является делителем m;
(в)(n,m) 7еr 0,  если n=m 52 0;  (г) (n,m) 7еr 0,  если n<m; (д) (n,m) 7еr 0, если
n 7, 0m.
                 3Семантика 0  3индуктивных определений 2:
                     3вычисление через расширение
    21. 0 Опишите процесс вычисления значения данной функции при задан-
ных значениях аргументов:
    2(a) 0  1F 0: ═N 7& ═N 0─ 76 ═N 0,
 ш1.0

             7( 0x 42 0, если x 41 0=0;
            │
    1F 0(x 41 0,x 42 0) 7"* 0x 41 0, если x 42 0=0;
            │
             79 1F 0(x 41 0+1,x 42 0-1), если x 41 7- 00&x 42 7- 00.

 ш1.2
   (1)  1F 0(1,0); (2)  1F 0(0,2); (3)  1F 0(3,4);
    2(б)
 ш1.0

         7( 00, если x=0;
    1G 0(x) 7"* 01, если x=1;
         79 1G 0( 1G 0(x-1)), если x>1.

 ш1.2
   (1)  1G 0(0); (2)  1G 0(1); (3)  1G 0(2); (4)  1G 0(3);
    2(в) 0 функция Аккермана  1A 0: ═N 7& ═N 0─ 76 ═N 0,
 ш1.0

             7( 0x 42 0+1, если x 41 0=0;
            │
    1A 0(x 41 0,x 42 0) 7"* 1A 0(x 41 0-1,1), если x 42 0=0;
            │
             79 1A 0(x 41 0-1, 1A 0(x 41 0,x 42 0-1)), если x 41 7- 00&x 42 7- 00.

 ш1.2
   (1)  1A 0(0,0); (2)  1A 0(1,0); (3)  1A 0(1,2); (4)  1A 0(2,1).
   Для однозначности  в  любой из моментов вычислений первым вычис-
ляйте самое левое и самое внутреннее обращение к функции   1A 0(),  все
аргументы которой уже не содержат обращения к функции  1A 0();
    2(г) 0  1W 0( 7a 0) 7" 1Tail 0( 1Reverse 0( 7a 0)),
 ш1.0

               7(L 0, если  7a 0= 7L 0,
    1Reverse 0( 7a 0) 7"* 0        7( 0        7)
               79 1Reverse 72 1Tail 0( 7a 0) 727 1Head 0( 7a 0), если  7a-L 0.
                       79 0        70

 ш1.2
   (1)  1W 0(abaa); (2)  1W 0(ab); (3)  1W 0(bac).
   Будет ли определён результат вычисления функции W( 7a 0) при  7a 0= 7L 0?
 ш1.0

                      7( 0                          7)
    2(д) 0  1S 0( 7a 0,x, 7b 0) 7" 1Subst 72 1Head 0( 7a 0) 77 1Tail 0( 1Tail 0( 7a 0)),x, 7b2 0,
                      79 0                          70
                 7(L 0, если  7a 0= 7L 0;
                │ 7a 0, если  7a-L 0& 1NoInt 0(x, 7a 0)= 2И 0;
    1Subst 0( 7a 0,x, 7b 0) 7"* 1Head 0( 7a 0)∙ 1Subst 0( 1Tail 0( 7a 0),x, 7b 0),
                │   если  7a-L 0& 1Head 0( 7a 0) 7- 0x& 1NoInt 0(x, 7a 0) 7- 2И 0;
                │ 7b 0∙ 1Subst 0( 1Tail 0( 7a 0),x, 7b 0),
                 79 0   если  7a-L 0& 1Head 0( 7a 0)=x& 1NoInt 0(x, 7a 0) 7- 2И 0.

               7( 2И 0, если  7a 0= 7L 0;
    1NoInt 0(x, 7a 0) 7"*
               79 0x 7- 1Head 0( 7a 0)& 1NoInt 0(x, 1Tail 0( 7a 0)), если  7a-L 0.

 ш1.2
   (1)  1S 0(клок,к,кол); (2)  1S 0(алгоритм,а,ал).
   Определите область определения и область значения функции  1S 0.
    21 41 2. 0 [Андерсон,2003,с.198]
   Найдите f(1),  f(2), f(3), f(4) для приведённых ниже рекурсивных
функций:
 ш1.0

        7( 0f(0)=3;              7( 0f(0)=1;               7( 0f(0)=2;
   (а)  7* 0                (б)  7* 0                 (в)  7*
        79 0f(k)=3f(k-1);        79 0f(k)=2f(k-1)+3k;      79 0f(k)=(f(k-1)) 52 0;

        7( 0f(0)=1;              7( 0f(0)=1;
   (г)  7* 0                (д)  7*
        79 0f(k)=k 52 0f(k-1);       79 0f(k)=2 5f(k-1) 0.

 ш1.2
    21 42 2. 0 [Андерсон,2003,с.198]
   Найдите f(1),  f(2),  f(3), f(4) для следующих рекурсивных функ-
ций:
 ш1.0

        7( 0f(0)=0;                        7( 0f(0)=4;
   (а)  7* 0                          (г)  7*
        79 0f(k)=k+f(k-1);                 79 0f(k)=f(k-1)/k 52 0;

        7( 0f(0)=1;                        7( 0f(0)=2;
   (б)  7* 0                          (д)  7*
        79 0f(k)=│f(k-1)/2│+3k;            79 0f(k)=f(k-1)/k!
             └        ┘
        7( 0f(0)=2;
   (в)  7*
        79 0f(k)=8k 52 0-(f(k-1)) 52 0;

 ш1.2
    21 43 2. 0 [Андерсон,2003,с.198]
   Найдите f(2),  f(3), f(4) и f(5) для следующих рекурсивных функ-
ций:
 ш1.0

        7( 0f(0)=1;                        7( 0f(0)=1;
   (а)  7* 0f(1)=3;                   (г)  7* 0f(1)=2;
        79 0f(k)=2f(k-1)-f(k-2);           79 0f(k)=(f(k-1)-f(k-2))*k!

        7( 0f(0)=0;                        7( 0f(0)=-1;
   (б)  7* 0f(1)=1;                   (д)  7* 0f(1)=1;
        79 0f(k)=(f(k-1)) 52 0-(f(k-2)) 52 0;      79 0f(k)=f(k-1) 7_ 0f(k-2).

        7( 0f(0)=1;
   (в)  7* 0f(1)=2;
        79 0f(k)=(f(k-1)) 52 0-f(k-2)+k 52 0;

 ш1.2
    21 44 2. 0 [Андерсон,2003,с.198]
   Найдите f(2),  f(3), f(4) и f(5) для следующих рекурсивных функ-
ций:
 ш1.0

        7( 0f(0)=2;                        7( 0f(0)=10;
   (а)  7* 0f(1)=4;                   (г)  7* 0f(1)=20;
        79 0f(k)=3f(k-1)-2f(k-2);          79 0f(k)=│(f(k-1)+f(k-2))/k!│;
                                            └                  ┘
        7( 0f(0)=1;                        7( 0f(0)=-1;
   (б)  7* 0f(1)=2;                   (д)  7* 0f(1)=1;
        79 0f(k)=(f(k-1))!-(f(k-2))!       79 0f(k)=f(k-1) 7_ 0(f(k-2)) 52 0.

        7( 0f(0)=0;
   (в)  7* 0f(1)=2;
        79 0f(k)=(f(k-1))! 7_ 0(f(k-2))!

    22. 0 Определите, является ли заданная функция предикатом:

             7( 00, если x=0;
    2(а) 0  1G 0(x) 7"* 01, если x=1;
             79 1G 0( 1G 0(x-1)), если x>1.

               7( 2Л 0, если  7a 0= 7Lv 1len 0( 7a 0)<2;
    2(б) 0  1N 0( 7a 0,x) 7"*
               79 1Head 0( 7a 0)=x& 1N 0( 1Tail 0( 1Tail 0( 7a 0)),x), если  7a-L 0& 1len 0( 7a 0) 7. 02;

               7( 00, если  7a 0= 7L 0;
        1len 0( 7a 0) 7"* 0    7( 0        7)
               79 1len 72 1Tail 0( 7a 0) 72 0+1, если  7a-L 0.
                   79 0        70
             7( 20 0, если  1Reverse 0( 7a 0)= 7L 0;
    2(в) 0  1P 0( 7a 0) 7"*
             79 21 0, если  1Reverse 0( 7a 0) 7-L 0.

 ш1.2
   Здесь  20  0и  21 0 - буквы некоторого алфавита.

                  3Определение семантики индуктивно
                          3заданной функции

 ш1.0
             1Невозможно отделить язык от науки или науку  от  языка,
             1поскольку  любая  естественная  наука всегда использует
             1три вещи 0: 1  последовательность феноменов, на которые она
             1опирается, краткие описания - концепции этих феноменов,
             1которыми они представляются в мышлении,  и слова, в ко-
             1торых  выражаются  концепции.  Для движения к концепции
             1необходимо слово 0: 1  для описания явления необходима кон-
             1цепция. Все три отражают одну и ту же реальность. 0
                                                    1А.Лавуазье, 1789
 ш1.2

    23. 0 Определите семантику следующих функций:
    2(a) 0  1Sec 0: 7A 5* 0─ 76A 5* 0,
 ш1.0

           7(L 0, если  1len 0( 7a 0)<2;
    1Sec 0( 7a 0) 7"*
           79 1Head 0( 1Tail 0( 7a 0)) в противном случае;

    2(б) 0  1Rep 0: 7A 5* 7&A 0─ 76A 5* 0,

             7(L 0, если  7a 0= 7L 0;
            │
    1Rep 0( 7a 0,x) 7"* 0x, если  7a-L 0& 1Tail 0( 7a 0)= 7L 0;
            │
             79 0x 77 1Tail 0( 1Body 0( 7a 0)) 77 0x, если  7a-L 0& 1Tail 0( 7a 0) 7-L 0;

            7(L 0, если  1Tail 0( 7a 0)= 7L 0;
    1Body 0( 7a 0) 7"*
            79 1Head 0( 7a 0) 77 1Body 0( 1Tail 0( 7a 0)), если  1Tail 0( 7a 0) 7-L 0;

    2(в) 0  1Sub 0: 7A 5* 7&A&A 5* 0─ 76A 5* 0,

    1Sub 0( 7a 0,x, 7b 0) 7" 1Subst 0( 1Reverse 0( 7a 0),x, 1Reverse 0( 7b 0)).

 ш1.2
   Напишите данное определение более рациональным способом;
    2(г) 0  1Q 0: 7A&A 5* 0─ 76A 5+ 0,
 ш1.0

           7( 1Reverse 0( 1Reverse 0( 7a 0) 77 0x), если  1Int 41 0(x, 7a 0)= 2И 0;
    1Q 0(x, 7a 0) 7"*
           79 1Reverse 0(x 77 1Reverse 0( 7a 0)), если  1Int 41 0(x, 7a 0)= 2Л 0;

              7( 2Л 0, если  7a 0= 7L 0;
             │
    1Int 41 0(x, 7a 0) 7"* 2И 0, если  1Head 0( 7a 0)=x& 7a-L 0;
             │
              79 1Int 41 0(x, 1Tail 0( 7a 0)), если  1Head 0( 7a 0) 7- 0x& 7a-L 0;

    2(д) 0  1Kol 0: 7A&A 5* 0─ 76 ═N 0,

             7( 00, если  7a 0= 7L 0;
            │
    1Kol 0(x, 7a 0) 7"* 1Kol 0(x, 1Tail 0( 7a 0))+1, если  7a-L 0& 1Head 0( 7a 0)=x;
            │
             79 1Kol 0(x, 1Tail 0( 7a 0)), если  7a-L 0& 1Head 0( 7a 0) 7- 0x.

 ш1.2
    24. 0 Дана последовательность значений функции от  различных  аргу-
ментов.  Определите семантику функции и напишите её индуктивное оп-
ределение:
 ш1.1

   (a)  1F 41 0: ═N 0─ 76 ═N 0         (б)  1F 42 0: ═N 0─ 76 ═N 0     (в)  1Third 0: 7A 5* 0─ 76A 5*
        1F 41 0(1)=1;             1F 42 0(1)=1;         1Third 0( 7L 0)= 7L 0;
        1F 41 0(2)=1+1=2;         1F 42 0(2)=1;         1Third 0(a)= 7L 0;
        1F 41 0(3)=2+1=3;         1F 42 0(3)=2;         1Third 0(bc)= 7L 0;
        1F 41 0(4)=3+1=4;...      1F 42 0(4)=3;         1Third 0(cba)=a;
                            1F 42 0(5)=5;         1Third 0(abdcea)=d;
                            1F 42 0(6)=8;...      1Third 0(cebfd)=b;...
   (г) 1 Wrd3 0: 7A 5* 0─ 76A 5*
        1Wrd3 0( 7L 0)= 7L 0;
        1Wrd3 0(c)= 7L 0;
        1Wrd3 0(ab)= 7L 0;
        1Wrd3 0(cab)=b;
        1Wrd3 0(abcdef)=cf;...

 ш1.2
    24 41 2. 0 [Андерсон,2003,с.199]
   Найдите явные выражения для f(n), исключив рекурсию из следующих
определений:
 ш1.0

        7( 0f(0)=1;              7( 0f(0)=1;               7( 0f(0)=1;
   (а)  7* 0                (в)  7* 0                 (д)  7*
        79 0f(k)=2f(k-1);        79 0f(k)=f(k-1) 7_ 0k;        79 0f(k)=5f(k-1).

        7( 0f(0)=1;              7( 0f(0)=1;
   (б)  7* 0                (г)  7* 0
        79 0f(k)=1+f(k-1);       79 0f(k)=f(k-1)+2;

 ш1.2
    24 42 2. 0 [Андерсон,2003,с.199]
   Найдите явные выражения для f(n), исключив рекурсию из следующих
определений:
 ш1.0

        7( 0f(0)=2;              7( 0f(0)=-1;             7( 0f(0)=1;
   (а)  7* 0                (в)  7* 0                (д)  7*
        79 0f(k)=f(k-1)!/k!      79 0f(k)=-1/f(k-1);      79 0f(k)=5+2f(k-1);

        7( 0f(0)=1;              7( 0f(0)=1;              7( 0f(0)=-1;
   (б)  7* 0                (г)  7* 0                (е)  7* 0f(1)=1;
        79 0f(k)=1+f(k-1);       79 0f(k)=-3f(k-1);       79 0f(k)=f(k-1)
                                                          /f(k-2).

 ш1.2
    25. 0 Допишите индуктивное определение:
    2(а) 0 предиката  1Compare 0: 7A 5+ 0─ 76B 42 0,  устанавливающего  тот  факт,  что
одинаковые буквы стоят на нечётных местах в исходном слове:
 ш1.0

               7( 2И 0, если  ...( 1Tail 0( 7a 0))= 7L 0;
              │
    1Compare 0( 7a 0) 7"* 1Compare 0( 1Tail 0( 1Tail 0( 7a 0))), если  1Tail 0( 1Tail 0( 7a 0)) 7-L 0&...;
              │
               79 0...

 ш1.2
    2(б) 0 функции  1Delete 0: 7A&A 5* 0─ 76A 5* 0,  в результате применения которой  к
слову  получается  слово,  из  которого вычеркнули первое вхождение
данной буквы (если таковая имеется в данном слове):
 ш1.0

                7( 0..., если  7a 0= 7L 0;
               │
    1Delete 0(x, 7a 0) 7"* 1Tail 0( 7a 0), если ...;
               │
                79 1Head 0( 7a 0) 77 0..., если  7a-L 0&x 7- 1Head 0( 7a 0);

 ш1.2
    2(в) 1  0функции  1St 0: 7A&A 5* 0─ 76 ═N 0, являющейся степенью слова  7a 0 относительно
буквы x:
 ш1.0

            7( 00, если  7a 0= 7L 0;
           │
    1St 0(x, 7a 0) 7"* 1St 0(..., 1Tail 0(...)), если x 7- 1Head 0( 7a 0);
           │
            79 0...+ 1St 0(x, 1Tail 0( 7a 0)), если x=...( 7a 0).

 ш1.2
    26. 0 (Н.Н.Непейвода,1998)
   Что вычисляет  следующая   функция   действительного   аргумента
( 3D 0 - оператор дифференцирования):
 ш1.0

                 7( 0f(0), если n=0;
   (1)  1F 0(f,x,n) 7"*
                 79 1F 0(f,x,n-1)+ 3D 5n 0(f)(x)/n! в противном случае;

                 7( 1F 0(f,x,n+1)+ 3D 5n 0(f)(x)/n!, если n 7. 00;
   (2)  1F 0(f,x,n) 7"*
                 79 1Не определена 0, если n<0.

 ш1.2
    27. 0 (По [Андерсон,2003,с.199-200])
   Докажите, что  формула для a 4n 0 удовлетворяет соответствующему ре-
курсивному определению:
 ш1.0

   (1) a 4n 0=7-2 5n+1 0,               (7) a 4n 0=-2(-1) 5n 0+2 77 03 5n 0,

    7( 0a 40 0=5;                        7( 0a 40 0=0;
    7* 0                             7* 0a 41 0=8;
    79 0a 4k 0=2a 4k-1 0-7 при k>0;          79 0a 4k 0=2a 4k-1 0+3a 4k-2 0 при k>2;

   (2) a 4n 0=3 5n 0-n3 5n+1 0,             (8) a 4n 0=2(-3) 5n 0+5 77 02 5n 0,

    7( 0a 40 0=1;                        7( 0a 40 0=7;
    7* 0a 41 0=-6;                       7* 0a 41 0=4;
    79 0a 4k 0=6a 4k-1 0-9a 4k-2 0 при k>1;      79 0a 4k 0=-a 4k-1 0+6a 4k-2 0 при k>1;

   (3) a 4n 0=-1-2 5n+1 0,              (9) a 4n 0=3(-2) 5n 0+2 77 03 5n 0-3 77 02 5n 0,

    7( 0a 40 0=-3;                       7( 0a 40 0=2;
    7* 0a 41 0=-5;                       7* 0a 41 0=-6;
    79 0a 4k 0=6a 4k-1 0-8a 4k-2 0-3 при k>1;    79 0a 4k 0=a 4k-1 0+6a 4k-2 0+3 77 02 5k 0 при k>1;

   (4) a 4n 0=(1-r 5n+1 0)/(1-r),       (10) a 4n 0=n 52 0(n+1) 52 0,

    7( 0a 40 0=1;                        7( 0a 41 0=4;
    7* 0                             7*
    79 0a 4k 0=a 4k-1 0+r 5k 0 при k>0;          79 0a 4k 0=a 4k-1 0+4k 53 0 при k>1;

   (5) a 4n 0=n 52 0+n+1,               (11)          7(( 0    7|\) 0n   7( 0    7|\) 0n 7)
                                          1   722 01+ 7? 05  72 0    72 01- 7? 05  72 0  72
    7( 0a 41 0=3;                            a 4n 0= ─── 7722 0───── 72 0 -  72 0───── 72 0  72 0,
    7* 0                                       7|\ 0  722 0  2   72 0    72 0  2   72 0  72
    79 0a 4k 0=a 4k-1 0+2k при k>1;                   7? 05   799 0      70 0    79 0      70 0  70
                                 7( 0a 41 0=1;
                                 7* 0a 42 0=1;
                                 79 0a 4k 0=a 4k-1 0+a 4k-2 0 при k>1.
 ш1.2

                 3Построение индуктивных определений
                         ( 1простые задачи 0)

 ш1.0
                 1Я всегда ставлю самое  характерное  слово  в  конец
                 1строки и достаю к нему рифму во что бы то ни стало.
                                                        1В.Маяковский
 ш1.2

    20. 0 Напишите индуктивное определение функции,  вычисляющей модуль
разности двух целых неотрицательных чисел.
    21. 0 Напишите  индуктивное  определение  функции,  вычисляющей n-ю
степень числа x, x 7е ═N 0\{0}, n 7е ═N 0.
    22. 0 Напишите индуктивное определение  1предиката 0, устанавливающего,
что слово состоит не менее, чем из m букв, m 7е ═N 0.
    23. 0 Напишите  индуктивное  определение функции,  меняющей местами
первую и последнюю буквы заданного непустого слова.
    24. 0 Напишите индуктивное определение  1предиката 0,  устанавливающего
тот факт, что заданное слово является  1палиндромом 0.
    25. 0 Напишите индуктивное определение функции, конструирующей сло-
во, содержащее k букв a.
    26. 0 Напишите индуктивное определение функции, учетверяющей каждую
букву заданного слово.
    27. 0 Напишите  индуктивное  определение функции,  вычёркивающей из
заданного слова буквы,  расположенные: (1) на чётных местах; (2) на
нечётных местах.
    28. 0 Напишите индуктивное определение функции, производящей замену
всех букв исходного слова на данную букву x 7еA 0.
    29. 0 Напишите индуктивное определение функции, производящей замену
всех букв слова, стоящих на чётных местах, на заданную букву.
    210. 0 Напишите индуктивное определение функции, которая в заданном
слове заменяет все вхождения буквы x на букву y и наоборот.
    211. 0 Напишите индуктивное определение функции,  производящей  пе-
рестановку каждой буквы заданного слова,  расположенной на нечётном
месте, с соседней справа буквой (если она есть).
    212. 0 Напишите индуктивное определение функции, которая возвращает
"центральную" букву слова.
    213. 0 Напишите индуктивное определение  1предиката 0, устанавливающего
тот факт,  что в написании слова  7aеA 5+ 0  использовалась  только  одна
буква алфавита  7A 0.
    214. 0 Напишите индуктивное определение  1предиката 0, устанавливающего
тот факт,  что заданная буква имеет хотя бы одно вхождение в задан-
ное слово.
    215. 0 Приведите индуктивное определение функции,  вычеркивающей из
слова  7a 0 те буквы, которые встречаются в нём ровно n раз.
    216. 0 Приведите индуктивное определение  1предиката 0, устанавливающе-
го тот факт, что слово  7a 0: (1) является началом слова  7b 0; (2)  ─являет-
 ─ся 0  ─концом слова 0  7b 0; (3) не имеет вхождений в слово  7b 0.
    217. 0 Приведите индуктивное определение функции, значением которой
является конец слова  7a 0, началом которого является слово  7b 0.

                 3Построение индуктивных определений
                         ( 1сложные задачи 0)

 ш1.0
                 1Слова в  определениях часто создают более серьёзную
                 1путаницу и неоднозначность, чем определяемое слово.
                              1С.И.Хайакава. Язык вымышленный и живой
 ш1.2

    21 5* 2. 0 Приведите индуктивное определение:
 ш1.1
   (1) первого вхождения слова  7a 0 в слово  7b 0;
   (2)  ─последнего вхождения слова 0  7a 0 в  ─слово 0  7b 0;
   (3) k-го  вхождения  однобуквенного слова  7a 0 в слово  7b 0 для любого
натурального k 7. 01;
   (4) 2  0k-го (k 7е ═N 0\{0}) вхождения слова  7a 0 в слово  7b 0 для случая, когда
все вхождения не имеют общих вхождений букв алфавита;
   (5) k-го вхождения слова  7a 0 в слово  7b 0 для любого натурального k.

 ш1.2
    22 5* 2. 0 Приведите индуктивное определение операции подстановки:
 ш1.1
   (1) в слово  7a  0вместо слова  7g 0 слова 7 b 0;
   (2) в  слово   7a 0 вместо k-го вхождения слова  7g  0слова  7b 0 для любого
натурального k.

 ш1.2
    23 5* 2. 0 Приведите индуктивное определение количества вхождений:
 ш1.1
   (1) слова  7g 0 в слово  7a 0;
   (2) слова  7g 0 в слово  7a 0 для случая,  когда все вхождения не  имеют
общих вхождений букв алфавита.

 ш1.2
    24 5* 2. 0 Найдите ошибку, допущенную в следующем индуктивном определе-
нии k-го вхождения слова  7a 0 в слово  7b 0 для любого натурального k:
 ш1.0

                7(L 0, если k=1& 1Beg 0( 7a 0, 7b 0)= 2И 0;
               │
               │ 1First 0( 7a 0, 7b 0), если k=1& 1Beg 0( 7a 0, 7b 0)= 2Л 0;
                72 0                  7( 0          7( 0               7))
    1Int 43 0(k, 7a 0, 7b 0) 7"* 1First 0( 7a 0, 7b 0)∙ 7a 0∙ 1Int 43 72 0k-1, 7a 0, 1End 72b 0, 1First 0( 7a 0, 7b 0)∙ 7a22 0,
               │                  79 0          79 0               700
               │                           если k 7- 01& 1Beg 0( 7a 0, 7b 0)= 2Л 0;
               │             7( 0          7( 0          7))
               │ 1Head 0( 7a 0) 77 1Int 43 72 0k-1, 7a 0, 1End 72b 0, 1Head 0( 7a 0) 722 0,
                79 0             79 0          79 0          700
                                           если k 7- 01& 1Beg 0( 7a 0, 7b 0)= 2И 0,

 ш1.2
где функция  1First 0( 7a 0, 7b 0) определяет первое вхождение слова  7a 0 в  слово
 7b 0;  функция  1End 0( 7a 0, 7b 0) определяет конец слова  7a 0, началом которого яв-
ляется слово  7b 0;  функция  1Beg 0( 7a 0, 7b 0) определяет,  является ли слово   7a
началом слова  7b 0.

                     3Доказательство правильности
                       3индуктивных определений

 3   0ш1.0
                     1Необязательно следовать всем канонам строгости,
                     1достаточно понимать, как их достичь! 0
                                        1А.Н.Колмогоров, А.Г.Драгалин
 3   0ш1.2

    21. 0 Определите семантику  и  докажите  правильность  индуктивного
определения функции  1G 0: ═N 0\{0}─ 76 ═N 0\{0},
 ш1.0

         7( 51 0/ 42 0, если n=1;
    1G 0(n) 7"*
         79 1G 0(n-1)+1/(n*(n+1)), если n>1.

 ш1.2
    22. 0 Докажите правильность индуктивного определения операции  при-
писывания слова к слову ∙: 7A 5* 7&A 5* 0─ 76A 5* 0:
 ш1.0

        7(b 1, 7  0если  7a 0= 7L 0;
    7a 0∙ 7b"* 0         7( 0          7)
        79 1Head 0( 7a 0) 772 1Tail 0( 7a 0)∙ 7b2 1, 0 если  7a-L 0.
                 79 0          70

 ш1.2
    23. 0 Докажите правильность индуктивного определения операции  "об-
ращение слова"  1Reverse 0: 7A 5* 0─ 76A 5* 0:
 ш1.0

               7(L 0, если  7a 0= 7L 0;
    1Reverse 0( 7a 0) 7"* 0        7( 0        7)
               79 1Reverse 72 1Tail 0( 7a 0) 727 1Head 0( 7a 0), если  7a-L 0.
                       79 0        70

 ш1.2
    24. 0 Рассмотрим следующее индуктивное определение (n - натуральное
число), записанное на языке структурированных программ:
 ш1.0

    1F 0(n) 7" 0IF n=1
          THEN 1
          ELSE OTHERWISE n* 1F 0(n-1).

 ш1.2
   Определите семантику функции  1F 0. Докажите правильность догадки.
    25. 0 Рассмотрим следующее индуктивное определение (n - натуральное
число):
 ш1.0

    1Q 0(n) 7" 0IF n=1                       7( 01, если n=1;
          THEN 1                1S 0(n) 7"*
          ELSE n* 1S 0(n)+ 1Q 0(n-1),        79 0n 77 1S 0(n-1), если n>1.

 ш1.2
   Определите семантику функции 1  0Q.  Докажите правильность определе-
ния функции Q.
    26. 0 Рассмотрим следующую  программу  на  языке  структурированных
программ, применимую для неотрицательных целых n:
 ш1.0

    1F 0(n) 7" 0IF n=0
          THEN 0
          ELSE OTHERWISE  1F 0( 1F 0(n-1)).

 ш1.2
   Перепишите данную  программу на язык программирования LISP и до-
кажите, что  1F 0(n)=0 для любого неотрицательного целого числа n.
    27.  0Определите  семантику,  перепишите  на язык структурированных
программ и докажите правильность следующей программы:
 ш1.0

   (DEFUN Reverse1 (LAMBDA (L)
     (COND ( 1  0(NULL L) NIL 1  0)
           ( 1  0(AND (EQ (LENGTH L) 1) (ATOM (CAR L))) L 1  0)
           (  T  (APPEND (Reverse1 (CDR L))
                         (CONS (Reverse1 (CAR L)) NIL)) 1  0))
   ))

 ш1.2
    28. 0 Рассмотрим рекурсивную программу  1Subs 0(X 41 0,X 42 0,L),  применимую к
любым двум атомам X 41 0, X 42 0 и любому списку L:
 ш1.0

    1Subs 0(X 41 0,X 42 0,L) 7" 0IF L=NIL
                  THEN NIL
                  ELSE IF CAR(L)=X 42
                        THEN CONS(X 41 0, 1Subs 0(X 41 0,X 42 0,CDR(L)))
                        ELSE IF ATOM(CAR(L))
                            THEN CONS(CAR(L), 1Subs 0(X 41 0,X 42 0,CDR(L)))
                            ELSE OTHERWISE CONS( 1Subs 0(X 41 0,X 42 0,CAR(L)),
                                                 1Subs 0(X 41 0,X 42 0,CDR(L)))

 ш1.2
   Перепишите данную  программу на язык программирования LISP и до-
кажите,  что в этом случае  1Subs 0(X 41 0,X 42 0,L) есть список, полученный из
L путём подстановки X 41 0 вместо каждого вхождения элемента X 42 0 в L.
   Например,
 ш1.0

   SUBS(B C (A B C (A (C))))=(A B B (A (B))).

 ш1.2
    29.  0Рассмотрим индуктивное определение функции  1F 0 (n 7е 0Z):
 ш1.0

         7( 0n-3, если n>202;
    1F 0(n) 7"*
         79 1F 0( 1F 0(n+4)), если n 7, 0202.

   Докажите, что для всех целых n

         7( 0n-3, если n>202;
    1F 0(n) 7"*
         79 0200, если n 7, 0202.

 ш1.2
    210. 0 Пусть  1А 0(х 41 0,х 42 0) - функция Аккермана. Докажите, что
 ш1.0

    1А 0(х 41 0,х 42 0)>х 41 0+х 42

 ш1.2
для всех неотрицательных целых чисел х 41 0 и х 42 0.
    211.  0Рассмотрим следующее индуктивное определение (n 7е 0Z):
 ш1.0

    1F 0(n) 7" 0IF n=0
          THEN 0                            7( 2И 0, если n - чётное
          ELSE IF  1Even 0(n)           1Even 0(n) 7"* 0                число;
                 THEN  1F 0(n/5)+5              79 2Л 0, если n - нечётное
                 ELSE  1F 0(3*n+1)-1,                           число.

 ш1.2
   Через n/5 обозначается частное от целочисленного деления n на 5.
   Докажите, что  для всех неотрицательных целых чисел n вычисление
значения функции заканчивается.
    212. 0 Рассмотрим  следующее индуктивное определение (х 41 0 и х 42 0 - не-
отрицательные целые числа):
 ш1.0

    1F 0(х 41 0,х 42 0) 7" 0IF х 41 0=0
              THEN 0
              ELSE IF х 42 0=0
                     THEN  1F 0(x 41 0-1,х 42 0+1)
                     ELSE  1F 0( 1F 0(х 41 0-1,х 42 0), 1F 0(х 41 0,х 42 0-1)).

 ш1.2
   Определите семантику функции  1F 0(х 41 0,х 42 0).
   Докажите правильность догадки.
    213. 0 Рассмотрим  рекурсивное определение (х 41 0 и х 42 0 - неотрицатель-
ные целые числа, удовлетворяющие условиям 0 7, 0х 41 7, 0х 42 0 и 0<х 42 0):
 ш1.0

    1F 0(х 41 0,х 42 0) 7" 0IF х 41 0=0
              THEN х 42
              ELSE IF х 41 7, 0x 42 0-x 41
                     THEN  1F 0(х 41 0,х 42 0-х 41 0)
                     ELSE  1F 0(х 42 0-х 41 0,х 41 0).

   Докажите, что для любых целых х 41 0 и х 42 0 при условии 0 7, 0х 41 7, 0х 42 0 и 0<х 42

    1F 0(х 41 0,х 42 0)= 1GCD 0(х 41 0,х 42 0),

 ш1.2
где GCD - наибольший общий делитель х 41 0 и х 42 0.
   При доказательстве используйте тот факт,  что по определению для
любых рассмотренных выше х 41 0 и х 42 0:
 ш1.0

    1GCD 0(х 41 0,х 42 0)= 1GCD 0(х 41 0,х 42 0-х 41 0)= 1GCD 0(х 42 0-х 41 0,х 41 0).

 ш1.2
    214. 0 Докажите  правильность  следующей  программы,  написанной на
языке функционального программирования LISP:
 ш1.0

   (DEFUN F (LAMBDA (N)
       (COND ( 1  0(EQ N 1) 1 1  0)
             ( 1  0 T 1  0 (+ N (F (- N 1))) 1  0))
   ))

 ш1.2
   Предполагается, что F(n)=n(n+1)/2 для любого натурального n.
