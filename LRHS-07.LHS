> import List
> import Random

    2ЛАБОРАТОРНАЯ РАБОТА 7.
    2ФУНКЦИОНАЛЫ-СВЁРТКИ НА СПИСКАХ. ПРОГРАММИРОВАНИЕ В СТИЛЕ ОРИГАМИ

 ш1.0
               1- Ты ведёшь себя не как исчислитель, а как пиит.
               1Нержин не удивился 0: 1 и "математик" и "поэт" были заме-
               1нены по известному чудачеству Сологдина  говорить  на
               1так называемом Языке Предельной Ясности,  не употреб-
               1ляя  _птичьих ., то есть иностранных, слов. 0
                                        1А.Солженицын. В круге первом
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ

    _ 1Вспомогательные понятия . 0:
 ш1.0
    1- моноиды, 0 " 1оригами 0", " 1оригамика 0",  1"паттерн рекурсии" 0.
 ш1.2

    _ 1Знать . 0:
 ш1.0
    1- понятие 0  1"свёртка" 0;
    1- 0  1функционалы  свёртки на списках в библиотеке Prelude 0:   1свёртка
 1справа, свёртка справа на непустых списках,  свёртка слева, свёртка
 1слева на непустых списках 0;
    1- теоремы двойственности для свёрток 0;
    1- законы объединения для свёрток 0:  1законы fold-объединения 0,  1зако-
 1ны fold-map-объединения 0,  1закон fold-concat-объединения 0,  1закон fold-
 1map-concat-объединения 0,  1законы fold-scan-объединения 0;
    1- функционалы-конструкторы 0:  1scanl, scanl1, scanr, scanr1 0;
   - 1 понятия 0: 1  "программирование в стиле оригами",  "Haskell-орига-
 1ми" 0;
    1- 0  1определение функций и функционалов 0  1с помощью свёртки foldr 0;
    1- 0  1определение функций и функционалов 0  1с помощью свёртки foldl 0;
    1- 0  1определение комбинатора неподвижной 0  1точки с помощью свёртки 0;
    1- сбалансированная свёртка 0;
    1- 0  1функционал развёртки на списках 0;
    1- 0  1технология MapReduce 0;
    1- списочный гомоморфизм, теоремы о списочном гомоморфизме 0.

 ш1.2
    _ 1Уметь . 0:
 ш1.0
   - реализовывать функции и функционалы в стиле Haskell-оригами;
   - определять комбинатор неподвижной точки на языке Haskell с по-
мощью свёртки и использовать его для программирования в стиле  Has-
kell-оригами.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                       2Вспомогательные понятия

 ш1.0
             1- Не понимаю, как можно жить, не прочитав Достоевского 0!
             1- Ну, жил же Пушкин 0!
                                                1Литературный анекдот
 ш1.2

                             21. 0  3Моноиды
   Пусть M - множество.
    2Определение 0.
 ш1.1
    2(1)  0[Голдблатт,1983,с.43]  _ 1Моноидом . 0 называется кортеж
 ш1.0

   (M,*, 3e 0),

 ш1.1
где *:M 52 0─ 76 0M,  причём отображение * является ассоциативным, т.е. для
любых x,y,z 7е 0M
 ш1.0

   x*(y*z)=(x*y)*z.                       ║  7А 0x,y,z(x*(y*z)=(x*y)*z)

 ш1.1
    _ 1Единицей моноида . 0 называется элемент  3e 7е 0M, такой, что для всех x 7е 0M
 ш1.0

    3e 0*x=x, x* 3e 0=x.                          ║  7Э 0x 7А 0y(x*y=y&y*x=y)

 ш1.1
    2(2) 0 [Лаллеман,1985,с.16]  _ 1Моноид . 0 <M, 77 0,1> - это множество M с  та-
кими  бинарной  операцией и выделенным элементом 1,  что (M, 77 0) есть
 1полугруппа с единицей 0 1.

 ш1.2
                        22. 3 Оригами. Оригамика
   Японское слово " 1оригами 0" состоит из слов " 1свёртка 0" и " 1бумага 0".
    2Определение 0 ( 1описательное 0).
 ш1.1
    2(1) 0 (По [Хага,2012])  Под  _ 1оригами . 0 ( 1в Японии 0) обычно понимают ис-
кусство бумажных поделок,  увлечение в основном детское (почти  все
книги по оригами можно купить в детских отделах книжных магазинов).
    2(2) 0  _ 1Оригами . 0 - это цветные украшения или  фигурки,  сложенные  из
квадратного  листа  цветной  бумаги.  Результатом конструирования в
оригами являются бумажные фигурки животных, цветы, фрукты и т.д.
    2(3) 0  _ 1Оригами . 0 - это искусство бумажной  1скульптуры 0.

 ш1.2
    2Определение 0 ( 1конструктивное 0) 1  0[Комлев,2006].
 ш1.1
    2(1) 0  _ 1Оригами . 0 (от яп.   1ori 0 -  1свёртка 0,  1kami - бумага 0) - это старин-
ное японское искусство конструирования из бумаги разного рода изоб-
ражений декоративного характера (путём её  1перегибания 0,  1разрезания 0 и
 1комбинирования 0).
    2(2) 0 (По [Хага,2012,с.92]) В оригами используются  следующие тер-
мины для названия  1операций над прямоугольным листом бумаги 0:
   (а) если  сгиб  производится  в направлении "на себя",  то линия
сгиба называется  _ 1линией долины . 0;
   (б) если  сгиб  производится  в направлении "от себя",  то линия
сгиба называется  _ 1линией горы . 0 (линия горы превращается в линию доли-
ны и наоборот, если бумагу перевернуть);
   (в)  _ 1книжные сгибы . 0 - это сгибы по горизонтали или по вертикали;
   (г)  _ 1книжный сгиб . и 0  _ 1диагональный сгиб . 0 - это сгибы,  которые делят
лист на две равные части.

 ш1.2
    2Определение 0 (по [Хага,2012]).
 ш1.1
    _ 1Оригамика . 0 - это "оригамистическая"  1геометрия 0, для которой основ-
ным и практически единственным инструментом геометрических построе-
ний является  _ 1лист бумаги . 0.

 ш1.2
                        23. 0  3Паттерны рекурсии
   Вначале определим смысл термина " 1паттерн 0".
   По словам К.Александра (цит.  по  [Гамма,Хелм,Джонсон,Влиссидес,
2006,с.16]), "любой  1паттерн 0 описывает задачу, которая снова и снова
возникает в вашей работе,  а также принцип её решения, причём таким
образом,  что это решение можно потом использовать миллион раз, ни-
чего не изобретая заново".
   Итак, смысл паттерна - предложить решение определённой задачи  в
конкретном контексте.
   Хотя К.Александр имел в виду паттерны,  возникающие при проекти-
ровании зданий и городов,  но его слова верны и в отношении паттер-
нов в программировании.
    2Определение 0.
 ш1.1
    _ 1Паттерном рекурсии . 0 (от англ.   1pattern - шаблон 0,   1примитив 0,  1обра-
 1зец 0) назовём описание взаимодействия функций и функционалов функци-
онального языка программирования,  адаптированных (приспособленных)
для  1рекурсивного решения 0 некоторой задачи в конкретном контексте.

 ш1.2
    3Замечания 0 ( 1важные 0).
 ш1.1
    21. 0 Фрагмент программы, который один программист воспринимает как
 1паттерн рекурсии 0,  для другого программиста может  являться  просто
 1строительным блоком 0.
    22.  0Свёртка - это не единственный полезный паттерн рекурсии.
   Например [Bird,de Moor,1997],  1двойственный оператор 0 используется
в целях спецификации.
    23. 0 Некоторые экспериментальные языки программирования  показыва-
ют, что использование паттернов рекурсии является более эффективным
способом использования рекурсивных функций. Среди них выделим:
   (а) язык программирования Charity (Cockett & Fukushima,1992);
   (б) язык программирования PolyP (Jansson & Jeuring,1997);
   (в) алгебраический язык ADL (Kieburtz & Lewis,1994).
 ш1.2

                    2Функционалы свёртки в Prelude

 ш1.0
                                                1Стиль - это человек.
                                                   1Ж.Л.Бюффон 0 ( 11763 0)
 ш1.2

   Рассмотрим функционалы  языка программирования Haskell,  которые
являются паттернами рекурсии в функциональном  программировании;  к
таким функционалам относится " 1свёртка 0".
   Оператор свёртки  встречается  ещё  в теории рекурсивных функций
(С.Клини,1952), а также в языках программирования APL ( 1оператор ре-
 1дукции 0, К.Айверсон, 1962), и FP ( 1оператор вставки 0, Дж.Бэкус,1978).
    2Определение 0 (по [Кирпичёв,2009,с.156]).
 ш1.1
    _ 1Свёрткой . 0 ( 1в программировании 0) называется индуктивный процесс вы-
числения  _ 1снизу вверх . 0, применяющий в каждом узле некоторой  1структуры
 1данных 0  функцию,  соответствующую данному типу узла,  к содержимому
узла и результатам для его подузлов.

 ш1.2
   Приведём (неполный) список языков, в которых можно найти свертку
- непосредственно или с помощью дополнительных модулей и библиотек.
   Вместо слова fold в названиях функций и соответствующих операций
может употребляться reduce или accumulate:
 ш1.1
    2C++ 0 (std::accumulate),
    2Perl 5 0 (reduce),  2Perl 6 0 (reduction metaoperator),
    2Python 0 (reduce, functools.reduce),
    2Ruby 0 (enum.inject, enum.reduce);
    2Scala 0 (foldLeft, foldRight, reduceLeft, reduceRight),
    2Common 0  2Lisp 0 (reduce),  2Scheme R6RS 0 (fold-left, fold-right),
    2Standard ML 0 (foldl, foldr),
    2OCaml 0 (List.fold_left, List.fold_right);
    2Clojure 0 (reduce),  2Erlang 0 (foldl, foldr),
    2Maxima 0 (lreduce, rreduce).

 ш1.2
                    21. 3 Свёртка справа на списках
   Функционал (от англ.   3fold 0 -  1свёртка 0,  3r 1ight 0 -  1справа 0), "сворачи-
вающий" заданный список с использованием бинарной функции и началь-
ного значения (свёртка производится  _ 1по ассоциации вправо . 0):
 ш1.0

    2foldr 0:: (a -> b -> b) -> b -> [a] -> b
    2foldr funct k lst

 ш1.2
   Например:
 ш1.0

   > foldr (+) 0 []        > foldr (-) 0 [1,2,3,4,5]
   0                       3

   > foldr (*) 4 [5,6,7]   > foldr min 10 [-1,2,13,-4,5]
   840                     -4

 ш1.2
   Название  1foldr 0 можно объяснить следующим образом.
   Рассмотрим список [a,b,c,d], который с помощью операции добавле-
ния элемента в начало списка запишем в виде
 ш1.0
   
   a : (b : (c : (d : []))).

 ш1.2
   Функционал foldr заменяет [] на некоторый начальный элемент e, а
операцию (:) на бинарную операцию, которую обозначим  7Х 0, и возвраща-
ет результат, т.е. она осуществляет следующее преобразование:
 ш1.0

   a : (b : (c : (d : []))) => a  7Х 0 (b  7Х 0 (c  7Х 0 (d  7Х 0 e))).

 ш1.2
   Так как операция (:) ассоциативна справа, то скобки в первом вы-
ражении можно было бы опустить.  Однако мы оставляем их в результи-
рующем выражении,  потому что операция  7Х 0 может быть неассоциативной
справа.
   Итак,  1денотационная семантика 0 функционала foldr представима либо
в инфиксной, либо в префиксной форме записи:
 ш1.0

   ┌────────────────────────────────────────────────────────────┐
   │ foldr ( 7Х 0) e [x 41 0,x 42 0,...,x 4n 0] = x 41 0  7Х 0 (x 42 0  7Х 0 (... (x 4n 0  7Х 0 e)...)) │
    1│                                                            │ 0,
   │ foldr f e [x 41 0,x 42 0,...,x 4n 0] = f x 41 0 (f x 42 0 (... (f x 4n 0 e)...)) 1   0 │
   └───────────────────────────────────────────────────────── 1── 0─┘

 ш1.2
где  7Х 0 - бинарная операция, f - функция с двумя аргументами, e - на-
чальное значение.
   Другими словами,  функционал foldr "сворачивает" список  в  одно
значение,  вставляя  1между 0 всеми элементами списка операцию  7Х 0, прод-
вигаясь при этом справа налево от заданного начального значения.
    2Пример 0.
 ш1.1
   Для списка, содержащего три элемента, последовательно получим:
 ш1.0

   foldr ( 7Х 0) e [] = e 4,

   foldr ( 7Х 0) e [x 41 0] = x 41 0  7Х 0 e,

   foldr ( 7Х 0) e [x 41 0,x 42 0] = x 41 0  7Х 0 (x 42 0  7Х 0 e),

   foldr ( 7Х 0) e [x 41 0,x 42 0,x 43 0] = x 41 0  7Х 0 (x 42 0  7Х 0 (x 43 0  7Х 0 e)).

 ш1.2
   Функционал " 1свёртка справа 0" для списков определён так:
 ш1.0

   foldr:: (a -> b -> b) -> b -> [a] -> b
   foldr f e []     = e
   foldr f e (x:xs) = f x (foldr f e xs)

 ш1.2
   Итак, foldr  f v,  используя функцию f::  a -> b -> b и значение
e:: b, обрабатывает список типа [a].
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1.

 ш1.2
    2Теорема 0 ( 1лёгкая 0).
 ш1.1
   Если операция  7Х 0 и функция e образуют  1моноид 0, то
 ш1.0

   foldr ( 7Х 0) e []             = e;
   foldr ( 7Х 0) e [x 41 0,x 42 0,...,x 4n 0] = x 41 7Х 0x 42 7Х 0... 7Х 0x 4n 0.

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
    2Теорема 0 [Bird,Wadler,1988,p.69].
 ш1.1
    2(1) 0 Если  операция   7Х 0 и функция e образуют  1моноид 0,  то для любых
списков xs и ys
 ш1.0

    3foldr 0 ( 7Х 0) e (xs ++ ys) = ( 3foldr 0 ( 7Х 0) e xs)  7Х 0 ( 3foldr 0 ( 7Х 0) e ys)

 ш1.1
    2(2) 0 Для  1произвольных 0 f и e и для любых списков xs и ys
 ш1.0

    3foldr 0 f e (xs ++ ys) =  3foldr 0 f ( 3foldr 0 f e ys) xs

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
    2Пример 0.
 ш1.0

> xs = [5.0,2.0..1.0]; ys = [7.0,2.0..2.0]
> f = (/)
> test1 = (foldr f 2 (xs ++ ys), foldr f (foldr f 2 ys) xs)

 ш1.2
    3Замечание 0.
 ш1.1
   В языке  программирования  Python  работа с функционалом свёртка
синтаксически выглядит так (с использованием безымянных функций):
 ш1.0

   >>> reduce(lambda x,y: x+y,[1,2,3],0)
   6

 ш1.2
                22. 3 Свёртка справа на непустых списках
   Функционал, "сворачивающий" заданный непустой список с использо-
ванием бинарной функции,  в качестве начального значения берёт пер-
вый элемент списка (свёртка производится  _ 1по ассоциации вправо . 0):
 ш1.0

    2foldr1 0:: (a -> a -> a) -> [a] -> a
    2foldr1 funct lst

 ш1.2
   Например:
 ш1.0

   > foldr1 (-) [1,2,3,4,5]      > foldr1 (*) [5,6,7]
   3                             210

   > foldr1 min [-1,2,-13,-4,5]
   -13

 ш1.2
   Итак,  1денотационная семантика 0 функционала foldr1 представима ли-
бо в инфиксной, либо в префиксной форме записи:
 ш1.0

   ┌──────────────────────────────────────────────────────────────┐
   │ foldr1 ( 7Х 0) [x 41 0,x 42 0,...,x 4n 0] = x 41 0  7Х 0 (x 42 0  7Х 0 (... (x 4n-1 0  7Х 0 x 4n 0)...)) │
    1│                                                              │ 0,
   │ foldr1 f [x 41 0,x 42 0,...,x 4n 0] = f x 41 0 (f x 42 0 (... (f x 4n-1 0 x 4n 0)...))  1   0│
   └─────────────────────────────────────────────────────────── 1── 0─┘

 ш1.2
где  7Х 0 - бинарная операция, f - функция с двумя аргументами.
                     23. 3 Свёртка слева на списках
   Функционал (от англ.  3fold 0 -  1свёртка 0,  3l 1eft 0 -  1слева 0), "сворачиваю-
щий" заданный список с использованием бинарной функции и начального
значения (свёртка производится  _ 1по ассоциации влево . 0):
 ш1.0

    2foldl 0:: (a -> b -> a) -> a -> [b] -> a
    2foldl funct k lst

 ш1.2
   Например:
 ш1.0

   > foldl (+) 0 []        > foldl (-) 0 [1,2,3,4,5]
   0                       -15

   > foldl (*) 4 [5,6,7]   > foldl max 10 [-1,2,13,-4,5]
   840                     13

 ш1.2
    1Денотационная семантика 0 функционала foldl такова:
 ш1.0

   ┌────────────────────────────────────────────────────────────┐
   │ foldl ( 7Х 0) e [x 41 0,x 42 0,...,x 4n 0] = (...((e  7Х 0 x 41 0)  7Х 0 x 42 0) ...)  7Х 0 x 4n 0 │,
   └────────────────────────────────────────────────────────────┘

 ш1.2
где  7Х 0 - бинарная операция, e - начальное значение.
   Заметим, что  если e - ассоциативная единица для операции  7Х 0,  то
foldr ( 7Х 0) e и foldl ( 7Х 0) e определяют одну и ту же функцию на конеч-
ных списках.
    2Пример 0.
 ш1.1
   Разберём подробно процесс применения foldl к заданному списку:
 ш1.0

   foldl ( 7Х 0) e [a,b,c] = foldl ( 7Х 0) (e  7Х 0 a) [b,c] =
                       = foldl ( 7Х 0) ((e  7Х 0 a)  7Х 0 b) [c] =
                       = foldl ( 7Х 0) (((e  7Х 0 a)  7Х 0 b)  7Х 0 c) [] =
                       = ((e  7Х 0 a)  7Х 0 b)  7Х 0 c).

 ш1.2
   В языке Haskell функционал " 1свёртка слева 0" для списков определён
следующим образом:
 ш1.0

   foldl:: (b -> a -> b) -> b -> [a] -> b
   foldl f e []     = e
   foldl f e (x:xs) = foldl f (f e x) xs

 ш1.2
   Итак, foldl f e обрабатывает элементы списка  типа [a]  _ 1слева на-
 _ 1право . 0 с  использованием  функции  f::  b -> a -> b (для объединения
значений), и значение e:: b в качестве начального значения.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1.

 ш1.2
    2Теорема 0 [Bird,Wadler,1988,p.69].
 ш1.1
   Для  1произвольных 0 f и e и для любых списков xs и ys
 ш1.0

    3foldl 0 f e (xs ++ ys) =  3foldl 0 f ( 3foldl 0 f e xs) ys

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
    2Пример 0.
 ш1.0

> xs' = [5.0,2.0..1.0]; ys' = [7.0,2.0..2.0]
> f'  = (/)
> test2  = (foldl f' 2 (xs' ++ ys'), foldl f' (foldl f' 2 xs') ys')
> test2' = (foldl f' 2 (xs' ++ ys'), foldl f' (foldr f' 2 xs') ys')

 ш1.2
    3Замечание 0 ( 1для знатоков нумералов в  7l 1-исчислении 0).
 ш1.1
   Представление натурального числа в l-исчислении неявно использу-
ет свёртку.
   Например, число 3 представляется  7l 0-термом f (f (f 0)) или в язы-
ке Haskell
 ш1.0

   succ (succ (succ 0)).

 ш1.1
   Последняя функция представима следующей свёрткой:
 ш1.0

   nat n = foldr1 f (replicate 1 n)
              where f = const . succ

 ш1.2
                24. 3 Свёртка слева на непустых списках
   Функционал, "сворачивающий" заданный непустой список с использо-
ванием бинарной функции,  в качестве начального значения берёт пер-
вый элемент списка (свёртка производится  _ 1по ассоциации влево . 0):
 ш1.0

    2foldl1 0:: (a -> a -> a) -> [a] -> a
    2foldl1 funct lst

 ш1.2
   Например:
 ш1.0

   > foldl1 (-) [1,2,3,4,5]       > foldl1 (*) [5,6,7]
   -13                            210

   > foldl1 min [-1,2,-13,-4,5]
   -13

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   Функционал свёртки представляет собой  1паттерн рекурсии 0,  поэтому
для других рекурсивно определённых структур данных достаточно заме-
нить конструкторы [] и (:) другими значениями и функциями.

 ш1.2
    2Пример 0.
 ш1.1
   Построим функцию,  которая  позволяет  проследить  за  процессом
конструирования результата выполнения правых и левых свёрток:
 ш1.0

> paren :: String -> String -> String
> paren x y = concat ["(",x," * ",y,")"]
> ------------------------------------------
> test3 = foldr  paren "1" ["a","b","c","d"]
>                                    == "(a * (b * (c * (d * 1))))"
> test4 = foldl  paren "1" ["a","b","c","d"]
>                                    == "((((1 * a) * b) * c) * d)"
> test5 = foldr1 paren     ["a","b","c","d"]
>                                    == "(a * (b * (c * d)))"
> test6 = foldl1 paren     ["a","b","c","d"]
>                                    == "(((a * b) * c) * d)"

 ш1.2

                 3Теоремы двойственности для свёрток

 ш1.0
                1Планируя грядки на следующую весну, учтите главное -
                1там, где росли вершки, посадите корешки, и наоборот.
                                                        1Дачный совет
 ш1.2

    2Теорема 0 ( 1первая теорема двойственности для свёрток 0)
           [Bird,Wadler,1988,p.68].
 ш1.1
   Если операция  7Х 0 и функция e образуют  1моноид 0, xs - конечное  1  0мно-
жество, то
 ш1.0

   ┌───────────────────────────────┐
   │ 3foldr 0 ( 7Х 0) e xs =  3foldl 0 ( 7Х 0) e xs│.
   └───────────────────────────────┘

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
   Другими словами, свёртки foldr и foldl на моноиде определяют од-
ну и ту же функцию.
   Однако иногда более эффективным является использование foldr,  а
иногда - foldl.  Например, более эффективно использование foldl для
представления функций  sum  и product,  а для представления функций
concat, and и or использование foldr более эффективно.
    2Теорема 0 ( 1вторая теорема двойственности для свёрток 0)
           [Bird,Wadler,1988,p.68].
 ш1.1
   Если операции  7Х 0,  7х 0 и функция e таковы, что
 ш1.0

   (а)  7А 0x 7А 0y 7А 0z(x 7Х 0(y 7х 0z)=(x 7Х 0y) 7х 0z);  (б)  7А 0x(x 7Х 0e=e 7х 0x),

то для любых конечных списков xs

   ┌───────────────────────────────┐
   │ 3foldr 0 ( 7Х 0) e xs =  3foldl 0 ( 7х 0) e xs│.
   └───────────────────────────────┘

 ш1.2
   Говорят, что функции  7Х 0 и  7х 0  _ 1ассоциативны относительно друг друга . 0.
    2Доказательство 0.
    1Упражняйтесь 0.
   Первая теорема двойственности следует из второй, если операции  7Х
и  7х 0 совпадают.
    2Пример 0 ( 1иллюстрация второй теоремы двойственности 0).
 ш1.1
   Рассмотрим определения  функций length и reverse с помощью foldr
и foldl:
 ш1.0

   reverse' =  3foldr 0  7Х 41 0 e           ║  reverse' =  3foldl 0  7х 41 0 e
      where  7Х 41 0 = \x xs -> xs++[x]  ║     where  7х 41 0 = \ys x -> x:ys
            e 41 0 = []                ║           e 41 0 = []
                                   ║
   length' =  3foldr 0  7Х 42 0 e            ║  length' =  3foldl 0  7х 42 0 e
      where  7Х 42 0 = \x n -> n + 1     ║     where  7х 42 0 = \n x -> n + 1
            e 42 0 = 0                 ║           e 42 0 = 0

   Далее, очевидно, что

    7Х 41 ═+ 0(++),  7х 41 ═+ 0flip (:),  7Х 42 ═+ 0(+),  7х 42 ═+ 0(+), e 41 ═+ 0[], e 42 ═+ 00.

 ш1.1
   Остаётся проверить выполнимость условий  второй  теоремы  двойс-
твенности свёрток:
 ш1.0

   x 7Х 41 0(y 7х 41 0z)=(x 7Х 41 0y) 7х 41 0z => flip (:) (x++y) z = flip (:) (x++y) z =>

        => z : (x++y) = z : (x++y);

   x 7Х 41 0e 41 0=e 41 7х 41 0x => x++[] = flip (:) [] x => x++[] = x:[] => x = x;

   x 7Х 42 0(y 7х 42 0z)=(x 7Х 42 0y) 7х 42 0z => x+(y+z)=(x+y)+z => x+y+z=x+y+z,

   x 7Х 42 0e 42 0=e 42 7х 42 0x => x+0=0+x.

 ш1.2
    2Теорема 0 ( 1третья теорема двойственности для свёрток 0)
           [Bird,Wadler,1988,p.68-69].
 ш1.1
   Если  7Х 0 и  7Х 0~ - операции, удовлетворяющие условию
 ш1.0

   x 7Х 0~y=y 7Х 0x,

то для любого конечного списка xs

   ┌──────────────────────────────────────────┐
   │ 3foldr 0 ( 7Х 0) e xs =  3foldl 0 ( 7х 0~) e (reverse xs)│.
   └──────────────────────────────────────────┘

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
    2Пример 0 ( 1иллюстрация третьей теоремы двойственности 0).
 ш1.1
   Рассмотрим определения функции plusPlus с помощью foldr и foldl:
 ш1.0

   plusPlus = flip $  3foldr 0 (:),                               (*)

   plusPlus xs ys =  3foldl 0 (flip (:)) ys (reverse xs).         (**)

 ш1.1
   Выполним эквивалентные преобразования равенства  (*)  с  помощью
алгебры комбинаторов:
 ш1.0

   plusPlus xs ys = flip $  3foldr 0 (:) xs ys =

      = flip ( 3foldr 0 (:)) xs ys =  3foldr 0 (:) ys xs.

 ш1.1
   Сравнивая полученный результат с равенством (**), получим:
 ш1.0

    7Х ═+ 0(:),  7Х ═+ 0flip (:).

 ш1.1
   Остаётся проверить выполнимость условия третьей  теоремы  двойс-
твенности:
 ш1.0

   x 7Х 0~y=y 7Х 0x => x:y = flip (:) y x = x:y.

 ш1.2
    3Замечание 0.
 ш1.1
   Используя теоремы  двойственности для свёрток,  можно выразить с
помощью свёртки foldl многие функции, увеличивая их эффективность.
 ш1.2

                    3Законы объединения для свёртки

 ш1.0
                            1Ум - качество не скалярное, а векторное.
                                                             1Дж.Блох
 ш1.2

    21. 3  _ 1Законы fold-объединения . 0.
    2Теорема 0 [Bird,1998,p.131] ( 1закон объединения для foldr 0).
 ш1.1
   Если функция f обладает следующими свойствами:
   (а) она является  1строгой 0;
   (б) для всех x и y
 ш1.0

   f a = b, f (g x y) = h x (f y),

   ┌─────────────────────────┐
то │f .  3foldr 0 g a =  3foldr 0 h b│.
   └─────────────────────────┘

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
    2Теорема 0 [Bird,1998,p.131] ( 1закон объединения для foldl 0).
 ш1.1
   Если функция f обладает следующими свойствами:
   (а) она является  1строгой 0;
   (б) для всех x и y
 ш1.0

   f a = b и f (g x y) = h (f x) y

   ┌─────────────────────────┐
то │f .  3foldl 0 g a =  3foldl 0 h b│.
   └─────────────────────────┘

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
    22. 3  _ 1Законы fold-map-объединения
    2Теорема 0 [Bird,1998,p.132; Gibbons,2003,p.43]
           ( 1foldr-map объединение 0).
 ш1.0

   ┌───────────────────────────────────┐
   │ 3foldr 0 f e .  3map 0 g =  3foldr 0 (f . g) e│
   └───────────────────────────────────┘

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
    2Теорема 0 [Bird,Wadler,1988,p.72] ( 1foldl-map объединение 0).
 ш1.1
   Если x 7х 0y=x 7Х 0f y, то
 ш1.0

   ┌─────────────────────────────────┐
   │ 3foldl 0 ( 7Х 0) a .  3map 0 f =  3foldl 0 ( 7х 0) a│.
   └─────────────────────────────────┘

 ш1.2
    2Доказательство 0. Получается  из  foldr-map объединения и одной из
теорем двойственности ( 1какой 0?), а также из утверждения
 ш1.0

   map f . reverse = reverse . map f

 ш1.2
    1Теорема доказана 0.
    23. 3  _ 1Закон foldr-concat-объединения
    2Теорема 0 [Bird,1998,p.132] ( 1foldr-concat объединение 0).
 ш1.0

   ┌─────────────────────────────────────────────┐
   │ 3foldr 0 f e .  3concat 0 =  3foldr 0 (flip ( 3foldr 0 f)) e│.
   └─────────────────────────────────────────────┘

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
    24. 3  _ 1Закон foldr-map-concat-объединения
    2Теорема 0 [Bird,1998,p.132-133] ( 1foldr-map-concat объединение 0).
 ш1.1
   Если функция f является ассоциативной, e - единица функции f, то
 ш1.0

   ┌────────────────────────────────────────────────┐
   │ 3foldr 0 f e .  3concat 0 =  3foldr 0 f e .  3map 0 ( 3foldr 0 f e)│.
   └────────────────────────────────────────────────┘

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
    25. 3  _ 1Законы fold-scan-объединения
    2Теорема 0 [Bird,1998,p.134] ( 1foldr-scan объединение 0).
 ш1.1
   Если выполнены следующие условия:
   (1) операция  7х 0 является ассоциативной с единицей e;
   (2) операция  7х 0 дистрибутивна относительно операции  7Х 0, т.е.
 ш1.0

   x 7х 0(y 7Х 0z)=x 7х 0y 7Х 0x 7х 0z;

   (3) x ═* 0y=e 7Х 0(x 7х 0y),

   ┌──────────────────────────────────────┐
то │ 3foldr1 0 ( 7Х 0) .  3scanl 0 ( 7х 0) e =  3foldr 0 ( ═* 0) e│
   └──────────────────────────────────────┘

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
    2Теорема 0 [Bird,1998,p.137] ( 1foldl-scan объединение 0).
 ш1.1
   Если операции  ═* 0,  7Х 0,  7х 0 таковы, что
 ш1.0

   (x,y) ═* 0z=(x 7Х 0(y 7х 0z),y 7х 0z),

   ┌────────────────────────────────────────────────┐
то │ 3foldl1 0 ( 7Х 0) .  3scanl 0 ( 7х 0) e = fst .  3foldl 0 ( ═* 0) (e,e)│.
   └────────────────────────────────────────────────┘

 ш1.2
    2Доказательство 0.  1Упражняйтесь 0.

                      2Функционалы-конструкторы

 ш1.0
            1В области мысли,  при постоянном умственном общении вряд
            1ли  можно  точно разграничить,  что принадлежит одному и
            1что другому.  Зато каждый имеет удовлетворение и радость
            1сознавать своё участие в общем результате.
                 1И.П.Павлов. Из предисловия к книге "Лекции о работе
                             1больших полушарий головного мозга"
 ш1.2

   Приведём функционалы из библиотеки Prelude,  с  помощью  которых
легко описывается операционная семантика функционалов-свёрток и ко-
торые иногда называются  _ 1префиксными суммами . 0 или  _ 1бегущими  свёртками
(кстати,  отсюда возникают термины " 1бегущая сумма 0",  " 1бегущий мини-
 1мум 0" и т.п.).
                    21. 3 Функционалы scanl и scanl1
    2А. 0 Функционал 2  0scanl (англ.  1scan 0 - " 1сканировать, бегло просматри-
 1вать 0") применяет бинарный оператор к начальному значению и к каждо-
му последующему элементу заданного списка, формируя при этом список
промежуточных результатов:
 ш1.0

    2scanl 0:: (a -> b -> a) -> a -> [b] -> [a]
    2scanl 0  2funct k lst

 ш1.2
   Например:
 ш1.0

   > scanl (+) 0 [1,2,3,4,5]           > scanl (*) 2 [5,6,7]
   [0,1,3,6,10,15]                     [2,10,60,420]

   > scanl min (-5) [-1,2,-13,-4,-6]
   [-5,-5,-5,-13,-13,-13]

 ш1.2
   Функционал scanl определяется следующим образом:
 ш1.0

    3scanl 0 _ x0 []     = [x0]
    3scanl 0 f x0 (x:xs) = x0 :  3scanl 0 f (f x0 x) xs

 ш1.2
    2Теорема 0.
 ш1.0

    2(1) 0 last . scanl f e = foldl f e;

    2(2) 0 [Bird,1998,p.124]
       scanl f e = map (foldl f e) . inits

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
    2Б. 0 Функционал scanl1 применяет бинарный оператор к "голове"  за-
данного  непустого  списка  и  к каждому последующему его элементу,
формируя при этом список промежуточных результатов:
 ш1.0

    2scanl1 0:: (a -> a -> a) -> [a] -> [a]
    2scanl1 0  2funct lst

 ш1.2
   Например:
 ш1.0

   > scanl1 (+) [1,2,3,4,5]   > scanl1 (*) [5,6,7]
   [1,3,6,10,15]              [5,30,210]

   > scanl1 min [-1,2,-13,-4,-6]
   [-1,-1,-13,-13,-13]

 ш1.2
   Функционал scanl1 определяется следующим образом:
 ш1.0

    3scanl1 0 _ []     = []
    3scanl1 0 f (x:xs) =  3scanl 0 f x xs

 ш1.2
                    22. 3 Функционалы scanr и scanr1
    2А. 0 Функционал scanr применяет  бинарный  оператор  к  начальному
значению и к каждому последующему элементу заданного списка;  полу-
ченный результат записывается в формируемый список.
   Далее бинарный  оператор применяется к каждому последующему эле-
менту "хвоста" списка. Результат также записывается в список.
   Процесс продолжается  до  тех  пор,  пока хвост списка не станет
пустым; в этом случае возвращается исходное начальное значение:
 ш1.0

    2scanr 0:: (a -> b -> b) -> b -> [a] -> [b]
    2scanr 0  2funct k lst

 ш1.2
   Например:
 ш1.0

   > scanr (+) 0 [1,2,3,4,5]            > scanr (*) 2 [5,6,7]
   [15,14,12,9,5,0]                     [420,84,14,2]

   > scanr min (-5) [-1,2,-13,-4,-6]    > scanr (-) 0 [1,2,3,4,5]
   [-13,-13,-13,-6,-6,-5]               [3,-2,4,-1,5,0]

 ш1.2
   Функционал scanr определяется следующим образом:
 ш1.0

    3scanr 0 _ x0 []     = [x0]
    3scanr 0 f x0 (x:xs) = f x x' : (x' : xs')
          where (x':xs') =  3scanr 0 f x0 xs

 ш1.2
    2Теорема 0 [Bird,1998,p.125].
 ш1.0

   scanr f e = map (foldr f e) . tails

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
    2Б. 0 Функционал scanr1 применяет бинарный  оператор  к  последнему
элементу  заданного  непустого  списка и к каждому последующему его
элементу,  начиная с предпоследующего. Полученный результат записы-
вается в формируемый список.
   Далее бинарный  оператор применяется к каждому последующему эле-
менту хвоста списка и результаты также записываются в список.
   Процесс продолжается до тех пор, пока хвост списка не станет од-
ноэлементным; в этом случае возвращается оставшийся элемент списка:
 ш1.0

    2scanr1 0:: (a -> a -> a) -> [a] -> [a]
    2scanr1 0  2funct lst

 ш1.2
   Например:
 ш1.0

   > scanr1 (+) [1,2,3,4,5]        > scanr1 (*) [5,6,7]
   [15,14,12,9,5]                  [210,42,7]

   > scanr1 min [-1,2,-13,-4,-6]
   [-13,-13,-13,-6,-6]

 ш1.2
   Функционал scanr1 определяется следующим образом:
 ш1.0

    3scanr1 0 _ []     = []
    3scanr1 0 _ [x0]   = [x0]
    3scanr1 0 f (x:xs) = f x x' : (x' : xs')
          where (x':xs') =  3scanr1 0 f xs

 ш1.2
    2Пример 0.
 ш1.1
   Построим функцию,  которая  позволяет  проследить  за  процессом
конструирования результата выполнения "бегущих свёрток:
 ш1.0

> paren' :: String -> String -> String
> paren' x y = concat ["(",x," * ",y,")"]
> ---------------------------------------
> test7  = scanr paren' "1" ["a","b","c"]
>          == ["(a * (b * (c * 1)))","(b * (c * 1))","(c * 1)","1"]
> test8  = scanl paren' "1" ["a","b","c"]
>          == ["1","(1 * a)","((1 * a) * b)","(((1 * a) * b) * c)"]
> -----------------------------------------------------------------
> test9  = scanr1 paren' ["a","b","c"]
>                                == ["(a * (b * c))","(b * c)","c"]
> test10 = scanl1 paren' ["a","b","c"]
>                                == ["a","(a * b)","((a * b) * c)"]

 ш1.2
   Фактически функционалы  scanl и scanr реализуют своеобразную  1ме-
 1моизацию 0.
    2Определение 0.
 ш1.1
    2(1) 0  _ 1Мемоизация . 0 [Орлов,2013,с.91] - это специальная оптимизацион-
ная методика программирования, которая позволяет увеличить скорость
выполнения компьютерных программ и заключающаяся в том,  чтобы иск-
лючить повторное вычисление результатов предыдущих вызовов процедур
и функций.
    2(2) 0  _ 1Мемоизация . 0 [Марков,2016,с.138] - это способ увеличения  ско-
рости выполнения  программ за счёт запоминания результатов промежу-
точных вычислений.  Такой способ работает тогда, когда одни и те же
промежуточные результаты  неоднократно требуются при дальнейших вы-
числениях. Мемоизация,  как правило,  используется в реализации ре-
курсивных вычислений.
 ш1.2

                 2Определение функций и функционалов
                          2с помощью свёртки

 ш1.0
                               1Ладно, я покажу им, как это делается.
                                                  1Эдуард Мане 0 ( 11862 0)
 ш1.2

    2Определение 0.
 ш1.1
    2(1) 0  _ 1Программирование в стиле оригами . 0 - это  технология  функцио-
нального программирования, в которой используемые функции представ-
лены в виде:
   (а) ( 1foldr-стиль 0,  1cata-стиль 0) паттерна, использующего свёртку:
 ш1.0

   func ... lst = 3 foldr 0  ═f 0 e lst  ║  length' lst = foldr f e lst
      where  ═f 0 = \a b -> ...      ║     where f x n = 1 + n
            e = ...              ║           e     = 0

 ш1.1
   При этом вместо функционала  3foldr 0  могут  использоваться   3foldl 0,
 3foldr1 0,  3foldl1 0;
   (б) ( 1unfold-стиль 0,  1ana-стиль 0) паттерна, использующего развёртку:
 ш1.0

   func ... x = 3 unfold 0 p  ═f 0 g x  ║  infinity = unfold p f g 1
      where p = \x -> ...       ║      where p = \x -> False
             ═f 0 = \x -> ...       ║            f = id
            g = \x -> ...       ║            g = succ

 ш1.1
   (в) ( 1foldr-unfold-стиль 0,   1hylo-стиль 0)  паттерна,   использующего
свёртку и развёртку:
 ш1.0

   func ... x = 3  0( 3foldr 0  ═f 41 0 e .  3unfold 0 p  ═f 42 0 g) x
      where  ═f 41 0 = \a b -> ...
            e  = ...
            p  = \x -> ...
             ═f 42 0 = \x -> ...
            g  = \x -> ...

 ш1.1
   (г) ( 1unfold-foldr-стиль 0) паттерна,  использующего свёртку и раз-
вёртку:
 ш1.0

   func ... x = 3  0( 3unfold 0 p  ═f 42 0 g .  3foldr 0  ═f 41 0 e) x
      where p  = \x -> ...
             ═f 42 0 = \x -> ...
            g  = \x -> ...
             ═f 41 0 = \a b -> ...
            e  = ...

 ш1.1
   (д) ( 1fix-foldr-стиль 0) паттерна, использующего свёртку:
 ш1.0

   func ... x =  3foldr 0 f e x
       where f = \_ -> g
             e = undefined
             g = ...

 ш1.1
   Здесь функция g является нерекурсивной "заготовкой",  полученной
из рекурсивного определения функции func;

 ш1.1
   (е) ( 1fix-foldl-стиль 0) паттерна, использующего свёртку:
 ш1.0

   func ... x =  3foldl 0 f e [1..10000]
       where f = \x _ -> g x
             e = undefined
             g = ...

 ш1.1
   Числовой список [1..10000] подбирается эмпирически,  а функция g
является нерекурсивной "заготовкой", полученной из рекурсивного оп-
ределения функции func;
   (ж) ( 1fix-foldr-unfold-стиль 0)  паттерна,  использующего свёртку и
развёртку:
 ш1.0

   func ... = 3 foldr 0  ═f 0 e 1  0.  3unfold 0 p  ═f 41 0 g 41
      where  ═f 0  = ($)
            e  = undefined
            p  = \x -> False
             ═f 41 0 = id
            g 41 0 = id

 ш1.1
    2(2) 0  _ 1Haskell-оригами . 0 будем называть программирование в стиле ори-
гами на языке Haskell.

 ш1.2
    3Замечание 0.
 ш1.1
   Стиль foldr-unfoldr  хорошо подходит для языков программирования
с отложенными вычислениями,  поскольку в связке fold-unfold функции
свёртки и развёртки работают синхронно,  т.е.  функция развёртки не
производит новых элементов до тех пор,  пока они не понадобятся  во
внешней функции свёртки.

 ш1.2
                 21. 3 Использование функционала foldr
   Вначале напомним,  что применение инфиксной операции  7Х 0 в круглых
скобках ( 7Х 0) преобразует операцию в префиксную  форму.  Этот  приём,
называемый   _ 1секционированием . 0,  часто  является  полезным при записи
простых функций с использованием свёртки.  (Если требуется, то один
из аргументов операции может быть также заключён в круглые скобки).
   Далее отметим, что функции, написанные с использованием свёртки,
являются  _ 1менее удобочитаемыми . 0,  чем функции, написанные с использо-
ванием явной рекурсии. Однако программы, написанные с использовани-
ем foldr, более удобны для:
   (а) эквивалентных (тождественных) преобразований функций;
   (б) доказательства свойств функций.
    21. 0 Ряд функций,  действующих на списках, могут быть легко реали-
зованы с использованием свёртки:
 ш1.0

   sum':: [Int] -> Int     1  0 ║  product':: [Int] -> Int
   sum' = foldr (+) 0      1  0 ║  product' = foldr (*) 1
   ----------------------- 1- 0--------------------------
   and':: [Bool] -> Bool   1  0 ║  or':: [Bool] -> Bool
   and' = foldr (&&) True  1  0 ║  or' = foldr (||) False
   ----------------------- 1- 0--------------------------
   concat:: [[a]] -> [a]   1  0 ║  head:: [a] -> a
   concat = foldr (++) []  1  0 ║  head = foldr const (error "Empty")
   ------------------------ 1- 0-------------------------------------
   (++):: [a] -> [a] -> [a]
   (++) ys    = foldr (:) ys
   -------------------------
   (++):: [a] -> [a] -> [a]
   xs (++) ys = foldr (:) ys xs

 ш1.2
   В приведённых примерах конструктор (:) заменён некоторой  встро-
енной  функцией.  Однако,  в большинстве случаев применения свёртки
конструктор (:) заменяется функциями, определёнными пользователем и
реализованными с использованием  7l 0- _ 1абстракции . 0.
   Например:
 ш1.0

   length':: [a] -> Int
   length' = foldr (\x n -> 1 + n) 0
   ---------------------------------
   reverse':: [a] -> [a]
   reverse' = foldr (\x xs -> xs ++ [x]) []

 ш1.2
    22. 0 Реализуем с помощью свёртки часто встречающиеся  1функционалы 0.
 ш1.0

   map':: (a -> b) -> [a] -> [b]
   map' f = foldr (\x xs -> f x : xs) []
   -------------------------------------
   map'' f = foldr ((:) f) []

 ш1.2
   Интересно (!?),  что определение map' с  использованием  свёртки
может быть построено из обычного рекурсивного определения.
 ш1.0

   filter':: (a -> Bool) -> [a] -> [a]
   filter' p = foldr (\x xs -> if p x then x : xs else xs) []

 ш1.2
   Выражение функций и функционалов с помощью функционала foldr бы-
вает настолько  нетривиальным,  что,  например,   1Р.Бёрд 0 [Bird,1998,
с.121] писал,  что функционал zip  невозможно  выразить  с  помощью
foldr: "Not  every  function on lists can be defined as an instance
of  1foldr 0.  For example,   1zip 0 cannot be so defined.  Even for  those
that can, an alternative definition may be more efficient."
   Однако впоследствии он указал вариант представления:
 ш1.0

   zip' = foldr f e
       where e ys         = []
             f x g []     = []
             f x g (y:ys) = (x,y) : g ys

 ш1.2
   Функционал dropWhile нельзя выразить с помощью свёртки foldl та-
ким образом,  чтобы он корректно "работал" для всех списков (в  том
числе и для бесконечных). Однако имеется следующее представление:
 ш1.0

   dropWhile' p xs = foldr f id xs xs
        where f x g xs@(_:ys) | p x  = g ys
                              | True = xs

 ш1.2
   Выразим с помощью foldr свёртку foldl ( 1два способа 0):
 ш1.0

   foldl':: (a -> b -> a) -> a -> [b] -> a
   foldl' f s xs = foldr (\x g -> (\a -> g (f a x))) id xs s
   ---------------------------------------------------------
   foldl''  f s xs = foldr (\a -> (. flip f a)) id xs s
   foldl''' f      = flip (foldr (\a -> (. flip f a)) id)

 ш1.2
    23. 0 Построим функцию  compose,  которая  конструирует  композицию
функций  из заданного списка функций:  воспользуемся свёрткой с по-
мощью замены каждого конструктора (:) в  списке,  функцией  (.),  а
пустой список [] - стандартной функцией id:
 ш1.0

   compose':: [a -> a] -> a -> a
   compose' = foldr (.) id

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   Пример 2.

 ш1.2
    1Правая свёртка на списках 0 используется, когда известно, как  со-
ставить результат для всего списка из его "головы" и результата для
"хвоста", причём часть результата известна и без полного результата
для "хвоста", т.е. вычисляется лишь на основе "головы" (например, в
случае map или filter).
                 22. 3 Использование функционала foldl
   Приведём примеры представления функций с помощью foldl:
 ш1.0

   sum'  = foldl (+) 0
   sum'' = foldl (\x y -> x + y) 0
   -------------------------------
   concat = foldl (++) []         ( 1Медленная реализация 0!)
   ----------------------
   reversel:: [a] -> [a]
   reversel = foldl (\xs x -> x:xs)
                    []
   ----------------------        ║
   reversel':: [a] -> [a]        ║  flip (:) xs x = (:) x xs =
   reversel' = foldl (flip (:))  ║       = x : xs = \xs x -> x : xs
                     []          ║

 ш1.2
   Определение функции reversel позволяет обратить список  _ 1за линей-
 _ 1ное время . 0 (т.е. алгоритм имеет эффективность  7O 0(n)).
   Для "обоснования"  воспользуемся  интерпретатором  Haskell в ка-
честве "песочницы":
 ш1.0

   > reversel [1..100] =>  4546 cells
   > reversel [1..200] =>  9046 cells
   > reversel [1..400] => 18046 cells
   > reversel [1..800] => 36046 cells

 ш1.2
   Итак, последняя функция предпочтительнее, чем запись с использо-
ванием foldr:
 ш1.0

   reverse' = foldr (\x xs -> xs ++ [x]) [],

 ш1.2
т.к. в этом случае многократно используется операция ++.
   Выразить свёртку foldr через foldl  _ 1невозможно . 0,  т.к. foldl опре-
деляется строго в хвосте списка своих аргументов, а foldr - нет.
                3Работа с демонстрационными примерами
 ш1.1
   Пример 3.

 ш1.2
    1Левая свёртка на списках 0 используется, когда алгоритм выражается
в виде правой свёртки,  если список перевернуть.  Эта разновидность
свёртки используется редко.
   Наконец ( 1для знатоков строгой аппликации 0),  1строгая левая свёртка
используется, когда алгоритм выражается в виде императивного цикла.
    3Замечание 0 ( 1важное 0) (см. [Bird,1998]).
 ш1.1
   Существуют рекомендации,  помогающие  определить,  какая свёртка
лучше подходит для решения конкретной задачи.
 ш1.2

                3Моделирование комбинатора неподвижной
                         3точки в foldr-стиле

 ш1.0
             1Ни рука, ни интеллект, предоставленный себе, многого не
             1стоят 0: 1 дело совершается при помощи орудий и средств.
                                                             1Ф.Бэкон
 ш1.2

   Использование свёртки в качестве комбинатора  неподвижной  точки
берёт начало из теоретико-категорной работы [Freyd,1990], в которой
показано, что такой комбинатор может быть выражен в виде композиции
 1катаморфизма 0 и  1анаморфизма 0.
   В работе [Meijer,Hutton,1995] эти результаты переводятся на язык
функционального  программирования  и формулируются для произвольных
алгебраических типов данных.
   Итак, свёртку  можно  использовать в качестве комбинатора непод-
вижной точки; другими словами, можно написать функцию, моделирующую
комбинатор неподвижной точки Y с помощью функционала foldr:
 ш1.0

   fix = \f ->  3foldr 0 (\_ -> f) undefined (repeat undefined)

 ш1.2
   Теперь (как обычно!) с помощью fix можно  выполнить  необходимое
количество вызовов  1нерекурсивной функции 0, моделируя рекурсию.
    2Пример 0.
 ш1.1
   Комбинатор неподвижной  точки  помогает  построить   рекурсивную
функцию  из  нерекурсивных  "заготовок",  полученных из рекурсивных
функций:
 ш1.0

   foldr' f e []     = e              foldr''  _f1 . f e []     = e
   foldr' f e (x:xs) =            =>  foldr''  _f1 . f e (x:xs) =
             x `f` foldr' f e xs                x `f`  _f1 . f e xs

   foldl' f e []     = e          =>  foldl''  _f1 . f e []     = e
   foldl' f e (x:xs) =                foldl''  _f1 . f e (x:xs) =
             foldl' f (e `f` x) xs               _f1 . f (e `f` x) xs

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 4 41 0.

 ш1.2
   Итак, зная рекурсивную схему для функции  ═f 0,  можно построить для
неё нерекурсивную "заготовку" - функцию  ═f 5* 0,  а далее для вычисления
значений функции f уже пользоваться функцией fix  ═f 5* 0.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 4 42 0.

 ш1.2
   Заметив, что с помощью развёртки  легко  получается  бесконечный
список [1..]:
 ш1.0

   infinity = unfold (\x -> False) id succ 1,

 ш1.2
получим следующее представление в fold-unfold-стиле:
 ш1.0

   y = \f ->  3foldr 0 (\_ -> f) undefined
                   ( 3unfold 0 (\x -> False) id succ 1)

 ш1.2
   Впрочем, на практике выражение рекурсивных  функций  в  терминах
свёртки вряд ли полезно: ясно, что замена рекурсии на свёртку может
привести к значительному усложнению кода.
    3Замечание 0 ( 1важное 0).
 ш1.1
   Теоретический интерес представляют выражения комбинатора  непод-
вижной точки в  1foldl- 0 и в  1unfold-стиле 0.
 ш1.2

                      3Сбалансированная свёртка

 ш1.0
               1Часть работы программиста состоит в том, чтобы решать
               1сегодняшние  задачи.  Другая,  возможно более важная,
               1состоит в подготовке к решению завтрашних задач. 0
                                                          1Дж. Бентли
 ш1.2

   Для ассоциативных операций результаты вычисления выражений
 ш1.0

   foldr (+) [a 41 0...a 4n 0] = a 41 0+(a 42 0+...+(a 4n-1 0+a 4n 0)...),

   foldl (+) [a 41 0...a 4n 0] = (...(a 41 0+a 42 0)+...)+a 4n

 ш1.2
совпадают. Более того,  расставляя скобки произвольным образом,  мы
будем получать все тот же результат.
   Другими словами,  можно абстрагироваться от порядка вычислений и
говорить об "абстрактной" свертке как о результате выражения
 ш1.0

   fold (+) [a 41 0...a 4n 0] = a 41 0 + a 42 0 +...+ a 4n

 ш1.2
безотносительно к порядку выполнения операций.
   Теперь мы можем конкретизировать эту абстракцию, установив опре-
делённый порядок вычислений.
   Например, определим  _ 1сбалансированную . 0 ( _ 1древесную . 0)  _ 1свёртку . 0, произ-
водящую вычисления в таком порядке
 ш1.0

   foldb (+) [a 41 0...a 4n 0] = (...((a 41 0+a 42 0)+(a 43 0+a 44 0))+(...(a 4n-1 0+a 4n 0)...).

 ш1.2
   Сбалансированную свёртку  можно  выполнять  в направлении сверху
вниз:
 ш1.0

   foldb f [x] = x
   foldb f xs  = f (foldb f (take (length xs `div` 2) xs))
                   (foldb f (drop (length xs `div` 2) xs))

или в направлении снизу вверх:

   foldb' f [x] = x
   foldb' f xs  = foldb' f (pair f xs)
   -----------------------------------
   pair f []         = []
   pair f [x]        = [x]
   pair f (x1:x2:xs) = f x1 x2 : pair f xs

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 6.

                       2Функционал "развёртка"

 ш1.0
                    1Глаз должен выучиться видеть, как язык говорить.
                                                             1Д.Дидро
 ш1.2

                       21. 3 Основные определения
   Функционал " 1развёртка 0" охватывает достаточно общий образец гене-
рации списков 1.
    2Определение 1 0.
 ш1.1
    _ 1Функционал . 0 " _ 1развёртка . 0" определяется следующим паттерном рекурсии:
 ш1.0

   unfold:: (a -> Bool) -> (a -> b) -> (a -> a) -> a -> [b]
   unfold p f g x | p x  = []
                  | True = f x : unfold p f g (g x)

   Другими словами,

   head $ unfold p f g x = f x,
   tail $ unfold p f g x = unfold p f g (g x),
   null $ unfold p f g x = p x.

 ш1.2
   Опишем шутливо  _ 1операционную семантику . 0 функционала: на каждом ша-
ге функция unfold "скармливает" предикату p  аргумент  x,  а  потом
спрашивает:  "Понравилось?".  Если "понравилось" (функция p вернула
True), то "кормёжка" прекращается и возвращается пустой список.
   Если же  "не понравилось" (функция p вернула False),  то функция
возвращает результат (f x) и "заказывает",  чем её "кормить" в сле-
дующий раз (т.е. вычисляет g x).
   Затем unfoldr собирает результаты в список и возвращает его.
    2Пример 0.
 ш1.1
   Представим процесс вычисления значения функции
 ш1.0

   enum n m = unfold (>m) id succ

 ш1.1
для значений аргументов n=1, m=3 в виде следующего рисунка:
 ш1.0

               1 ───── 76 0 2 ───── 76 0 3 ───── 76 0 4 ───── 76 0 []
               │   51>3 0   │   52>3 0   │   53>3 0       54>3
    1Полученный 0   7^ 1  0        7^ 0         7^
      1список 0     21 0         22 0         23

 ш1.2
    2Теорема 0 (по [Bird,Wadler,1988,p.173]).
 ш1.0

    3unfold 0 p f g =  3map 0 f .  3takeWhile 0 (not . p) .  3iterate 0 g

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 5 41 0.

 ш1.2
    2Теорема 0 ( 1универсальное свойство unfold 0) [Gibbons,2003,p.45].
 ш1.0

    3h 0 =  3unfold 0 p f g <=>  3h 0 x | p x  = []
                            | True = f x :  3h 0 (g x)

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
    2Теорема 0 ( 1свойство объединения unfold, fusion law 0)
           [Gibbons,2003,p.45].
 ш1.0

    3unfold 0 p f g . h =  3unfold 0 p' f' g' <=

                   <= p . h = p', f . h = f', g . h = h . g'.
                       ═└ 0─── ═┬ 0──── ═┘ 0   ═└ 0─── ═┬ 0──── ═┘ 0   ═└ 0───── ═┬ 0────── ═┘

 ш1.2
    2Доказательство 0.
    1Упражняйтесь 0.
   Определим функционал  " 1развёртка 0"  с  помощью паттерна рекурсии,
использующего функцию, называемую  _ 1конструктором пары . 0.
    2Определение 2 0.
 ш1.0

   unfold':: (a -> Bool) -> (a -> (b,a)) -> a -> [b] 
   unfold' p fg x | p x  = []
                  | True = fx : unfold' p fg gx
       where (fx,gx) = fg x

 ш1.1
   Другими словами,
 ш1.0

   fg = \x -> (f x, g x)

 ш1.1
где элементы списка порождаются функцией f,  а начальный элемент  x
преобразуется функцией g.

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 5 42 0.

 ш1.2
                       22. 3 Обобщение развёртки
   Рассмотрим следующее обобщение функционала " 1развёртка 0":
 ш1.0

    3ana 0 q r p f g x = if p x
                       then r x
                       else q (f x) ( 3ana 0 q r p f g (g x))

 ш1.2
   Установим представления свёртки и развёртки на списках с помощью
указанного выше обобщения.
 ш1.0

    3foldr 0 f e =  3ana 0 f (\x -> e) null head tail

    3unfold 0    =  3ana 0 (:) (\x -> [])

 ш1.2
    2Теорема 0 ( 1лёгкая 0).
 ш1.1
   Имеют место следующие  1эквациональные утверждения 0:
 ш1.0

    2(1) 0  3foldr 0 f e =  3ana 0 f (\x -> e) null head tail.

    2(2)  3unfold 0    =  3ana 0 (:) (\x -> []).

 ш1.2
    2Доказательство 0.
 ш1.0

    21. 0  3ana 0 f (\x -> e) null head tail x =
       = if null x
           then (\x -> e) x
           else f (head x) ( 3ana 0 f (\x -> e) null head tail (tail x))
       = if null x
           then e
           else f (head x) ( 3ana 0 f (\x -> e) null head tail (tail x))
       = fold f e,

где fold f e x = if null x
                   then e
                   else f (head x) (fold f e (tail x)).

    22. 0  3ana 0 (:) (\x -> []) p f g x =
            = if p x
                then (\x -> []) x
                else (:) (f x) ( 3ana 0 (:) (\x -> []) p f g (g x)) =
            = if p x
                then []
                else f x :  3ana 0 (:) (\x -> []) p f g (g x) =
            = unfold p f g x.

 ш1.2
    1Теорема доказана 0.

                        3Технология MapReduce

 ш1.0
                                   1Носорог очень плохо видит, но при
                                   1его весе это уже не его проблемы.
                                                               1Шутка
 ш1.2

   Оказалось, что  очень большое количество задач над большими объ-
ёмами данных можно представить в виде комбинации функций map и  re-
duce, где reduce - это свёртка для ассоциативной операции (+).
   В 2004  инженеры  компании Google [Dean,Ghemawat,2004] выступили
на конференции с докладом о  _ 1технологии MapReduce . 0;  они  разработали
систему,  позволившую  программистам отвлечься от побочных задач по
управлению данными,  обработке ошибок  и  т.д.,  и  сосредоточиться
только на разработке алгоритмов.
   Входные данные  поступают  в  систему в виде пар (Ключ,Значение)
(k 41 0,v 41 0). Функция f 41 0 (называется " 1mapper 0") превращает каждую пару  в
список пар [(k 42 0,v 42 0)], являющимся промежуточным результатом.
   Функция sort сортирует промежуточные пары по ключам k 42 0.
   На вход  функции  f 42 0  (называется  " 1reducer 0") подаются пары вида
(k 42 0,[v 42 0]), где [v 42 0] - это список  значений,  соответствующих  ключу
k 42 0. Результатом функции f 42 0 является список выходных значений v 43 0.
   Итак, задачей программиста является построение двух функций:
 ш1.0

   mapper :: (k 41 0,v 42 0) -> [(k 42 0,v 42 0)], reducer :: (k 42 0,[v 42 0]) -> [v 43 0]

 ш1.2
   Технология MapReduce является разработкой компании Google.
   Тем не менее, существует открытая реализация этой идеи в системе
Hadoop (именно кластеры Hadoop используются для обработки данных  в
таких компаниях, как Yahoo!, Facebook, IBM).
   Покажем, как  в  технологии MapReduce решается следующая класси-
ческая задача:   1для заданного массива слов вычислить частоту  упот-
 1ребления каждого слова 0.  Предполагаем, что размер данных таков, что
для решения требуется параллелизация.
   Решение задачи представим в виде комбинации функций map и foldr:
 ш1.1
   (1) каждое слово w из исходного массива представим в  виде  пары
(w,1):
 ш1.0

> lst  = words "asd asd asd asd asd zxc zxc asd" -- Список слов
> fun = map (\x -> (x,1)) lst

 ш1.1
   (2) пары сортируются,  используя первый элемент в качестве ключа
(они фактически группируются определённым образом):
 ш1.0

> fun1 = sort $ map (\x -> (x,1)) lst
> fun2 = groupBy (\x y -> fst x == fst y)
>                (sort $ map (\x -> (x,1)) lst)

 ш1.1
   Отметим, что функцию (\x y -> fst x == fst y) можно упростить  с
помощью  7h 0-редукции и вспомогательной функции on:
 ш1.0

> -------------------------------------------------------
> -- Вспомогательная функция, моделирующая комбинатор psi
> -------------------------------------------------------
> on g f x y = g (f x) (f y)

   \x y -> fst x==fst y = \x y -> (==) (fst x) (fst y) =
                        = \x y -> on (==) fst x y = on (==) fst;

 ш1.1
   (3) все пары с одинаковым ключём подаются на вход функции, кото-
рая суммирует вторые элементы, вычисляя частоту употребления слов:
 ш1.0

> fun3 = map (\lst -> foldr (\x y -> (fst x, snd x + snd y))
>                           ("_",0) lst)
>            fun2

 ш1.1
   Приведём варианты решения подобной задачи,  не использующие тех-
нологию MapReduce:
 ш1.0

> -- ***************************************************
> -- Функции реализуют частотный анализ букв текста word
> -- и возвращает списки пар вида:
> --
> --  (1) ([Символ],Частота появления в слове),
> --  (2) (Частота появления в слове,[Символ])
> --
> -------------------------------------------------------
> prob :: (Ord a, Fractional a) => [Char] -> [([Char],a)]
> prob word = sort [(x:"",
>                    fromInt (length (findIndices (==x) word)) /
>                    (fromInt (length word)))
>                  | x <- nub word]
> --------------------------------------------------------
> prob' :: (Ord a, Fractional a) => [Char] -> [(a,[Char])]
> prob' word = sort [(fromInt (length (findIndices (==x) word)) /
>                                        (fromInt (length word)),
>                     x:"")
>                   | x <- nub word]
> ----------------------------------------
> lst1 = "asd asd asd asd asd zxc zxc asd"
> test11 = prob  lst1
> test12 = prob' lst1

 ш1.2
   Интересно, насколько  широк  класс задач,  для которых можно ис-
пользовать технологию MapReduce?

                       2Теоремы о гомоморфизмах
                      21. 0  3Понятие "гомоморфизм"

 ш1.0
                                 1Контекстом слова является весь мир.
                                          1Е.Лец. Непричёсанные мысли
 ш1.2

   Д.Пойа писал (см. [Ахо,Ульман,1978,с.243-244]), что  гомоморфизм
есть  "своего рода систематический сокращенный перевод...  Тонкости
при этом сокращении могут быть потеряны,  но всё, что есть в ориги-
нале,  чем-то представлено в переводе, и в уменьшенном масштабе со-
отношения сохраняются".
   Обычно гомоморфизм объясняют как отображение из "богатых" струк-
тур в "бедные", при котором сохраняются алгебраические законы отоб-
ражаемых структур.
    2Определение 0 ( 1содержательное 0).
 ш1.1
    2(1) 0 [Математический,1995,с.160]   _ 1Гомоморфное отображение . 0,   _ 1гомо-
 _ 1морфизм . 0 (от греч.  7omoz  0-  1равный, одинаковый 0 и  7morfh  0-  1форма 0,  1образ 0)
- это отображение, определённое на паре алгебраических систем и яв-
ляющееся отображением множества элементов одной системы  в  другую,
 1сохраняющим 0 все операции и предикаты системы.
    2(2) 0 (По [Кауфман,1993,с.374-378])  _ 1Гомоморфизм . 0 - это отображение,
 1сохраняющее 0  свойства  всех  операций  из области отправления в том
смысле что:
   (а) каждой из них соответствует некоторый "гомоморфный образ";
   (б) результат каждой из них отображается в результат  применения
гомоморфного  образа  операции  к гомоморфному образу её аргумента,
что представимо следующей   1коммутативной  диаграммой 0  ("коммутатив-
ность" означает,  что  из  левого  нижнего  угла диаграммы в правый
верхний можно пройти любым из путей,  указанных стрелками, с одина-
ковым результатом):
 ш1.0

    1Результат 0              1Образ результата
        f(x) ∙──────── 76 0∙ g(f(x))=g(f)(g(x))
              7% 0          7%
             │         │
             │         │
           x ∙──────── 76 0∙ g(x)
     1Аргумент 0             1Образ аргумента

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   В математике существует тенденция к замене термина " 1гомоморфизм 0"
термином " 1морфизм 0".  поэтому можно сказать,  что  _ 1гомоморфизм . 0 -  это
 1морфизм 0 в категории алгебраических систем; отображение алгебраичес-
кой системы, сохраняющее основные операции и основные соотношения.

 ш1.2
   Важно заметить, что понятие " 1гомоморфизм 0" удачно моделирует мно-
гие важнейшие понятия программирования.  Конечно, содержательно все
они связаны с тем или иным представлением о "корректном  развитии",
"корректном обогащении" ранее созданного, рассмотренного, изученно-
го и т.п.
    3Замечание 0 [Кауфман,1993,с.374-378].
 ш1.1
   Для программирования особенно интересна (обратная, двойственная)
интерпретация гомоморфизма как отношения между "бедной" и "богатой"
структурами,  при котором в последней сохраняются все свойства опе-
раций, сохраняемых из первой.  В сущности,  это есть  1отношение иде-
 1ального наследования 0.
   Итак,  _ 1гомоморфизм из обогащенного типа в исходный . 0 - это  естест-
венное математическое представление (математическая модель) идеаль-
ного наследования.
 ш1.2

                 22. 0  3Понятие "списочный гомоморфизм"

 ш1.0
                                     1Приближаясь к истине, мы иногда
                                     1удаляемся 0  1от 0  1действительности.
                                          1Е.Лец. Непричёсанные мысли
 ш1.2

   Рассмотрим функции sum,  min, length, аргументом каждой из кото-
рых является список значений. Если разбить список (являющийся аргу-
ментом) на две части,  то значение каждой из этих функций можно вы-
числить от каждой части, а затем объединить вычисленные значения.
   Другими словами,  1существует 0 такая бинарная операция (), что
 ш1.0

   h (x ++ y) = h x  h y,                                     (*)

 ш1.2
где h - одноместная функция, (++) - операция конкатенации списков.
   Очевидно, что операция () должна быть ассоциативной, в силу ас-
социативности операции (++).
   Функция h в этом случае называется  1списочным гомоморфизмом 0.
   Понятие " 1списочный гомоморфизм 0" было введено профессором  Р.Бёр-
дом (Оксфордский университет).
    2Примеры 0.
 ш1.0

    21. 0 sum    (x ++ y) = sum x    + sum y
    22. 0 length (x ++ y) = length x + length y.

 ш1.2
   Нашей задачей является обнаружение необходимых и достаточных ус-
ловий того, что некоторая функция удовлетворяет условию (*).
   Эти условия называются  1теоремами о гомоморфизмах 0.

    2А 0. () 1- _гомоморфные функции . 0.
    2Определение 0 [Gibbons,1995].
 ш1.1
   Будем говорить,  что  списочная  _ 1функция . h  _является . 0 () _ 1-гомоморф-
 _ 1ной . 0,  если для любых конечных списков x и y  1существует 0 функция  ()
такая, что
 ш1.0

   h (x ++ y) = h x  h y,

где () - ассоциативная операция, а (h []) - единица операции ().

 ш1.2
    2Лемма 0.
 ш1.1
   Если операция () не имеет единицы,  то значение (h []) не опре-
делено.  Если значение (h []) определено,  то единицей операции ()
является (h []).

 ш1.2
    2Доказательство 0. Воспользуемся    1контрапозицией 0:  пусть  значение
(h []) определено, тогда
 ш1.0

   h y  7= 0 h ([] ++ y) = h [] () h y,

 ш1.2
и операция () имеет единицу, которой является (h []).
    1Лемма доказана 0.
    2Пример 0.
 ш1.1
   Функция head является const-гомоморфной,  но  функция  const  не
имеет единицы, поэтому значение head [] не определено.

 ш1.2
    2Определение 0 [Gibbons,1995].
 ш1.1
   Пусть () - ассоциативная функция с  _ 1единицей . 0 e, [·] x 7  ═+ 7  0[x].
   Будем обозначать ()-гомоморфную функцию h следующим образом:
 ш1.0

    3hom 0 () (h ═O 0[·]) (h []) =  3hom 0 () f e.
             ═└ 0─ ═┬ 0─ ═┘ 4f 0   ═└┬ 0─ ═┘ 4e

 ш1.2
    2Примеры 0.
 ш1.0
    21. 0 Функция sum является (+)-гомоморфной функцией, т.к. для любых
конечных списков x и y
 ш1.0

                    sum [] = 0
                     7^
   sum =  3hom 0 (+) id 0.
                  7%
                 sum ═O 0[·] =  7l 0x.(sum ═O 0[·]) x =  7l 0x.sum [x] =  7l 0x.x = id

 ш1.1
    22. 0 Функция  length является (+)-гомоморфной функцией,  т.к.  для
любых конечных списков x и y
 ш1.0

                        length []=0
                            7^
   length =  3hom 0 (+) ( 7l 0x.1) 0.
                      7%
               length ═O 0[ 77 0] =  7l 0x.(length ═O 0[ 77 0]) x =  7l 0x.length ([ 77 0] x) =
                          =  7l 0x.length [x] =  7l 0x.1.

 ш1.1
    23. 0 Функция  head является  1const 0-гомоморфной функцией,  т.к.  для
любых конечных списков x и y
 ш1.0

   head (x ++ y) = const (head x) (head y) = head x.

 ш1.1
   Другими словами,
 ш1.0

                         head [] не определено
                            7^
   head = 3 hom 0 const id undefined,
                     7%
                 h ═O 0[·] =  7l 0x.(head ═O 0[·]) x =  7l 0x.head [x] =  7l 0x.x = id.
 ш1.2

    2Б 0.  7х 0- _ 1правосторонние функции . 0.
    2Определение 0 [Gibbons,1995].
 ш1.1
   Будем говорить,  что списочная  _ 1функция . h  _является . 0  7х _ 1-правосторон-
 _ 1ней . 0 (англ.   1rightwards 0), если для любого значения a и любого списка
x существует бинарная функция  7х 0 такая, что
 ш1.0

   h (x ++ [a]) = h x  7х 0 a.

 ш1.2
   Важно заметить, что функция ( 7х 0) не обязана быть ассоциативной.
    2Лемма 0.
 ш1.1
    7х 0-правосторонняя функция h имеет следующее представление:
 ш1.0

   h = foldl ( 7х 0) (h []).

т.е. функция h представима в виде  1левой свёртки 0.

 ш1.2
    2Доказательство 0. Воспользуемся определением функции foldl и опре-
делением  7х 0-правосторонней функции h:
 ш1.0

   foldl ( 7х 0) (h []) [a 41 0,a 42 0,...,a 4n 0] =
             4┌ 0    4┌┌ 0            4┐ 0      4┐ 0          4┐
          = │...││(h [])  7х 0 a 41 0│  7х 0 a 42 0│  7х 0... 7х 0 a 4n 0│;
             4└ 0    4└└ 0            4┘ 0      4┘ 0          4┘
                         4┌ 0                         4┐
   h [a 41 0,a 42 0,...,a 4n 0] = h │[a 41 0,a 42 0,...,a 4n-1 0] ++ [a 4n 0]│ =
                         4└ 0                         4┘
       = (h [a 41 0,a 42 0,...,a 4n-1 0])  7х 0 a 4n 0 =
          4┌ 0                              4┐
       = │h ([a 41 0,a 42 0,...,a 4n-2 0] ++ [a 4n-1 0]│  7х 0 a 4n 0 =...=
          4└ 0                              4┘
          4┌ 0    4┌┌ 0            4┐ 0      4┐ 0          4┐
       = │...││(h [])  7х 0 a 41 0│  7х 0 a 42 0│  7х 0... 7х 0 a 4n 0│.
          4└ 0    4└└ 0            4┘ 0      4┘ 0          4┘

 ш1.2
    1Лемма доказана 0.
    3Замечание 0 ( 1терминологическое 0).
 ш1.1
   Известно, что левая свёртка вычисляется в направлении  1 слева на 0-
 1право 0, однако представляемая функция называется  7Х 1-правосторонней 0.
 ш1.2

    2В 0.  7Х 0- _ 1левосторонние функции . 0.
    2Определение 0 [Gibbons,1995].
 ш1.1
   Будем говорить, что списочная  _ 1функция . h  _является . 0  7Х 0- _ 1левосторонней
(англ.  1leftwards 0), если для любого значения a и любого списка y су-
ществует бинарная функция  7Х 0 такая, что
 ш1.0

   h ([a] ++ y) = a  7Х 0 h y.

 ш1.2
   Важно заметить, что операция ( 7Х 0) не обязана быть ассоциативной.
    2Пример 0 ( 1левосторонней функции 0) (по [Gibbons,1995]).
 ш1.1
   Определим функцию lsp  вычисления   1наибольшего  отсортированного
 1по возрастанию префикса 0:
 ш1.0

                            7( 0a  7Х 0 []    = [a]
   lsp = foldr ( 7Х 0) [], где  7* 0a  7Х 0 (b:x) = a : b : x, если a 7, 0b;
                            79 0a  7Х 0 (b:x) = [a],       если a>b.

 ш1.1
   Приведём соответствующую функцию в foldr-стиле на языке Haskell:
 ш1.0

> lsp :: Ord a => [a] -> [a]
> lsp = foldr f []
>     where
>           f :: Ord a => a -> [a] -> [a]
>           f a []    = [a]
>           f a (b:x) = if a <= b then a : b : x else [a]

> list k = (tail . take 10 . randomRs ('a','z') . mkStdGen) k
>                                                         :: [Char]

> test13 = lsp "abcdefghabcdefgh"
> test14 = head $ sort $ (map (\x -> (lsp x,x)) . map list) [1..100]

 ш1.1
   Возникает  _ 1гипотеза . 0, состоящая в том, что значений  lsp x и lsp y
недостаточно для вычисления значения lsp (x ++ y), т.е. функция lsp
не является списочным гомоморфизмом.
   Пусть, например, x="1234", y="123", тогда
 ш1.0

   lsp (x ++ y) = lsp "1234123" = "1234".

 ш1.1
   Однако lsp x () lsp y = "1234" () "123", и приходится выбирать
в качестве функции () функцию const, но если x="12", y="34123", то
 ш1.0

   lsp (x ++ y) = "1234", но lsp x `const` lsp y = "12".

 ш1.2
   Тем не менее,  пока мы не можем  _ 1доказать . 0, что функция lsp не яв-
ляется списочным гомоморфизмом.
    2Лемма 0.
 ш1.1
    7х 0-левосторонняя функция h имеет следующее представление:
 ш1.0

   h = foldr ( 7х 0) (h []),

т.е. функция h представима в виде  1правой свёртки 0.

 ш1.2
    2Доказательство 0. 1 Упражняйтесь 0.
    3Замечание 0 ( 1терминологическое 0).
 ш1.1
   Известно, что правая свёртка вычисляется  в  направлении   1справа
 1налево 0, однако представляемая функция называется  7Х 1-левосторонней 0.
 ш1.2

    2Г 0.  _ 1Редукция и map-функция . 0.
    2Определение 0 [Gibbons,1995].
 ш1.1
    _ 1Редукцией . 0 назовём функцию
 ш1.0

    3hom 0 () id e

для некоторой ассоциативной функции () с единицей e.

 ш1.2
    2Определение 0 [Gibbons,1995].
 ш1.1
    _ 1Map-функцией . 0 (обозначается map f) назовём функцию,  которая  для
функции f имеет вид:
 ш1.0

    3hom 0 (++) ([ 77 0] ═O 0f) [].

 ш1.2
   Напомним, что
 ш1.0

   [ 77 0] ═O 0f  ═+ 0 \x -> [f x].
 ш1.2

                     23. 0  3Теоремы о гомоморфизмах

 ш1.0
            1- Докажите мне это 0! 1 Докажите 0! 1 И если сможете... - Ярост-
            1ный блеск её глаз говорил лучше всяких слов. 0
            1- За  доказательствами  дело не станет,  - сказал Шерлок
            1Холмс, вынимая из кармана какие-то бумаги. 0
                                    1А.Конан Дойл. Собака Баскервилей
 ш1.2

    2Теорема 1 0 ( 1первая теорема о гомоморфизме 0) [Gibbons,1995].
 ш1.1
   Каждый гомоморфизм  h  представим  в  виде композиции редукции и
map-функции:
 ш1.0

    3hom 0 () f e =  3hom 0 () id e  ═O 0 map f.
                  ═└ 0──── ═┬ 0───── ═┘ 0    ═└ 0─ ═┬ 0─ ═┘

 ш1.1
   Обратно: каждая композиция редукции и map-функции есть ()-гомо-
морфизм.

 ш1.2
    2Теорема 2 0 ( 1вторая теорема о гомоморфизме 0,
               1теорема о специализации 0) [Gibbons,1995].
 ш1.1
   Если () - ассоциативная функция,  то каждый ()-гомоморфизм яв-
ляется:
    2(1) 0 ( 7Х 0)-левосторонней функцией, где a  7Х 0 s = f a  s, т.е.
 ш1.0

    3hom 0 () f e = foldr ( 7Х 0) e = foldr (\x y -> f x  y) e;

 ш1.1
    2(2) 0 ( 7х 0)-правосторонней функцией, где r  7х 0 a = r  f a, т.е.
 ш1.0

    3hom 0 () f e = foldl ( 7х 0) e = foldl (\x y -> x  f y) e.

 ш1.2
    2Лемма 0 0.
 ш1.0

    2(1) 0  3foldr 0 ( 7Х 0) e (x ++ y) =  3foldr 0 ( 7Х 0) ( 3foldr 0 ( 7Х 0) e y) x;     (1)

    2(2) 0  3foldl 0 ( 7х 0) e (x ++ y) =  3foldl 0 ( 7х 0) ( 3foldl 0 ( 7Х 0) e x) y.     (2)

 ш1.2
    2Доказательство 0. 1 Упражняйтесь 0.
    2Лемма 1 0 [Gibbons,1995].
 ш1.1
   Для любой всюду вычислимой функции h с перечислимой областью оп-
ределения  1существует 0 вычислимая (возможно,  частично) функция g та-
кая, что h ═O 0g ═O 0h=h.
    2Доказательство 0. Определим функцию g следующим простым способом.
   Выберем t  из  множества значений функции h,  перечислим область
определения функции h и выберем первое значение x такое, что h x=t.
   Положим g t = x. Теперь
 ш1.0

   h x = (h ═O 0g ═O 0h) x = (h ═O 0g) (h x) = (h ═O 0g) t = h (g t) = h x.

 ш1.2
    1Лемма 1 доказана 0.
    2Лемма 2 0 [Gibbons,1995].
 ш1.1
   Функция h является гомоморфизмом  1тогда и только тогда 0, когда для
любых списков v, w, x, y
 ш1.0

   h v = h x, h w = h y => h (v ++ w) = h (x ++ y)             (3)
    ═└ 0─── ═┬ 0─── ═┘ 0   ═└ 0─── ═┬ 0─── ═┘ 0     ═└ 0────────── ═┬ 0────────── ═┘

 ш1.2
    2Доказательство 0 [Gibbons,1995].
    _ 1Необходимость . 0. Если  h  - является гомоморфизмом,  то существует
функция  7Х 0 такая, что h (x ++ y) = h x  7Х 0 h y для любых списков x и y.
   Пусть теперь  _h v = h x .,  _h w = h y ., тогда
 ш1.0

   h (v ++ w) = h v  7Х 0 h w = h x  7Х 0 h y =  _h (x ++ y) ..

 ш1.2
    _ 1Достаточность . 0. Предположим, что функция h удовлетворяет (3).
   Выберем такую  функцию  g,  что h ═O 0g ═O 0h=h и определим оператор ()
следующим образом:
 ш1.0

   t  u = h (g t ++ g u).

 ш1.2
   Покажем, что функция h является ()-гомоморфной.
   В силу выбора функции g,
 ш1.0

   h x = h (g (h x)), h y = h (g (h y))

 ш1.2
и используя (3), по которому v = g (h x), w = g (h y), получим
 ш1.0

                                4┌ 0                   4┐
   h (x ++ y) = h (v ++ w) = h │g (h x) ++ g (h y)│ =
                                4└ 0                   4┘
              = h x () h y.

 ш1.2
    1Лемма 2 доказана 0.
    2Теорема 3 0 ( 1третья теорема о гомоморфизме 0) [Gibbons,1995].
 ш1.1
   Если функция h является и левосторонней и правосторонней функци-
ями, то h - гомоморфизм.
   Более точно, функция h является ()-гомоморфизмом, причём
 ш1.0

   t  u = h (g t ++ g u)

для некоторой функции g такой, что h ═O 0g ═O 0h=h.

 ш1.2
    2Доказательство 0. Предположим, что
 ш1.0

   h = foldr ( 7Х 0) e = foldl ( 7х 0) e, h v = h x, h w = h y.

 ш1.2
   Тогда
 ш1.0

   h (v ++ w)                        = { h - левосторонняя }  =
       = foldr ( 7Х 0) e (v ++ w)        = { (1) }                =
       = foldr ( 7Х 0) (foldr ( 7Х 0) e w) v = { h w = h y }          =
                     ═└ 0──── ═┬ 0──── ═┘ 4h

       = foldr ( 7Х 0) (foldr ( 7Х 0) e y) v = { (1) }                =
       = foldr ( 7Х 0) e (v ++ y)        = { h - левосторонняя }  =

       = h (v ++ y)                  = { h - правосторонняя } =
       = foldl ( 7х 0) e (v ++ y)        = { (2) }                =
       = foldl ( 7х 0) (foldl ( 7х 0) v) y   = { h v = h x }          =
       = foldl ( 7х 0) (foldl ( 7х 0) x) y   = { (2) }                =
       = foldl ( 7х 0) e (x ++ y)        = { h - правосторонняя } =
       = h (x ++ y).

 ш1.2
   Следовательно, по Лемме 2 функция h является гомоморфизмом.
    1Теорема доказана 0.
    2Пример 0 ( 1применения третьей теоремы о гомоморфизме 0).
 ш1.1
   Рассмотрим функцию  id,  для  которой построим  foldr-  и foldl-
представления:
 ш1.0

   id = foldr (:)                 _[] .,
   id = foldl (\x y -> x ++ [y])  _[] ..

 ш1.1
   По третьей теореме о гомеоморфизме  1существует 0 функция () такая,
что для любых конечных списков x и y
 ш1.0

   id (x ++ y) = id x () id y.

   Нетрудно установить, что такой функцией является функция (++).

 ш1.2
    3Замечание 0.
 ш1.1
   Существуют исследования,  обобщающие  понятие списочных гомомор-
физмов на древовидные структуры.
 ш1.2

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 0  21.
 ш1.0

 ш1.2

    2Пример 0  22.
 ш1.0

 ш1.2

    2Пример 0  23.
 ш1.0

 ш1.2

    2Пример 0  24.
 ш1.0

 ш1.2

    2Пример 0  25.
 ш1.0

 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                     1Раз - везение, два - везение, надобно и умение.
                                                         1А.В.Суворов
 ш1.2

                       20. 3 Классическое оригами
    21. 0 Сконструируйте классические оригами:
 ш1.1
   (1)  _ 1статичные модели . 0:  стакан,  шлем самурая, дзунако, вертушка,
пароход, парусник, голубь, цикада;
   (2)  _ 1движущиеся модели . 0: лягушка, японский журавлик, лающий щенок,
учёный тюлень и др.

 ш1.2
                  21. 3 Функционалы свёртки в Prelude
    20 4* 2. 0 Вычислите значения выражений и проверьте результат в HUG:
 ш1.0

   (1) foldl (/) 480 [3,2,5,2];  (2) foldr (/) 2 [8,12,24,4].

 ш1.2
    21 4* 2. 0 Определите назначение следующих функций:
 ш1.0

   (1) test1      = foldr (+) 0 [1..10]
   (2) test2      = foldr (+) 0
   (3) test3      = foldr (*) 1
   (4) test4 lst  = foldr max (head lst) (tail lst)
   (5) test5 elem = (.) (foldr (||) False) (map (== elem))
   (6) test6 lst  = take (toInt (len lst `div` 2)) lst
          where len = foldr (\z -> \n -> n+1) 0
   (7) test7 = map fact
          where fact n = foldl1 (*) [1..n]
   (8) test8      = map (length . show . (scanl (*) 1 [1..] !!))
   (9) test9 x = sum $ map (\k -> power sin k x) [1..50]
          where power f 0     = id           
                power f (n+1) = f . power f n
   (10) test10 m n  = takeWhile (<=n) $ iterate (+ 1) m
   (11) [Bird,Wadler,1988,p.172]
        group n = map (take n) . takeWhile (/=[])
                               . iterate (drop n)
   (12) [Bird,Wadler,1988,p.172]
        digits  = reverse . map (`mod` 10) . takeWhile (/=0)
                                           . iterate (`div` 10)

 ш1.2
    22. 0 Известно, что свёртка foldr приспособлена для работы с беско-
нечными списками:
 ш1.0

   > head $ (foldr (\x xs -> (x + pi) : xs) [] ) [1..]
   4.141592653589793

 ш1.2
   К сожалению, иногда возникают неприятности. Например, рассмотрим
функцию, которая удаляет из заданного списка элементы,  расположен-
ные на нечётных местах:
 ш1.0

   evenOnly = snd . foldr (\x (os,es) -> (x : es,os)) ([],[])

   > evenOnly [1..10]
   [2,4,6,8,10]

 ш1.2
   Однако на бесконечном списке её поведение становится странным:
 ш1.0

   > head $ evenOnly [1..]
   Interrupted.

 ш1.2
   Почему это происходит, и какие минимальные изменения можно в неё
внести, чтобы восстановить утраченную работоспособность?
                22. 3 Определение функций и функционалов
                          3с помощью свёртки
    21. 0 Реализуйте следующие функции с помощью свёртки foldr:
 ш1.0

   (1) sum, product, and, or, concat, head, (++), length, reverse;
   (2) not, tail, init, last.

 ш1.2
    22. 0 Реализуйте следующие функционалы с помощью свёртки foldr:
 ш1.0

   map, filter, zip, dropWhile, foldl.

 ш1.2
    23. 0 Реализуйте следующие функции с помощью свёртки foldl:
 ш1.0

   (1) sum, product, and, or, concat, reverse;
   (2) head, (++), length, not, tail, init, last.

 ш1.2
    24 5* 2. 0 Реализуйте следующие функционалы с помощью свёртки foldl:
 ш1.0

   map, filter, zip, dropWhile, foldr.

 ш1.2
    25 5* 2. 0 Реализуйте  следующие  функционалы  из библиотеки List с по-
мощью свёртки:
 ш1.0

   (1) tails'' []     = [[]]
       tails'' (x:xs) = (x : xs) : tails'' xs

   (2) inits'' []     = [[]]
       inits'' (x:xs) = [] : map (x :) (inits'' xs)

 ш1.2
    26. 0 ( 1С.Довжиков 0)
   Определите, правильно ли реализованы следующие функции, записан-
ные в foldr-стиле, с помощью  1ручной прокрутки 0 кода:
 ш1.0

   (1) tail' lst = foldr f [] lst
           where f x ys = if length ys == -1 + length lst
                            then ys else x : ys

   (2) init' lst = foldl f [] lst
           where f ys x = if length ys == -1 + length lst
                            then ys else ys ++ [x]

   (3) last' = (!! 0) . foldr f [] . h2
            where f (x,i) ys = if i==0 then x : ys else ys
       ---------------------------------------------------
       h2 :: [a] -> [(a,Int)]
       h2 []     = []
       h2 [x]    = [(x,0)]
       h2 (x:xs) = (x,1) : (h2 xs)

   (4) takeWhile' p = foldr f' [] . (g p)
             where f' (x,b) ys = if b then x : ys else ys
       --------------------------------------------------
       dropWhile' :: (a -> Bool) -> [a] -> [a]
       dropWhile' p = foldr f' [] . (g p)
             where f' (x,b) ys = if b then ys else x : ys
       --------------------------------------------------
       g :: (a -> Bool) -> [a] -> [(a,Bool)]
       g p [] = []
       g p (x:xs) = if p x
                      then (x,True) : (g p xs)
                      else (x,False) : (map (\x -> (x,False)) xs)

 ш1.2
    27 4* 2. 0 Определите недостатки следующей реализации функции head:
 ш1.0

   head' l = foldl f e l
       where f = \x y -> x
             e = l !! 0

 ш1.2
                       23. 3 Развёртка на списках
    21. 0 Функция (range n m) возвращает список чисел от n до m.  Опре-
делите её с помощью развёртки.
    22. 0 Определите с помощью развёртки следующие функции:
 ш1.0

   (1) map, zip; (2) 5* 0 filter.

 ш1.2
    23. 0 Проверьте, реализует ли функция, приведённая ниже, функционал
filter; при положительном ответе перепишите функцию в unfold-стиле.
 ш1.0

   filter' p lst | null lst     = []
                 | p (head lst) = f lst
                 | True         = tail $ f lst
      where f  = unfold p' f' g'
            p' = null 
            f' = head
            g' = g (not . p) . tail 
            -------------------------
            g pr l | null l      = []
                   | pr (head l) = dropWhile pr l
                   | True        = l

 ш1.2
                      24. 3 Списочные гомоморфизмы
    21. 0 Для каждого из следующих списочных  гомоморфизмов  определите
функцию ():
 ш1.0

   (а) id, concat, head, length;
   (б) sum, product, min, max;
   (в) all, any, map, filter.

 ш1.2
   Сравните для перечисленных функций их foldr- и foldl-представле-
ния и установите применимость третьей теоремы о гомоморфизме.
    22. 0 Постройте foldr-представления:  (а) функции lsp; (б) подсчёта
математического ожидания и дисперсии в  заданном  числовом  списке;
(в) сортировки списка.
    23. 0 Постройте  foldl-представление  процесса  нахождения  позиции
" 1последнего минимума 0" в заданном списке.
    24. 0 Постройте  foldr-представление  процесса  нахождения  позиции
" 1первого минимума 0" в заданном списке.
