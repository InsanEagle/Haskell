   -- Модуль, описывающий алгебраический тип данных (АТД),
   -- моделирующий  полиморфные  бинарные деревья  поиска,
   -- представленные объявлением:
   --
   --                 Размеченное объединение
   --                     |
   --  data BTree a = Nil | Node a (BTree a) (BTree a)
   --                            ---------------------
   --                                      |
   --                            Декартово произведение
   --
   -- Авторы: И.А.Кудрявцева, М.В.Швецкий (15.12.2010)
   ---------------------------------------------------
   module Tr_Polim
      (BTree (Nil,Node),
      ---------------------------------------------------------
      -- Для представления "настоящего" АТД необходимо  удалить
      -- ("спрятать") перечень конструкторов данных (Nil,Node),
      -- т.е. написать "(BTree (..),"
      -----------------------------------------------------
       nil, list, node,                     -- Конструкторы
       root, left, right,                   -- Селекторы
       isEmpty, isNode,                     -- Предикаты
       ---------------------------------------------------
       addTree, consTree, consTree', consTree'',
       search, searchBool,
       rightList, leftList, delete, ud, delete', ud',
       top, topNode, nodes, nList, way, equalTree, tCopy,
       klpObh, lpkObh, lkpObh, klkpObh,
       newRndTree,
       sort,
       mapBTree, filterBT,                  -- Функционалы 
       drawTree, outTree, outTree',         -- "Визуализаторы"
       ---------------------------------------------------------
       -- Функции, не удовлетворяющие требованиям, предъявляемым
       -- к АТД
       ----------------------------------------------------
       addTree', searchBool', nList', drawTree', mapBTree')
   where
   -------------------
   -- Конструктор типа
   --     |
   --     |     Конструкторы данных
   --     |        |     |
   --     |        |     |
   data BTree a = Nil | Node a (BTree a) (BTree a)
   --                        ---------------------
   --                                 |
   --                        Декартово произведение
   ------------------------------------------------
      deriving (Eq)
   --------------------------------------------
   -- Конструкторы данных имеют следующие типы:
   -- > :t Nil
   -- BTree a
   -- > :t Node
   -- a -> BTree a -> BTree a -> BTree a

   -- ******************************************
   -- Функции-конструкторы данных типа (BTree a)
   -- (конструкторы - это наименования функций, создающих
   -- декартовы произведения)
   -- ***********************

   ------------------------------------------------------
   -- Функция-конструктор пустого бинарного дерева поиска
   ------------------------------------------------------
   nil:: BTree a
   nil = Nil
   ----------------------------------------------------
   -- Функция-конструктор листа бинарного дерева поиска
   ----------------------------------------------------
   list:: a -> BTree a
   list x = Node x Nil Nil
   -------------------------------------------------------
   -- Функция-конструктор вершины бинарного дерева поиска,
   -- не являющейся листом
   -----------------------------------------
   node:: a -> BTree a -> BTree a -> BTree a
   node x l r = Node x l r

   -- ***************************************
   -- Функции-селекторы данных типа (BTree a)
   -- (селекторы - это функции, обеспечивающие получение
   -- отдельных компонентов декартовых произведений)
   -- **********************************************

   ----------------------------------------------------------------
   -- Функция-селектор, возвращающая корень дерева поиска (BTree a)
   ----------------------------------------------------------------
   root:: BTree a -> a
   root Nil          = error "Дерево пусто"
   root (Node a l r) = a
   --------------------------------------------------------
   -- Функция-селектор, возвращающая левое поддерево дерева
   -- поиска (BTree a)
   -------------------------
   left:: BTree a -> BTree a
   left Nil          = nil
   left (Node a l r) = l
   ---------------------------------------------------------
   -- Функция-селектор, возвращающая правое поддерево дерева
   -- поиска (BTree a)
   --------------------------
   right:: BTree a -> BTree a
   right Nil          = nil
   right (Node a l r) = r

   -- *************************************************
   -- Предикаты для распознавания  конструкторов данных
   -- типа BTree как элементов размеченного объединения
   -- (предикаты - это функции, позволяющие идентифици-
   -- ровать принадлежность заданного значения конкрет-
   -- ному множеству из размеченного объединения)
   -- *******************************************

   -------------------------------------------------
   -- Функция-предикат, распознающая конструктор Nil
   -------------------------------------------------
   isEmpty:: BTree a -> Bool
   isEmpty Nil = True
   isEmpty _   = False
   --------------------------------------------------
   -- Функция-предикат, распознающая конструктор Node
   --------------------------------------------------
   isNode:: BTree a -> Bool
   isNode = not.isEmpty

   -----------------------------------------------------
   -- Проверим тектоничность (внутреннюю согласованность
   -- структуры) построенного алгебраического типа данных
   ------------------------------------------------------
   test0  = node (root t) (left t) (right t)
        where t = node 1 nil nil
   test0' = node (root t) (left t) (right t)
        where t = node 'a' nil nil

   -- ***************************************************
   -- Реализация операций над алгебраическим типом данных
   -- ***************************************************

   -----------------------------------------------------------
   -- Функция, добавляющая элемент x в дерево поиска (BTree a)
   -----------------------------------------------------------
   addTree:: Ord a => a -> BTree a -> BTree a
   addTree x tree | isEmpty tree = list x
                  | x==root tree = tree
                  | x<root tree  = node (root tree)
                                        (addTree x (left tree))
                                        (right tree)
                  | True         = node (root tree) 
                                        (left tree)
                                        (addTree x (right tree))

   -----------------------------------------------------------
   -- Функция-парсер, конструирующая бинарное дерево поиска из
   -- одноуровневого списка lst, элементы которого "поступают"
   -- в дерево в порядке их следования в списке
   --------------------------------------------
   consTree:: Ord a => [a] -> BTree a
   consTree lst | null lst = nil
                | True     = addTree (last lst)
                                     (consTree (init lst))

   -----------------------------------------------------------
   -- Функция-парсер, конструирующая бинарное дерево поиска из
   -- одноуровневого списка lst, элементы которого "поступают"
   -- в дерево в порядке их следования в списке
   -- (бесточечная запись)
   ------------------------------------
   consTree'':: Ord a => [a] -> BTree a
   consTree'' = foldr addTree nil . reverse

   -----------------------------------------------------------
   -- Функция-парсер, конструирующая бинарное дерево поиска из
   -- одноуровневого  списка, элементы  которого "поступают" в
   -- дерево в порядке, обратном их следованию в списке
   ----------------------------------------------------
   consTree':: Ord a => [a] -> BTree a
   consTree' = foldr addTree nil

   ------------------------------------------------------------
   -- Функция, осуществляющая бинарный поиск элемента a в дере-
   -- ве поиска tree:
   --  (1) в случае успеха возвращает поддерево дерева  Tree, в
   -- котором элемент a является корнем;
   --  (2) в случае неудачного поиска функция возвращает пустое
   -- дерево nil
   -----------------------------------------
   search:: Ord a => a -> BTree a -> BTree a
   search a tree | isEmpty tree = nil
                 | a==root tree = tree
                 | a<root tree  = search a (left tree) 
                 | True         = search a (right tree)

   -----------------------------------------------------------
   -- Функция-предикат, осуществляющая бинарный поиск элемента
   -- a в дереве поиска:
   --  (1) в случае успеха возвращает True;
   --  (2) в случае неудачного поиска - False
   ------------------------------------------
   searchBool:: Ord a => a -> BTree a -> Bool
   searchBool a tree | isEmpty tree = False
                     | a==root tree = True
                     | a<root tree  = searchBool a (left tree)
                     | True         = searchBool a (right tree)

   -------------------------------------------------------------
   -- Функция, возвращающая самый правый лист дерева поиска tree
   -------------------------------------------------------------
   rightList:: BTree a -> a
   rightList tree | isEmpty (left tree) && isEmpty (right tree)
                                         = root tree
                  | isEmpty (right tree) = rightList (left tree)
                  | True                 = rightList (right tree)

   --------------------------------------------------------------
   -- Функция, возвращающая самый левый лист дерева поиска tree
   ------------------------------------------------------------
   leftList:: BTree a -> a
   leftList tree | isEmpty (left tree) && isEmpty (right tree)
                                       = root tree
                 | isEmpty (left tree) = leftList (right tree)
                 | True                = leftList (left tree)

   -------------------------------------------------------------
   -- Функция, удаляющая узел x из бинарного дерева поиска tree.
   -- Функции delete() и ud() "дословно"  повторяют соответству-
   -- ющие рекурсивные процедуры Н.Вирта [1985] (язык Pascal)
   -- (первый способ)
   -----------------------------------------
   delete:: Ord a => a -> BTree a -> BTree a
   delete x tree | isEmpty tree = nil
                 | x<root tree  = node (root tree) 
                                       (delete x (left tree))
                                       (right tree)
                 | x>root tree  = node (root tree) 
                                       (left tree)
                                       (delete x (right tree))
                 | isEmpty (right tree)
                                = left tree
                 | isEmpty (left tree)
                                = right tree
                 | True         = node (ud (left tree))
                                       (delete (ud (left tree))
                                               (left tree))
                                       (right tree)
   --------------------------------------------------------
   -- Функция, возвращающая самый "правый" элемент (элемент
   -- с наибольшим ключом) бинарного дерева поиска tree
   ----------------------------------------------------
   ud:: BTree a -> a
   ud tree | isEmpty (right tree) = root tree
           | True                 = ud (right tree)

   --------------------------------------------------------
   -- Функция, удаляющая узел x из бинарного дерева поиска.
   -- Функции delete'()  и  ud'() повторяют соответствующие
   -- рекурсивные процедуры Н.Вирта [1985] (язык Pascal)
   -- (второй способ)
   -------------------------------
   delete':: Ord a => a -> BTree a -> BTree a
   delete' x tree 
              | isEmpty tree = nil
              | x<root tree  = node (root tree) 
                                    (delete' x (left tree))
                                    (right tree)
              | x>root tree  = node (root tree) 
                                    (left tree)
                                    (delete' x (right tree))
              | isEmpty (right tree)
                             = left tree
              | isEmpty (left tree)
                             = right tree
              | True         = node (ud' (right tree))
                                    (left tree)
                                    (delete' (ud' (right tree))
                                             (right tree))
   -------------------------------------------------------
   -- Функция, возвращающая самый "левый" элемент (элемент
   -- с наименьшим ключом) бинарного дерева поиска tree
   ----------------------------------------------------
   ud':: BTree a -> a
   ud' tree | isEmpty (left tree) = root tree
            | True                = ud' (left tree)

   ----------------------------------------------------------
   -- Функция, возвращающая количество уровней в бинарном де-
   -- реве поиска tree (корень дерева расположен на уровне 0)
   ----------------------------------------------------------
   top:: Ord a => BTree a -> Int
   top tree | isEmpty tree = -1
            | True         = 1+max (top (left tree))
                                   (top (right tree))

   ---------------------------------------------------
   -- Функция, возвращающая уровень заданной вершины x
   -- в бинарном дереве поиска tree
   --------------------------------
   topNode:: Ord a => a -> BTree a -> Int
   topNode x tree | x==root tree = 0
                  | x<root tree = 1+ topNode x (left tree)
                  | True        = 1+ topNode x (right tree)

   ------------------------------------------
   -- Функция, возвращающая количество вершин
   -- в бинарном дереве поиска tree
   --------------------------------
   nodes:: BTree a -> Int
   nodes tree | isEmpty tree = 0
              | True         = 1 + nodes (left tree)
                                 + nodes (right tree)

   -------------------------------------------
   -- Функция, возвращающая количество листьев
   -- в бинарном дереве поиска tree
   --------------------------------
   nList:: BTree a -> Int
   nList tree | isEmpty tree = 0
              | isEmpty (left tree) && isEmpty (right tree)
                             = 1
              | True         = nList (left tree) +
                               nList (right tree)

   --------------------------------------------------
   -- Функция, возвращающая количество дуг в бинарном
   -- дереве поиска tree
   ---------------------
   way:: BTree a -> Int
   way tree | isEmpty (left tree) && isEmpty (right tree)
                                   = 0
            | isEmpty (left tree)  = 1 + way (right tree)
            | isEmpty (right tree) = 1 + way (left tree)
            | True                 = 2 + way (left tree)
                                       + way (right tree)

   ---------------------------------------------------
   -- Предикат, устанавливающий равенство произвольных
   -- бинарных деревьев поиска tree1 и tree2
   ----------------------------------------------
   equalTree:: Eq a => BTree a -> BTree a -> Bool
   equalTree tree1 tree2 | isEmpty tree1 && isEmpty tree2
                                   = True
                         | isEmpty tree1 || isEmpty tree2
                                   = False
                         | True    =   root tree1==root tree2
                                    && equalTree (left tree1)
                                                 (left tree2)
                                    && equalTree (right tree1)
                                                 (right tree2)

   -----------------------------------------------------------
   -- Функция, возвращающая копию бинарного дерева поиска tree
   -----------------------------------------------------------
   tCopy:: BTree a -> BTree a
   tCopy tree | isEmpty tree = nil
              | True         = node (root tree)
                                    (tCopy (left tree))
                                    (tCopy (right tree))

   -- ***************************
   -- Итераторы (обходы деревьев)
   -- ***************************

   -----------------------------------------------------
   -- Функция, осуществляющая левосторонний (нисходящий)
   -- обход бинарного дерева поиска tree
   -------------------------------------
   klpObh:: BTree a -> [a]
   klpObh tree | isEmpty tree = []
               | True         =   [root tree]
                               ++ klpObh (left tree)
                               ++ klpObh (right tree)

   ------------------------------------------------------
   -- Функция, осуществляющая концевой (восходящий) обход
   -- бинарного дерева поиска tree
   -------------------------------
   lpkObh:: BTree a -> [a]
   lpkObh tree | isEmpty tree = []
               | True         =   lpkObh (left tree)
                               ++ lpkObh (right tree)
                               ++ [root tree]

   -----------------------------------------------------
   -- Функция, осуществляющая обратный (смешанный) обход
   -- бинарного дерева поиска tree
   -------------------------------
   lkpObh:: BTree a -> [a]
   lkpObh tree | isEmpty tree = []
               | True         =   lkpObh (left tree)
                               ++ [root tree]
                               ++ lkpObh (right tree)

   ---------------------------------------------
   -- Функция, осуществляющая двойственный обход
   -- бинарного дерева поиска tree
   -------------------------------
   klkpObh:: BTree a -> [a]
   klkpObh tree | isEmpty tree = []
                | True         =    [root tree]
                                ++ klkpObh (left tree)
                                ++ [root tree]
                                ++ klkpObh (right tree)

   -- ***********************
   -- Функционалы на деревьях
   -- ***********************

   ----------------------------------------------
   -- Моделирование функционала map для бинарного
   -- дерева поиска tree
   --------------------------------------------------
   mapBTree:: Ord a => (a -> b) -> BTree a -> BTree b
   mapBTree f tree | isEmpty tree = nil
                   | True         = node (f (root tree))
                                         (mapBTree f (left tree))
                                         (mapBTree f (right tree))

   -------------------------------------------------
   -- Моделирование функционала filter для бинарного
   -- дерева поиска tree (возвращается дерево)
   -----------------------------------------------------
   filterBT:: Ord a => (a -> Bool) -> BTree a -> BTree a
   filterBT p tree 
        | isEmpty tree  = nil
        | p (root tree) = node (root tree) 
                               (filterBT p (left tree))
                               (filterBT p (right tree))
        | True          = delete (root tree)
                                 (node (root tree) 
                                       (filterBT p (left tree))
                                       (filterBT p (right tree)))

   --------------------------------------------------------
   -- Функция, генерирующая псевдослучайное бинарное дерево
   -- поиска, содержащее m-n+1 целое число из [0,a-1]
   --------------------------------------------------
   newRndTree:: Int -> Int -> Int -> BTree Int
   newRndTree n m a = consTree (newRndLst n m a)
       where
            ----------------------------------------------
            -- Функция, генерирующая подсписок целых чисел
            --
            -- a ,a   ,...,a   ,a ,
            --  n  n+1      m-1  m
            --
            -- каждое из  которых  принадлежит  [0,a-1], из
            -- псевдослучайного списка чисел
            -----------------------------------------------
            newRndLst n m a = drop n (take (m+1) (rand' a)) 
            -------------------------------------------------
            -- Функция, генерирующая бесконечный список чисел
            -- из [0,a-1]
            ---------------------------------
            rand' a = [x `mod` a | x <- rand]
            -----------------------------------------------------
            -- Функция, генерирующая список псевдослучайных чисел
            -----------------------------------------------------
            rand = iterate next_seed 23765492
            ----------------------------------------------
            -- Функция, возвращающая псевдослучайное число
            ----------------------------------------------
            next_seed n = case test>0 of
                            True  -> test
                            False -> test+2147483647
                 where test = 48271*lo-3399*hi 
                       hi   = n `div` 44488 
                       lo   = n `mod` 44488
   --------------------------------------------------------
   -- Функция, сортирующая (по возрастанию) элементы число-
   -- вого списка с помощью бинарного дерева поиска
   ------------------------------------------------
   sort:: Ord a => [a] -> [a]
   sort = lkpObh . consTree

   -- ************************************
   -- Визуализация бинарного дерева поиска
   -- ************************************

   --------------------------------------------------
   -- Функция, изображающая дерево поиска tree в виде
   -- строки символов (при вызове l=0)
   -- (с использованием охран)
   ---------------------------------------------
   drawTree:: Show a => BTree a -> Int -> String
   drawTree tree l | isEmpty tree = ""
                   | True         = drawTree (right tree) (l+1) ++
                                    "\n" ++ 
                                    replicate (l*3) ' ' ++
                                    show (root tree) ++
                                    drawTree (left tree) (l+1)

   ----------------------------------------------------
   -- Функция, изображающая бинарное дерево поиска tree
   -- на экране дисплея
   -----------------------------------
   outTree:: Show a => BTree a -> IO()
   outTree tree = putStr (drawTree tree 0 ++ "\n")

   ------------------------------------------------------
   -- Функция, представляющая бинарное дерево поиска tree
   -- в виде "обычного" списка, т.е. без указания  конст-
   -- руктора Node
   ------------------------------------
   outTree':: Show a => BTree a -> IO()
   outTree' tree = putStr (show tree)

   ------------------------------------------------------------
   -- Представление типа (BTree a) в качестве экземпляра класса
   -- Show с определением метода, представляющего  бинарное де-
   -- рево поиска без указания имени конструктора Node
   ---------------------------------------------------
   instance Show a => Show (BTree a)
     where show Nil = "Nil"
           show (Node a Nil Nil)
                 = "(" ++ show a ++ " Nil" ++ " Nil" ++ ")"
           show (Node a l r)    
                 = "(" ++ show a ++ " " ++ show l ++ " "
                                        ++ show r ++ ")"

   -- **************************************************
   -- П л о х и е  реализации функций с точки зрения АТД
   -- (используются сопоставления с образцом)
   -- ***************************************

   -------------------------------------------------------
   -- Функция, добавляющая элемент x в дерево поиска BTree
   -- (с использованием сопоставления с образцом)
   ----------------------------------------------
   addTree':: Ord a => a -> BTree a -> BTree a
   addTree' a Nil = list a
   addTree' a (Node x l r) | a==x = node x l r
                           | a<x  = node x (addTree' a l) r
                           | True = node x l (addTree' a r)
   -----------------------------------------------------------
   -- Функция-предикат, осуществляющая бинарный поиск элемента
   -- a в дереве поиска:
   --  (1) в случае успеха возвращает True;
   --  (2) в случае неудачного поиска - False
   ------------------------------------------
   searchBool':: Ord a => a -> BTree a -> Bool
   searchBool' a Nil = False
   searchBool' a (Node x l r) | a==x = True
                              | a<x  = searchBool' a l
                              | True = searchBool' a r
   ------------------------------------------------------
   -- Функция, возвращающая количество листьев в бинарном
   -- дереве поиска
   -- (с использованием сопоставления с образцом)
   ----------------------------------------------
   nList':: BTree a -> Int
   nList' Nil              = 0
   nList' (Node _ Nil Nil) = 1
   nList' (Node _ l r)     = nList' l + nList' r
   ----------------------------------------------
   -- Моделирование функционала map для бинарного
   -- дерева поиска tree
   ----------------------------------------
   mapBTree':: (a ->b) -> BTree a -> BTree b
   mapBTree' _ Nil          = nil
   mapBTree' f (Node x l r) = node (f x)
                                  (mapBTree' f l)
                                  (mapBTree' f r)
   ---------------------------------------------------------
   -- Функция, изображающая дерево поиска tree в виде строки
   -- символов; l - накапливающий параметр, значение которо-
   -- го при первом вызове функции равно 0
   -- (с использованием сопоставления с образцом)
   ----------------------------------------------
   drawTree':: Show a => BTree a-> Int -> String
   drawTree' Nil k          = ""
   drawTree' (Node x l r) k = drawTree' r (k+1)
                              ++ "\n" ++ replicate (k*3) ' '
                              ++ show x
                              ++ drawTree' l (k+1)

