   -- Модуль, описывающий алгебраический тип данных (АТД),
   -- моделирующий числовые бинарные деревья поиска, пред-
   -- ставленные объявлением:
   --
   --               Размеченное объединение
   --                   |
   --  data BTree = Nil | Node Int (BTree) (BTree)
   --                          -------------------
   --                                   |
   --                         Декартово произведение
   --
   -- Авторы: И.А.Кудрявцева, М.В.Швецкий (15.12.2010)
   ---------------------------------------------------
   module Tree
      (BTree (Nil,Node),
      ---------------------------------------------------------
      -- Для представления "настоящего" АТД необходимо  удалить
      -- ("спрятать") перечень конструкторов данных (Nil,Node),
      -- т.е. написать "(BTree (..),"
      -----------------------------------------------------
       nil, list, node,                     -- Конструкторы
       root, left, right,                   -- Селекторы
       isEmpty, isNode,                     -- Предикаты
       -------------------------------------------------
       addTree, consTree, consTree', consTree'',
       search, searchBool,
       rightList, leftList, delete, ud, delete', ud',
       top, topNode, nodes, nList, way, equalTree, tCopy,
       klpObh, lpkObh, lkpObh, klkpObh,
       newRndTree,
       sort,
       mapBTree, filterBT,                  -- Функционалы 
       drawTree, outTree, outTree',         -- "Визуализаторы"
       ---------------------------------------------------------
       -- Функции, не удовлетворяющие требованиям, предъявляемым
       -- к АТД
       ----------
       mapBTree')
   where
   -------------------
   -- Конструктор типа
   --     |
   --     |   Конструкторы данных
   --     |      |     |
   --     |      |     |
   data BTree = Nil | Node Int BTree BTree
   --              -       ---------------
   --              |              |
   --           Декартовы произведения
   -----------------------------------
      deriving (Eq)
   --------------------------------------------
   -- Конструкторы данных имеют следующие типы:
   -- > :t Nil
   -- BTree
   -- > :t Node
   -- Int -> BTree -> BTree -> BTree

   -- **************************************
   -- Функции-конструкторы данных типа BTree
   -- (конструкторы - это наименования функций, создающих
   -- декартовы произведения)
   -- ***********************

   ------------------------------------------------------
   -- Функция-конструктор пустого бинарного дерева поиска
   ------------------------------------------------------
   nil:: BTree
   nil = Nil
   ----------------------------------------------------
   -- Функция-конструктор листа бинарного дерева поиска
   ----------------------------------------------------
   list:: Int -> BTree
   list x = Node x Nil Nil
   -------------------------------------------------------
   -- Функция-конструктор вершины бинарного дерева поиска,
   -- не являющейся листом
   -------------------------------------
   node:: Int -> BTree -> BTree -> BTree
   node x l r = Node x l r

   -- ***********************************
   -- Функции-селекторы данных типа BTree
   -- (селекторы - это функции, обеспечивающие получение
   -- отдельных компонентов декартовых произведений)
   -- **********************************************

   ------------------------------------------------------------
   -- Функция-селектор, возвращающая корень дерева поиска BTree
   ------------------------------------------------------------
   root:: BTree -> Int
   root Nil          = error "Дерево пусто"
   root (Node a l r) = a
   --------------------------------------------------------
   -- Функция-селектор, возвращающая левое поддерево дерева
   -- поиска BTree
   ---------------------
   left:: BTree -> BTree
   left Nil          = nil
   left (Node a l r) = l
   ---------------------------------------------------------
   -- Функция-селектор, возвращающая правое поддерево дерева
   -- поиска BTree
   ----------------------
   right:: BTree -> BTree
   right Nil          = nil
   right (Node a l r) = r

   -- *************************************************
   -- Предикаты для распознавания  конструкторов данных
   -- типа BTree как элементов размеченного объединения
   -- (предикаты - это функции, позволяющие идентифици-
   -- ровать принадлежность заданного значения конкрет-
   -- ному множеству из размеченного объединения)
   -- *******************************************

   -------------------------------------------------
   -- Функция-предикат, распознающая конструктор Nil
   -------------------------------------------------
   isEmpty:: BTree -> Bool 
   isEmpty Nil = True
   isEmpty _   = False
   --------------------------------------------------
   -- Функция-предикат, распознающая конструктор Node
   --------------------------------------------------
   isNode:: BTree -> Bool
   isNode = not . isEmpty

   -----------------------------------------------------
   -- Проверим тектоничность (внутреннюю согласованность
   -- структуры) построенного алгебраического типа данных
   ------------------------------------------------------
   test0 = node (root t) (left t) (right t)
        where t = node 1 nil nil

   -- ***************************************************
   -- Реализация операций над алгебраическим типом данных
   -- ***************************************************

   -------------------------------------------------------
   -- Функция, добавляющая элемент x в дерево поиска BTree
   -------------------------------------------------------
   addTree:: Int -> BTree -> BTree
   addTree x tree | isEmpty tree = list x
                  | x==root tree = tree
                  | x<root tree  = node (root tree)
                                        (addTree x (left tree))
                                        (right tree)
                  | True         = node (root tree) 
                                        (left tree)
                                        (addTree x (right tree))

   -----------------------------------------------------------
   -- Функция-парсер, конструирующая бинарное дерево поиска из
   -- одноуровневого списка lst, элементы которого "поступают"
   -- в дерево в порядке их следования в списке
   --------------------------------------------
   consTree:: [Int] -> BTree
   consTree lst | null lst = nil
                | True     = addTree (last lst) 
                                     (consTree (init lst))

   -----------------------------------------------------------
   -- Функция-развёртка, конструирующая бинарное дерево поиска
   -- из одноуровневого списка, элементы  которого "поступают"
   -- в дерево в порядке, обратном их следованию в списке
   ------------------------------------------------------
   consTree':: [Int] -> BTree
   consTree' = foldr addTree nil

   -----------------------------------------------------------
   -- Функция-развёртка, конструирующая бинарное дерево поиска
   -- из одноуровневого списка lst, элементы которого "поступа-
   -- ют" в дерево в порядке их следования в списке
   ------------------------------------------------
   consTree'':: [Int] -> BTree
   consTree'' = foldl (flip addTree) nil

   ------------------------------------------------------------
   -- Функция, осуществляющая бинарный поиск элемента a в дере-
   -- ве поиска tree:
   --  (1) в случае успеха возвращает поддерево дерева  Tree, в
   -- котором элемент a является корнем;
   --  (2) в случае неудачного поиска функция возвращает пустое
   -- дерево nil
   ------------------------------
   search:: Int -> BTree -> BTree
   search a tree | isEmpty tree = nil
                 | a==root tree = tree
                 | a<root tree  = search a (left tree) 
                 | True         = search a (right tree)

   -----------------------------------------------------------
   -- Функция-предикат, осуществляющая бинарный поиск элемента
   -- a в дереве поиска:
   --  (1) в случае успеха возвращает True;
   --  (2) в случае неудачного поиска - False
   ------------------------------------------
   searchBool:: Int -> BTree -> Bool
   searchBool a tree | isEmpty tree = False
                     | a==root tree = True
                     | a<root tree  = searchBool a (left tree)
                     | True         = searchBool a (right tree)

   -------------------------------------------------------------
   -- Функция, возвращающая самый правый лист дерева поиска tree
   -------------------------------------------------------------
   rightList:: BTree -> Int
   rightList tree | isEmpty (left tree) && isEmpty (right tree)
                                         = root tree
                  | isEmpty (right tree) = rightList (left tree)
                  | True                 = rightList (right tree)

   ------------------------------------------------------------
   -- Функция, возвращающая самый левый лист дерева поиска tree
   ------------------------------------------------------------
   leftList:: BTree -> Int
   leftList tree | isEmpty (left tree) && isEmpty (right tree)
                                       = root tree
                 | isEmpty (left tree) = leftList (right tree)
                 | True                = leftList (left tree)

   -------------------------------------------------------------
   -- Функция, удаляющая узел x из бинарного дерева поиска tree.
   -- Функции delete() и ud() "дословно"  повторяют соответству-
   -- ющие рекурсивные процедуры Н.Вирта [1985] (язык Pascal)
   -- (первый способ)
   ------------------------------
   delete:: Int -> BTree -> BTree
   delete x tree | isEmpty tree = nil
                 | x<root tree  = node (root tree) 
                                       (delete x (left tree))
                                       (right tree)
                 | x>root tree  = node (root tree) 
                                       (left tree)
                                       (delete x (right tree))
                 | isEmpty (right tree)
                                = left tree
                 | isEmpty (left tree)
                                = right tree
                 | True         = node (ud (left tree))
                                       (delete (ud (left tree))
                                               (left tree))
                                       (right tree)
   --------------------------------------------------------
   -- Функция, возвращающая самый "правый" элемент (элемент
   -- с наибольшим ключом) бинарного дерева поиска tree
   ----------------------------------------------------
   ud:: BTree -> Int
   ud tree | isEmpty (right tree) = root tree
           | True                 = ud (right tree)

   --------------------------------------------------------
   -- Функция, удаляющая узел x из бинарного дерева поиска.
   -- Функции delete'()  и  ud'() повторяют соответствующие
   -- рекурсивные процедуры Н.Вирта [1985] (язык Pascal)
   -- (второй способ)
   -------------------------------
   delete':: Int -> BTree -> BTree
   delete' x tree 
              | isEmpty tree = nil
              | x<root tree  = node (root tree) 
                                    (delete' x (left tree))
                                    (right tree)
              | x>root tree  = node (root tree) 
                                    (left tree)
                                    (delete' x (right tree))
              | isEmpty (right tree)
                             = left tree
              | isEmpty (left tree)
                             = right tree
              | True         = node (ud' (right tree))
                                    (left tree)
                                    (delete' (ud' (right tree))
                                             (right tree))
   -------------------------------------------------------
   -- Функция, возвращающая самый "левый" элемент (элемент
   -- с наименьшим ключом) бинарного дерева поиска tree
   ----------------------------------------------------
   ud':: BTree -> Int
   ud' tree | isEmpty (left tree) = root tree
            | True                = ud' (left tree)

   ----------------------------------------------------------
   -- Функция, возвращающая количество уровней в бинарном де-
   -- реве поиска tree (корень дерева расположен на уровне 0)
   ----------------------------------------------------------
   top:: BTree -> Int
   top tree | isEmpty tree = -1
            | True         = 1+max (top (left tree))
                                   (top (right tree))

   ---------------------------------------------------
   -- Функция, возвращающая уровень заданной вершины x
   -- в бинарном дереве поиска tree
   --------------------------------
   topNode:: Int -> BTree -> Int
   topNode x tree | x==root tree = 0
                  | x<root tree  = 1 + topNode x (left tree)
                  | True         = 1 + topNode x (right tree)

   ------------------------------------------
   -- Функция, возвращающая количество вершин
   -- в бинарном дереве поиска tree
   --------------------------------
   nodes:: BTree -> Int
   nodes tree | isEmpty tree = 0
              | True         = 1 + nodes (left tree)
                                 + nodes (right tree)

   -------------------------------------------
   -- Функция, возвращающая количество листьев
   -- в бинарном дереве поиска tree
   --------------------------------
   nList:: BTree -> Int
   nList tree | isEmpty tree = 0
              | isEmpty (left tree) && isEmpty (right tree)
                             = 1
              | True         = nList (left tree) +
                               nList (right tree)

   --------------------------------------------------
   -- Функция, возвращающая количество дуг в бинарном
   -- дереве поиска tree
   ---------------------
   way:: BTree -> Int
   way tree | isEmpty (left tree) && isEmpty (right tree)
                                   = 0
            | isEmpty (left tree)  = 1 + way (right tree)
            | isEmpty (right tree) = 1 + way (left tree)
            | True                 = 2 + way (left tree)
                                       + way (right tree)

   ---------------------------------------------------
   -- Предикат, устанавливающий равенство произвольных
   -- бинарных деревьев поиска tree1 и tree2
   -----------------------------------------
   equalTree:: BTree -> BTree -> Bool
   equalTree tree1 tree2 | isEmpty tree1 && isEmpty tree2
                                   = True
                         | isEmpty tree1 || isEmpty tree2
                                   = False
                         | True    =   root tree1==root tree2
                                    && equalTree (left tree1)
                                                 (left tree2)
                                    && equalTree (right tree1)
                                                 (right tree2)

   -----------------------------------------------------------
   -- Функция, возвращающая копию бинарного дерева поиска tree
   -----------------------------------------------------------
   tCopy:: BTree -> BTree
   tCopy tree | isEmpty tree = nil
              | True         = node (root tree)
                                    (tCopy (left tree))
                                    (tCopy (right tree))

   -- ***************************
   -- Итераторы (обходы деревьев)
   -- ***************************

   -----------------------------------------------------
   -- Функция, осуществляющая левосторонний (нисходящий)
   -- обход бинарного дерева поиска tree
   -------------------------------------
   klpObh:: BTree -> [Int]
   klpObh tree | isEmpty tree = []
               | True         =   [root tree]
                               ++ klpObh (left tree)
                               ++ klpObh (right tree)

   ------------------------------------------------------
   -- Функция, осуществляющая концевой (восходящий) обход
   -- бинарного дерева поиска tree
   -------------------------------
   lpkObh:: BTree -> [Int]
   lpkObh tree | isEmpty tree = []
               | True         =   lpkObh (left tree)
                               ++ lpkObh (right tree)
                               ++ [root tree]

   -----------------------------------------------------
   -- Функция, осуществляющая обратный (смешанный) обход
   -- бинарного дерева поиска tree
   -------------------------------
   lkpObh:: BTree -> [Int]
   lkpObh tree | isEmpty tree = []
               | True         =   lkpObh (left tree)
                               ++ [root tree]
                               ++ lkpObh (right tree)

   ---------------------------------------------
   -- Функция, осуществляющая двойственный обход
   -- бинарного дерева поиска tree
   -------------------------------
   klkpObh:: BTree -> [Int]
   klkpObh tree | isEmpty tree = []
                | True         =    [root tree]
                                ++ klkpObh (left tree)
                                ++ [root tree]
                                ++ klkpObh (right tree)

   -- ***********************
   -- Функционалы на деревьях
   -- ***********************

   ----------------------------------------------
   -- Моделирование функционала map для бинарного
   -- дерева поиска tree
   ----------------------------------------
   mapBTree:: (Int ->Int) -> BTree -> BTree
   mapBTree f tree | isEmpty tree = nil
                   | True         = node (f (root tree))
                                         (mapBTree f (left tree))
                                         (mapBTree f (right tree))

   -------------------------------------------------
   -- Моделирование функционала filter для бинарного
   -- дерева поиска tree (возвращается дерево)
   -------------------------------------------
   filterBT:: (Int -> Bool) -> BTree -> BTree
   filterBT p tree 
        | isEmpty tree  = nil
        | p (root tree) = node (root tree) 
                               (filterBT p (left tree))
                               (filterBT p (right tree))
        | True          = delete (root tree)
                                 (node (root tree) 
                                       (filterBT p (left tree))
                                       (filterBT p (right tree)))

   --------------------------------------------------------
   -- Функция, генерирующая псевдослучайное бинарное дерево
   -- поиска, содержащее m-n+1 целое число из [0,a-1]
   --------------------------------------------------
   newRndTree:: Int -> Int -> Int -> BTree
   newRndTree n m a = consTree (newRndLst n m a)
     where
          -------------------------------------------
          -- Функция, генерирующая конечный подсписок
          -- целых чисел
          --
          -- a ,a   ,...,a ,
          --  n  n+1      m
          --
          -- принадлежащих [0,a-1], из потенциально бес-
          -- конечного списка псевдослучайного чисел
          ------------------------------------------
          newRndLst n m a = 
            drop n (take (m+1) 
                     [x `mod` a | x <- iterate next_seed 23765492])
          ---------------------------------------------------------
          -- Функция, возвращающая псевдослучайное число
          ----------------------------------------------
          next_seed n = case test>0 of
                          True  -> test
                          False -> test+2147483647
               where test = 48271*lo-3399*hi 
                     hi   = n `div` 44488 
                     lo   = n `mod` 44488
   --------------------------------------------------------
   -- Функция, сортирующая (по возрастанию) элементы число-
   -- вого списка с помощью бинарного дерева поиска
   ------------------------------------------------
   sort:: [Int] -> [Int]
   sort = lkpObh . consTree

   -- ************************************
   -- Визуализация бинарного дерева поиска
   -- ************************************

   --------------------------------------------------
   -- Функция, изображающая дерево поиска tree в виде
   -- строки символов (при вызове l:=0)
   ------------------------------------
   drawTree:: BTree -> Int -> String
   drawTree tree l | isEmpty tree = ""
                   | True         = drawTree (right tree) (l+1) ++
                                    "\n" ++ 
                                    replicate (l*3) ' ' ++
                                    show (root tree) ++
                                    drawTree (left tree) (l+1)

   ----------------------------------------------------
   -- Функция, изображающая бинарное дерево поиска tree
   -- на экране дисплея
   -----------------------
   outTree:: BTree -> IO()
   outTree tree = putStr (drawTree tree 0 ++ "\n")

   ------------------------------------------------------
   -- Функция, представляющая бинарное дерево поиска tree
   -- в виде "обычного" списка, т.е. без указания  конст-
   -- руктора Node
   ------------------------
   outTree':: BTree -> IO()
   outTree' tree = putStr (show tree)

   --------------------------------------------------------
   -- Представление типа BTree в качестве экземпляра класса
   -- Show с определением  метода, представляющего бинарное
   -- дерево поиска без указания имени конструктора Node
   -----------------------------------------------------
   instance Show BTree
     where show tree
               | isEmpty tree = "Nil"
               | list (root tree)==tree 
                              = "(" ++ show (root tree) ++
                                " Nil" ++ " Nil" ++ ")"
               | True         = "(" ++ show (root tree) ++
                                " " ++ show (left tree) ++
                                " " ++ show (right tree) ++ ")"

   -- **************************************************
   -- П л о х и е  реализации функций с точки зрения АТД
   -- (аргументами функций являются конструкторы данных)
   -- **************************************************

   ----------------------------------------------
   -- Моделирование функционала map для бинарного
   -- дерева поиска tree
   -----------------------------------------
   mapBTree':: (Int ->Int) -> BTree -> BTree
   mapBTree' _ Nil          = nil
   mapBTree' f (Node x l r) = node (f x)
                                   (mapBTree' f l)
                                   (mapBTree' f r)
   ---------------------------------------------------------
   -- Функция, изображающая дерево поиска tree в виде строки
   -- символов (при вызове l=0)
   -- (с использованием сопоставления с образцом)
   ----------------------------------------------
   drawTree':: BTree -> Int -> String
   drawTree' Nil k          = ""
   drawTree' (Node x l r) k = drawTree' r (k+1)
                              ++ "\n" ++ replicate (k*3) ' '
                              ++ show x
                              ++ drawTree' l (k+1)
