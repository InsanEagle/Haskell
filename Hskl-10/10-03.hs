   -- Демонстрация формальных преобразований функций на языке
   -- Haskell  с  использованием комбинаторного исчисления на
   -- примере вычисления значения арифметического выражения
   --
   --   odd(x)&&even(y)
   -- *****************************
   -- Функция fun1 до трансформации
   --------------------------------
   fun1:: Int -> Int -> Bool 
   fun1 x y = (&&) (odd x) (even y)
   ---------------------------------------------
   -- Демонстрация по шагам этапов трансформации
   -- с помощью комбинаторов:
   --
   --   Babc=a(bc), Cabc=acb
   -----------------------------------------------
   -- M(Px)(Qy) = (M(Px))(Qy)  = (BMPx)(Qy)      =
   --           = (BMP)x(Qy)   = C(BMP)(Qy)x     =
   --           = B(C(BMP))Qyx = C(B(C(BMP))Q)xy     
   ---------------------------------------------
   -- Демонстрация по шагам этапов трансформации
   -- с помощью языка Haskell:
   --   (1) flip - это аналог комбинатора C;
   --   (2) (.)  - это аналог комбинатора B
   ----------------------------------------
   z1 = (&&) (odd 3) (even (-4))
   z2 = ((&&) (odd 3)) (even (-4))
   z3 = ((.) (&&) (odd) 3) (even (-4))
   z4 = ((.) (&&) (odd)) 3 (even (-4))
   z5 = flip ((.) (&&) (odd)) (even (-4)) 3
   z6 = (.) (flip ((.) (&&) (odd))) (even) (-4) 3
   z7 = flip ((.) (flip ((.) (&&) (odd))) (even)) 3 (-4)
   -- **************************************************
   -- Функция fun1 после трансформации
   -----------------------------------
   fun2:: Int -> Int -> Bool   
   fun2 x y = flip ((.) (flip ((.) (&&) (odd))) (even)) x y
   --------------------------------------------------------
   -- Функция fun1 после трансформации (в виде комбинатора)
   -------------------------------------------------------- 
   fun2':: Int -> Int -> Bool 
   fun2' = flip ((.) (flip ((.) (&&) (odd))) (even))
   -- **********************************************
   -- Неудачные тестовые примеры:
   -----------------------------------------
   test = fun1  5 6 && fun2 5 6 && fun2' 5 6
