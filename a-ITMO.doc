                   3Функциональное программирование 0
                    (для групп 4742-4743, ИТМО)
                   (А.А.Кубенский, 2011, осень)

   Студенты решают каждый задачу своего варианта. Вариант определя-
ется первой буквой фамилии:
   * 1 вариант - фамилии, начинающиеся на буквы А-Г;
   * 2 вариант - фамилии, начинающиеся на буквы Е-К;
   * 3 вариант - фамилии, начинающиеся на буквы Л-П;
   * 4 вариант - фамилии, начинающиеся на буквы Р-Я.

                            2Условия задач
    _ 1Задача 1 . 0 (3 балла, последний срок присылки - 23 сентября).

    2Вариант 1 0 (А-Г).
   Функция
 ш1.0

   amember :: Double -> Double -> Int -> Double

 ш1.2
должна возвращать n-ый член арифметической прогрессии (члены  прог-
рессии нумеруются с нуля). Аргументами функции являются первый член
прогрессии, шаг, n.
   Например,
 ш1.0

   > amember 1 2 5
   11
 ш1.2

    2Вариант 2 0 (Е-К).
   Функция
 ш1.0

   mutual :: Integer -> Integer -> Boolean

 ш1.2
определяет, являются  ли  заданные  два  натуральных  числа взаимно
простыми.
   Например,
 ш1.0

   > mutual 25 14    > mutual 12 39
   True,             False
 ш1.2

    2Вариант 3 0 (Л-П).
   Функция
 ш1.0

   sumdiv :: Integer -> Integer

 ш1.2
выдает сумму всех делителей заданного положительного числа, включая
единицу, но исключая само это число.
   Например,
 ш1.0

   > sumdiv 36
   1+2+3+4+6+9+12+18 = 55
 ш1.2

    2Вариант 4 0 (Р-Я).
   Функция
 ш1.0

   inverse :: Integer -> Integer

 ш1.2
должна по заданному числу выдавать число, десятичная запись которо-
го содержит цифры исходного числа в обратном порядке.
   Например,
 ш1.0

   > inverse 36     > inverse 1050
   63               501
 ш1.2

.
    _ 1Задача 2 . 0 (4 балла, последний срок присылки - 30 сентября).

    2Вариант 1 0 (А-Г).
   Функция
 ш1.0

   root :: Double -> Double

 ш1.2
должна вычислить приближённое значение корня уравнения  cos(x)=x  с
точностью, заданной первым (и единственным) аргументом функции.

    2Вариант 2 0 (Е-К).
   Функция
 ш1.0

   summ :: Double -> Double -> Double

вычисляет сумму ряда с общим членом

   u 4n 0=x 4n+1 0/(n!+1),

 ш1.2
x - первый аргумент функции,  n=0,1,... Вычисления производить пока
очередной член ряда не станет по абсолютной  величине  меньше,  чем
число, заданное вторым аргументом функции.

    2Вариант 3 0 (Л-П). Функция
 ш1.0

   ch :: Double -> Integer -> Double

 ш1.2
должна вычислять значение гиперболического косинуса в заданной точ-
ке путем суммирования некоторого числа первых членов ряда в  разло-
жении этой функции в ряд Тейлора. Количество суммируемых членов за-
дается вторым аргументом функции.

    2Вариант 4 0 (Р-Я).
   Функция
 ш1.0

   harmonic :: Double -> Integer

 ш1.2
должна вычислить число членов гармонического  ряда,  которое  нужно
просуммировать, чтобы сумма ряда превысила число, заданное аргумен-
том функции.
   Ввиду ограниченной точности вычислений не следует задавать  тес-
ты, в которых суммируется более миллиона членов ряда.
.
    _ 1Задача 3 . 0 (6 баллов, последний срок присылки - 7 октября).

    2Вариант 1 0 (А-Г).
   Функция
 ш1.0

   maxthree :: [Integer] -> [Integer]

 ш1.2
получает список  целых  и выдает список той же длины,  содержащий в
качестве i-го элемента максимальные значения трех элементов  списка
- i-го, (i-1)-го и (i+1)-го.
   Например,
 ш1.0

   > maxthree [3,8,6,5,1]
   [8,8,8,6,5].
 ш1.2

    2Вариант 2 0 (Е-К).
   Функция
 ш1.0

   summator :: [Integer] -> [Integer]

 ш1.2
получает список  целых и выдает список,  содержащий в качестве i-го
элемента суммы первых i членов исходного списка.
   Например,

   > summator [3,2,6,5,1]
   [3,5,11,16,17]

    2Вариант 3 0 (Л-П).
   Функция
 ш1.0

   maxString :: [String] -> String

 ш1.2
выдает самую длинную строку заданного списка.

    2Вариант 4 0 (С-Я).
   Функция
 ш1.0

   remove-Even :: [String] -> [String]

 ш1.2
по заданному списку строк строит список, в котором содержатся те же
строки,  что и в исходном списке, но каждая вторая строка из списка
выброшена, а в оставшихся строках выброшен каждый второй символ.
   Например,
 ш1.0

   >remove-Even ["one","two","three","four","five"],
   ["oe","tre","fv"].
 ш1.2

.
    _ 1Задача 4 . 0 (7 баллов, последний срок присылки - 14 октября).

   При решении этой задачи требуется  использовать  функции  высших
порядков - стандартные или определённые вами в ходе решения.
   "Рекурсивные" решения засчитываются, но с максимальной оценкой 4
балла (при отсутствии других недостатков).

    2Вариант 1 0 (А-Г).
   Функция
 ш1.0

   split :: String -> Char -> [String]

 ш1.2
разрезает исходную строку на куски,  разделённые в исходной  строке
символом, указанным в качестве второго аргумента функции.
   Например,
 ш1.0

   > split "one,two,,three," ','
   ["one", "two", "", "three", ""]
 ш1.2

    2Вариант 2 0 (Е-К).
   Функция
 ш1.0

   join :: [String] -> Char -> String

 ш1.2
должна склеить  исходный список строк в одну строку,  вставив между
исходными кусками символ, заданный вторым аргументом.
   Например,
 ш1.0

   > join ["one","two","","three",""] ':'
   "one:two::three:".
 ш1.2

    2Вариант 3 0 (Л-П).
   Функция
 ш1.0

   grow :: [Integer] -> [[Integer]]

 ш1.2
получает список целых и выдает список неубывающих фрагментов исход-
ного списка.
   Например,
 ш1.0

   > grow [3,3,8,6,5,7]
   [[3,3,8],[6],[5,7]].
 ш1.2

    2Вариант 4 0 (Р-Я).
   Матрица задаётся типом данных
 ш1.0

   type Matrix a = [[a]].

   Функция умножения матриц

   multM :: Num a => Matrix a -> Matrix a -> Matrix a

 ш1.2
получает на вход две числовые прямоугольные матрицы подходящих раз-
меров и выдает их произведение.
   Проверку размеров матриц можно не производить.
.
    _ 1Задача 5 . 0 (9 баллов, последний срок присылки - 21 октября).

   В этой задаче используются следующие описания стандартных и нес-
тандартных типов данных:
 ш1.0

   -- Это стандартный тип данных из библиотеки Prelude:
   data  Maybe a = Nothing | Just a

   -- Это тип данных из лекций:
   data BinTree a = Empty | Node (BinTree a) a (BinTree a)

   -- Это новый тип данных.
   -- В узле дерева находится список его потомков  (возможно,  пус-
той)
   data Tree a = Node a [Tree a]
 ш1.2

    2Вариант 1 0 (А-Г).
   Функция
 ш1.0

   fluffy :: Tree a -> Int

 ш1.2
вычисляет максимальный показатель "ветвистости" узлов дерева.
   Показатель "ветвистости" узла - это количество поддеревьев этого
узла.

    2Вариант 2 0 (Е-К).
   Функция
 ш1.0

   isHeap :: Ord a => Tree a -> Bool

 ш1.2
проверяет, верно ли, что дерево является  _ 1пирамидой . 0, т.е. что значе-
ние в каждом из его узлов меньше значений, хранящихся в поддеревьях
этого узла.

    2Вариант 3 0 (Л-П).
   Функция
 ш1.0

   optimalTree :: Ord a => [a] -> BinTree a

 ш1.2
строит оптимальное  двоичное  дерево  поиска из элементов заданного
списка.
   Двоичное дерево называется  _ 1оптимальным . 0, если на каждом его уров-
не с номером (k) содержится ровно 2k узлов,  кроме,  возможно, пос-
леднего уровня, на котором может находиться и меньшее число узлов.

    2Вариант 4 0 (Р-Я).
   Функция
 ш1.0

   getMaxParent :: Ord a => Tree a -> Maybe a

 ш1.2
выдает значение некоторого узла дерева,  которое больше, чем значе-
ния непосредственных потомков этого узла.
   Если такого узла в дереве нет, то выдается значение Nothing.
   Если таких узлов несколько, то выдается значение любого из них.
.
    _ 1Задача 6 . 0 (11 баллов, последний срок присылки - 28 октября).

   Во всех  вариантах этой задачи требуется построить "бесконечные"
списки.

    2Вариант 1 0 (А-Г).
   Составить бесконечный список частичных сумм ряда, представляюще-
го собой разложение числа  1e 0,  полученное подстановкой единицы в ряд
Тейлора для экспоненты.  Написать функцию для получения n-го  члена
этой последовательности.

    2Вариант 2 0 (Е-К).
   Составить бесконечный  список  последовательностей  биномиальных
коэффициентов C(n,m) ( 1треугольник Паскаля 0):
 ш1.0

   1 1 1 1 2 1 1 3 3 1 1 4 6 4 1...,

пользуясь для построения соотношением

   C(n,m)=C(n-1,m-1)+C(n-1,m).

 ш1.2
   Для проверки правильности составления треугольника можно исполь-
зовать функцию
 ш1.0

   comb(n,m)=(n!)/(m!*(n-m)!)
 ш1.2

    2Вариант 3 0 (Л-П).
   Бесконечная упорядоченная последовательность целых положительных
чисел без повторений составлена из всех чисел вида 2k, 3*2k и чисел
Фибоначчи.  Составить программу для вычисления n-го члена этой пос-
ледовательности.

    2Вариант 4 0 (Р-Я).
   Составить список простых чисел вида 2n+1.
   Написать функцию для выбора k-го члена этого списка  (навряд  ли
удастся получить больше пяти членов этого списка...).
.
    _ 1Задача 7 . 0 (очень сложная! 12 баллов,
             последний срок присылки - 11 ноября).

   При решении этой задачи не надо добиваться  максимальной  эффек-
тивности, хотя, конечно, чем эффективнее решение, тем оно лучше.
   Во всех вариантах задачи требуется просто осуществить правильный
перебор всех вариантов.

    2Вариант 1 0 (А-Г).
   Определить, можно ли расставить знаки <+>,  <->,  <*> и  круглые
скобки между числами 1,2,...,10 (именно в этом порядке,  без перес-
тановок) так,  чтобы в результате выполнения всех действий  получи-
лось заданное число.
   Функция должна получать на вход число и выдавать строку, изобра-
жающую  правильную расстановку знаков и скобок,  или строку "impos-
sible", если заданное число получить невозможно.
   Например, для числа 2011 возможный вариант мог бы выглядеть так:
 ш1.0

   (1+((2*3)+(4+(5*((6*((7*8)+9))+10)))))

 ш1.2
(конечно, в этой записи некоторые скобки - лишние)

    2Вариант 2 0 (Е-К).
   Найти последовательность полей  квадратной  доски  размером  NхN
клеток,  получающуюся обходом всех полей доски ходом шахматного ко-
ня,  который должен побывать на каждом поле ровно один раз. Функция
должна выдавать список пар координат полей.
   Например, для N=5 возможный результат мог бы выглядеть так:
 ш1.0

   [(1,1),(2,3),(1,5),(3,4),(1,3),(2,1),(4,2),(5,4),(3,5),
    (1,4),(2,2),(4,1),(3,3),(2,5),(4,4),(5,2),(3,1),(1,2),
    (2,4),(4,5),(5,3),(3,2),(5,1),(4,3),(5,5)].

 ш1.2
   Если вариантов обхода нет,  функция должна выдавать разумный ре-
зультат,  например, пустой список или сообщение "No path", или зна-
чение Nothing.

    2Вариант 3 0  (Л-П).
   Найти все способы разбиения заданной строки символов на слова из
заданного словаря или определить, что такого разбиения не существу-
ет. Функция должна получать в качестве аргументов исходную строку и
список попарно несовпадающих слов (словарь),  а в результате  выда-
вать список возможных разбиений (каждое разбиение - это список слов
из словаря, при соединении которых получается исходная строка).
   Например, для  исходной строки "мой дядя самых честных правил" и
словаря
 ш1.0

  ["александр","дядя","Пушкин"," ","правил","честных","мой","самых"]

результатом должен быть список

   [["мой"," ","дядя"," ","самых"," ","честных"," ","правил"]].

 ш1.2
   Если вариантов разбиения исходной строки нет, функция должна вы-
давать разумный результат, например, пустой список.

    2Вариант 4 0 (Р-Я).
   Найти все способы представления заданной суммы денег в рублях  в
виде набора монет достоинством в 1,2,5,10 рублей.
   Например, результат для суммы в 5 рублей мог бы выглядеть так:
 ш1.0

   [[1,1,1,1,1],[1,1,1,2],[1,2,2],[5]]

 ш1.2
   Учтите, что  в результате не должно быть наборов,  различающихся
только порядком монет (наборы [1,2,2] и [2,1,2] считаются  одинако-
выми и не должны присутствовать в результате вместе). Вид представ-
ления результата произволен,  например, вышеописанный результат мог
бы быть представлен также в виде
 ш1.0

   [[(5,1)],[(3,1),(1,2)],[(1,1),(2,2)],[(1,5)]] или

   ["5*1","3*1+1*2","1*1+2*2","1*5"].
 ш1.2

.
    _ 1Задача 8 . 0 (очень сложная! 13 баллов,
             последний срок присылки - 18 ноября).

   При решении этой задачи не надо добиваться  максимальной  эффек-
тивности, хотя, конечно, чем эффективнее решение, тем оно лучше.
   Во всех вариантах задачи используется функциональное представле-
ние графов:
 ш1.0

   type Graph = (Int, Int -> Int -> Bool).

 ш1.2
в котором предполагается, что вершины графа (n,f) занумерованы чис-
лами от 1 до n, причем вершины i и j соединены ребром тогда и толь-
ко тогда, когда функция f выдает истину на паре аргументов i и j.
   Во всех вариантах граф предполагается неориентированным, так что
если он задается парой (n, f), то для всех i,j из диапазона от 1 до
n если верно f i j, то верно и f j i.

    2Вариант 1 0 (А-Г).
   Написать функцию
 ш1.0

   diameter :: Graph -> Int,

 ш1.2
вычисляющую диаметр заданного графа.
    _ 1Диаметром графа . 0 называется максимальное из расстояний между все-
ми парами его вершин. Граф предполагается связным.

    2Вариант 2 0 (Е-К).
   Написать функцию
 ш1.0

   biGraph :: Graph -> Bool,

 ш1.2
проверяющую, является ли граф  _ 1двудольным . 0,  т.е.  можно ли множество
его вершин разбить на два непустых подмножества таким образом,  что
концы любого ребра графа будут принадлежать разным множествам.
   Граф предполагается связным.

    2Вариант 3 0 (Л-П).
   Написать функцию
 ш1.0

   getBridges :: Graph -> [(Int,Int)],

 ш1.2
выдающую список всех мостов графа.  Исходный граф может быть и нес-
вязным.

    2Вариант 4 0 (Р-Я).
   Написать функцию
 ш1.0

   components :: Graph -> [[Int]],

 ш1.2
выдающую список  компонентов  связности  графа.  Каждая  компонента
представлена списком номеров вершин.
.
    _ 1Задача 9 . 0 (7 баллов, последний срок присылки - 2 декабря).

   Во всех вариантах этой задачи используется следующее представле-
ние лямбда-выражений расширенного лямбда-исчисления:
 ш1.0

   data Expression = 
     Integral Integer |
     Function String |
     Variable String |
     Lambda String Expression |
     Apply Expression Expression
 ш1.2

    2Вариант 1 0 (А-Г).
   Написать функцию
 ш1.0

   alfa :: String -> String -> Expression -> Expression,

 ш1.2
которая выполняет  переименование всех свободных переменных,  имена
которых заданы первым аргументом,  в имя,  заданное вторым аргумен-
том. Третий аргумент представляет исходное выражение.
   Например,
 ш1.0

   > alfa "x" "y" (Apply (Lambda "x" (Variable "x")) (Variable "x"))
   (Apply (Lambda "x" (Variable "x")) Variable "y")
 ш1.2

    2Вариант 2 0 (Е-К).
   Написать функцию
 ш1.0

   hasEta :: Expression -> Bool,

 ш1.2
которая проверяет,  есть ли в заданном выражении ?-редекс, т.е. вы-
ражение вида (?x.(e x)),  где в выражении e нет свободных вхождений
переменной "x".

    2Вариант 3 0 (Л-П).
   Написать функцию
 ш1.0

   hasBeta :: Expression -> Bool,

 ш1.2
которая проверяет, есть ли в заданном выражении хоть один ?-редекс.

    2Вариант 4 0 (Р-Я).
   Написать функцию
 ш1.0

   free :: Expression -> [String],

 ш1.2
которая выдает список имен свободных переменных  заданного  выраже-
ния.
   Список должен  быть  упорядочен в алфавитном порядке и не содер-
жать повторений.

.
    _ 1Задача 10 . 0 (8 баллов, последний срок присылки - 23 декабря).

   Рассматривается простой императивный язык  программирования  для
вычислений в целых числах,  содержащий следующие конструкции: выра-
жения, состоящие из целых констант, переменных целого типа и опера-
ций; присваивание; последовательное выполнение операторов.
   Абстрактный синтаксис этого языка  выражен  описанием  следующих
типов данных:
 ш1.0

   data Expression = Constant Integer |
                     Variable String |
                     Unary Char Expression |
                     Binary Expression Char Expression
   data Operator = Assignment String Expression |
                   Sequence [Operator]

 ш1.2
   Программа - это значение типа Operator.

    2Вариант 1 0 (А-Г).
   Функция
 ш1.0

   removeAssignments :: Operator -> String -> Operator

 ш1.2
удаляет из  заданной программы все операторы присваивания,  в левых
частях которых стоит переменная, заданная вторым аргументом.
   Если в результате  работы  будут  получаться  последовательности
операторов с пустым списком операторов, то такие "последовательнос-
ти" также следует удалить (только если это не окончательный резуль-
тат обработки).

    2Вариант 2 0 (Е-К).
   Функция
 ш1.0

   plus0 :: Operator -> Operator

 ш1.2
проверяет, есть  ли  в  программе  выражения вида '0+е' или 'е+0' и
строит новую программу, в которой такие выражения превращены просто
в 'е'. Обратите внимание на то, что в результате преобразования вы-
ражения '0+0' может образоваться новое выражение вида 'e+0',  кото-
рое тоже следует преобразовать!

    2Вариант 3 0 (Л-П).
   Функция
 ш1.0

   doPlus :: Operator -> Operator

 ш1.2
преобразует в заданной программе все выражения типа 'a+b',  где a и
b - константы,  в константу, содержащую сумму значений (то есть вы-
ражение Binary (Constant 3) '+' (Constant 5) должно  быть  заменено
на Constant 8).
   Обратите внимание, что в результате таких преобразований выраже-
ний, содержащих сумму констант, должно в программе не остаться сов-
сем!

    2Вариант 4 0 (Р-Я).
   Функция
 ш1.0

   undefinedUsed :: Operator -> [String]

 ш1.2
выдает список переменных,  которые встречаются в выражениях раньше,
чем  они появились в левой части какого-нибудь оператора присваива-
ния.
   Вложенность операторов роли не играет (все переменные  считаются
глобальными).
   Если переменная  в первый раз встретилась одновременно и в левой
и в правой частях оператора присваивания,  то  такое  использование
переменной также считается некорректным.
