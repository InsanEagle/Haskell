                     3Функции высшего порядка как
                       3средство доказательства
   Доказав некоторое утверждение о функции map,  мы затем переносим
его на все функции,  являющиеся применением map. Причем, вовсе нео-
бязательно, чтобы определения этих функций явно использовали map.
   Достаточно, чтобы они допускали такое представление.
   Так, из определения
 ш1.0

   twice([])     = []
   twice([x|xs]) = [2*x|twice(xs)]

мы тут же заключаем

   twice(xs++ys)=twice(xs)++twice(ys).

 ш1.2
   Это заключение основано на уже доказанном утверждении о  функции
map
 ш1.0

   map(f,xs++ys)=map(f,xs)++map(f,ys)

и на том факте, что

   twice(xs)=map(f,xs), f(x)=2*x.

 ш1.2
                          3Оператор свёртки
   Одна функция высшего порядка,  охватывающая очень общий  образец
рекурсии - это оператор свертки. Обычно он определяется так:
 ш1.0

   foldr(f,a,[])     = a;
   foldr(f,a,[x|xs]) = f(x,foldr(f,a,xs)).

   Смысл этого оператора виден из следующего примера.

   foldr(+,a,[x1,x2,...xn]) = foldr(+,a,[x1|[x2|...[xn|[]]...])=

                            = (x1+(x2+...(xn+ a)...))

 ш1.2
   Список выписан в явном (развернутом) виде,  чтобы показать,  что
каждый конструктор "|" заменяется применяемой  операцией  ("+"),  а
конструктор  "[]",  которым заканчивается каждый список - значением
a.
   В программировании  оператор  свертки  появился  под  названиями
 _ 1приведение . 0 или  _ 1вставка . 0 и определялся для непустых списков:
 ш1.0

   foldr(f,[x])    = x
   foldr(f,[x|xs]) = f(x,foldr(f,xs)).

 ш1.2
   Название " 1вставка 0" связано с тем, оператор как бы вставляет знак
операции между элементами списка.
 ш1.0

   foldr(+,[x1,x2,...xn]) = x1+x2+...xn

 ш1.2
   Нетрудно показать что,  если e - правый нейтральный элемент  би-
нарной операции f, а xs - непустой список то
 ш1.0

   foldr(f,xs)=foldr(f,e,xs).

   С другой стороны, для любого значения a и любого списка xs.

   foldr(f,a,xs)=foldr(f,xs++[a]).

 ш1.2
   Итак, оба варианта по сути эквивалентны и выбор  одного  из  них
определяется соображениями удобства. Но все же первый более интере-
сен с теоретической точки зрения.
   Множество знакомых функций на списках допускает простое  опреде-
ление через свертку. Например:
 ш1.0

   sum(xs)    = foldr(+,0,xs)
   prod(xs)   = foldr(*,1,xs)
   all(xs)    = foldr(and,true,xs)
   any(xs)    = foldr(or,false,xs)
   concat(xs) = foldr(++,[],xs)

 ш1.2
   Теперь рассмотрим некоторые функции и увидим, как они выражаются
через свертку.
                     _ 1Функция идентичности . 0 id(x)=x
 ш1.0

   id([])     = []
   id([x|xs]) = [x|xs]

   id(x) = foldr(cons,[],x),

 ш1.0
где cons(x,xs) = [x|xs] - просто имя для конструктора списка.
   Очевидно, это не общее определение функции идентичности. Это оп-
ределение идентичности для списков.  На первый взгляд не видно осо-
бого смысла представлять её таки образом, но чуть ниже нам это при-
годится.
                     _ 1Соединение списков . 0 (append).
   Казалось бы, эта функция не попадает под схему рекурсии, охваты-
ваемую сверткой. Но если рассмотреть частичное применение
 ш1.0

   appendys(xs) = xs ++ ys,

легко видеть, что

   appendys([]) = ys
   appendys([x|xs]) = cons(x,appendy(xs)).

   Таким образом

   appendys(x) = foldr(cons,ys,x)

или

   xs ++ ys = foldr(cons,ys,x).

 ш1.2
   Как видно,  операция  свертки обладает большой общностью и может
использоваться,  чтобы выразить множество функций.  Но эта общность
имеет обратную сторону. Свойства, которыми она обладает, оказывают-
ся слишком слабыми. Например, нетрудно убедится, что
 ш1.0

   foldr(f,a,xs++ys) = foldr(f,foldr(f,a,ys),xs).

   Применив это свойство к определению

   sum(xs) = foldr(+,0,xs),

получим

   sum(xs++ys) = foldr(+,sum(ys),xs)

 ш1.2
   Но это несколько не то, что нам хотелось бы получить.
   Для того, чтобы доказывать более интересные свойства, потребует-
ся привлечь дополнительные условия. Одно из таких условий - ассоци-
ативность операции.
   Повторяя рассуждения о функции sum, получаем следующее утвержде-
ние.
   Если операция f  ассоциативна  а  e  -  её  нейтральный  элемент
 ш1.0

   (f(a,f(b,c) = f(f(a,b)c) и f(x,e)=x ),

то
   foldr(f,e, xs ++ ys) = f( foldr(f,e,xs),  foldr(f,e,ys))

   Отсюда легко получаются такие утверждения, как

   sum(xs++ys)  = sum(xs) + sum(ys)
   prod(xs++ys) =  prod(xs) * prod(ys)
   all(xs++ys)  = all(xs) and all(ys)

 ш1.2
   Это свойство допускает простое обобщение.
   Пусть операции f и g связаны соотношением
 ш1.0

   f(x,g(y,z))=g(f(x,y),z)

 ш1.2
(при g=f  это  в  точности  означает  ассоциативность  f)  и  пусть
g(e,x)=x. Тогда
 ш1.0

   foldr(f,e,xs++ys) = g(foldr(f,e,xs),foldr(f,e,ys))

   Положив g=+, f=suc2, e=0, получим

   (suc2(x,y+z) = suc2(x,y)+z).

   Отсюда

   length(xs ++ ys) = length(xs) + length(ys)

   Пусть теперь

   g = ++ и e= [].

   Если f удовлетворяет условию

   f(x,y++z) = f(x,y)++z,

то
   foldr(f,e,xs++ys) = foldr(f,e,xs)++foldr(f,e,ys)

 ш1.2
   Поскольку определённые операции acons и ccons ему удовлетворяют,
то получаем
 ш1.0

   map(f,xs++ys)    = map(f,xs)++map(f,ys)
   filter(p,xs++ys) = filter(p,xs)++filter(p,ys).

   При g(x,y) = y++x, условие для f принимает вид

   f(x,z++y) = z++f(x,y).

 ш1.2
   Очевидно, что оно выполняется для функции snoc.
   Поэтому
 ш1.0

   reverse(xs++ys) = reverse(ys) ++ reverse(xs)

 ш1.2
   Обозначим
 ш1.0

   h(xs) = foldr(f,e,xs).

   Тогда, учитывая полученные результаты

   h([])     = e
   h(xs++ys) = g(h(xs),h(ys))

   Только эти свойства h нам и понадобятся, чтобы вывести, что

   h(concat(xs)) = h(x 41 0++...++x 4n 0) = g(h(x 41 0),g(h(x 42 0),...,h(x 4n 0))..) =

          = foldr(g,e,[h(x 41 0),...,h(x 4n 0)] = foldr(g,e,map(h,xs)).

   Отсюда простой подстановкой получаем

   length(concat(xs)) = sum(map(length,xs))
   sum(concat(xs))    = sum(map(sum,xs))
   all(concat(xs))    = all(map(all,xs))
   f*(concat(xs))     = concat(map(f*,xs))
   p?(concat(xs))     = concat(map(p?,xs))

   Вспоминая что

   concat(xs) = foldr(++,[],xs),

 ш1.2
можно предположить, что аналогичное свойство должно выполняться для
свертки любой операции.
   Действительно, можно показать что, если
 ш1.0

   f(g(x,y)) = h(f(x),f(y))

то
   f(foldr(g,a,xs)) = foldr(h,f(a),map(f,xs)).

   Рассматривая этот закон для логических функций f и положив

   h=and,

получим: если

   f(a)      = true,
   f(g(x,y)) = f(x) and f(y)

то
   f(foldr(g,a,xs)) = foldr(and,true,map(f,xs)) = all(map(f,xs)).

 ш1.2
   С практической точки зрения полезно перейти от равенства к отно-
шению логического следования. Кроме того, удобнее рассматривать не-
пустые списки.
   Тогда можно сформулировать следующий закон.
   Если
 ш1.0

   f(x) and f(y) => f(g(x,y)),

то
   all(map(f,xs)) => f(foldr(g, xs)).

 ш1.2
   Другими словами,  если  бинарная  операция  сохраняет  некоторое
свойство, то свертка этой операции также сохраняет это же свойство.
                            _ 1Левая свертка
   Рассматриваемый оператор обычно называют  _ 1правой сверткой . 0,  пото-
му, что операции выполняются справа налево.
   Мы определяли и  _ 1левую свертку . 0 (foldl) выполняющую операции слева
направо.
 ш1.0

   foldl(+,a,[x 41 0,x 42 0,...x 4n 0]) = (...(a+x 41 0)+x 42 0)+...+x 4n 0).

   Левая свертка определяется уравнениями

   foldl(f,a,[])     = a
   foldl(f,a,[x|xs]) = foldl(f,g(a,x),xs).

 ш1.2
и охватывает другой образец рекурсии - вычисления с накопителями.
   Действительно функцию f, определённую уравнениями
 ш1.0

   f([],a)     = a
   f([x|xs],a) = f(xs,g(a,x))

можно представить как левую свертку

   f(xs,a) = foldl(g,a,xa)

 ш1.2
   Как мы знаем,  функции, записанные в виде с хвостовой рекурсией,
обычно более эффективны.  Поэтому левая свертка должна  выполняться
эффективнее правой и с этой точки зрения предпочтительнее.
   В то же время многие функции естественно выражаются в виде  пра-
вой  свертки,  а построение процедур с накопителями требует опреде-
ленного искусства.
   Интересно найти  _ 1законы . 0, которые позволяли бы переходить от одной
формы к другой.
   Анализ примеров с суммой позволяет сформулировать теорему.
    2Теорема 0 ( 1первый закон двойственности для свертки 0).
 ш1.1
   Если f - ассоциативная операция, e - нейтральный элемент, то:
 ш1.0

   foldl f e xs = foldr f e xs.

 ш1.2
    2Доказательство 0. Воспользуйтесь индукцией.

   Различие между [] и [x|xs] иногда недостаточно для доказательст-
ва. Вам придётся различать три случая: пустой список, список из од-
ного элемента и список по крайней мере с двумя элементами.
   Используя закон  двойственности,  мы  можем выразить через левую
свертку многие функции,  повышая их эффективность. Но не все опера-
ции ассоциативны.
   Рассмотрим случай, когда f коммутативна f(x,y)=f(y,x)
 ш1.0

   foldr(f,e,[x 41 0,x 42 0,...x 4n 0]) = f(x 41 0,f(x 42 0...f(x 4n 0,e)...)) =

        = f(f(x 42 0...f(x 4n 0,e)...),x 41 0) = 7777 0=

        = f(f(...f(e,x 4n 0)...),x 42 0),x 41 0) = foldl(f,e,[x 4n 0,...x 42 0,x 41 0]),

т.е.

   foldl(f,e,xs) = foldl(f,e,reverse(xs))

 ш1.2
   Однако, коммутативные операции встречаются ещё реже.  Тем не ме-
нее, для любой бинарной операции f можно определить симметричную ей
операцию f', такую, что
 ш1.0

   f'(x,y)=f(y,x).

 ш1.2
   Повторяя с небольшими вариациями предыдущие рассуждения, получа-
ем.
    2Теорема 0 ( 1второй закон двойственности для свёртки 0).
 ш1.1
   Для всех f, e и xs
 ш1.0

   foldl(f,e,xs) = foldl(f',e,reverse(xs)).

 ш1.2
    2Доказательство 0. 1 Упражняйтесь 0.

   Этот закон дает нам способ улучшить функцию reverse.
 ш1.0

   reverse(xs) = id (reverse(xs))= foldr cons [] (reverse xs) =
               = foldl cons' [] xs

 ш1.2
   Легко видеть,  что это есть то самое  определение  fast_reverse,
которое вызвало так много трудностей.
    _ 1Упражнение . 0.
   Почему функция reverse часто встречается в программах?

                      3Сбалансированная свертка
   ...

   Зачем это может понадобиться?
   Вспомним  _ 1сортировку  слиянием . 0.  Её  можно определить как свертку
бинарной операции merge:
 ш1.0

   sort xs = foldb merge (map unit xs)
   unit x  = [x]

 ш1.2
   Здесь важно, чтобы свертка была сбалансированной.
   Действительно, если мы используем правую свертку,  то  учитывая,
что
 ш1.0

   merge [x] ys = insert x ys,

 ш1.2
получим  _ 1сортировку вставками . 0.

> sort xs = foldb merge (map unit xs)
> unit x  = [x]
> --------------------------
> merge [x] ys = insert x ys
> --------------------------------------------------------
> -- Функция insert, добавляющая элемент x в упорядоченный
> -- список lst с сохранением упорядоченности
> -------------------------------------------
> insert:: Int -> [Int] -> [Int]
> insert x lst | null lst    = [x]
>              | x<=head lst = x : lst
>              | True        = head lst : insert x (tail lst)
> -----------------------------------------------------------
> foldb f [x] = x
> foldb f xs  = f (foldb f (take (length xs `div` 2) xs))
>                 (foldb f (drop (length xs `div` 2) xs))
> -------------------------------------------------------
> test1 = sort [1..5]

   С другой стороны, поскольку операция merge ассоциативна, все те-
оремы  будут  выполнятся  для любой свертки и можем использовать их
для доказательства правильности программы сортировки.
   Посмотрим как могло бы выглядеть такое доказательство.
   Прежде всего, необходима формальная спецификация сортировки.
   Неформально: функция  sort  должна возвращать упорядоченный спи-
сок, содержащий те же элементы, что и её аргумент.
   Первую часть этого утверждения можно записать как
 ш1.0

   (I) ordered (sort xs),

где функция ordered xs возвращает true, если список xs упорядочен.

   ordered ([])         = true
   ordered ([x])        = true
   ordered ([x1,x2|xs]) = (x1<=x2) and ordered([x2|xs])

 ш1.2
   Вторая часть несколько сложнее.  Мы можем  переформулировать  её
следующим  образом:  количество вхождений любого объекта в исходный
список должно совпадать с количеством вхождений этого же объекта  в
список-результат.
 ш1.0

   (II) count (a,sort(xs)) = count (a,xs)

 ш1.2
   Функция count (a,xs) возвращает число вхождений объекта a в спи-
сок xs.
 ш1.0

   count (a,[])     = 0
   count (a,[a|xs]) = 1 + count (a,xs)
   count (a,[x|xs]) = count (a,xs) при x 7- 0a

 ш1.2
   Требуется доказать, что для функции sort выполняются утверждения
I и II. Для доказательства потребуются следующие утверждения.
 ш1.0

   1. ordered(x) and ordered(y) => ordered(merge(x,y))

   2. count(a,merge(x,y)) = count(a,x) + count(a,y)

   3. count(a,x++y) = count(a,x) + count(a,y)

   4. concat(map(unit,xs)) = xs

 ш1.2
   Последние два утверждения достаточно очевидны и легко  доказыва-
ются.  Утверждения  1 и 2 в сущности являются спецификацией функции
merge.  Их доказательство не сложно,  но достаточно громоздко и  мы
примем их за аксиомы. Можно переходить к доказательству.
   (I) Первая часть доказывается достаточно прямолинейно.
 ш1.0

   ordered (sort(xs)) = ordered (fold (merge,map (unit,xs))) <=

                     <= all (map (ordered, map(unit,xs))) =

                     = all (map (ordered_unit(xs))) = true.

 ш1.2
   Здесь ordered_unit - композиция функций ordered и unit,  для ко-
торой
 ш1.0

   ordered_unit(x) = ordered(unit(x)) = ordered([x]) = true

   (II) Введем обозначение

   counta(x) = count(a,xs).

   Заметим, что

   counta(sort(xs)) = counta(fold(merge,map(unit,xs))) =

                    = fold(+,map(counta,(map(unit,xs))).

   С другой стороны

   counta(xs) = counta(concat(map(unit,xs)) =

              = counta(foldr(++,map(unit,xs))) =

              = fold(+,map(counta,(map(unit,xs))).

   Отсюда

   counta(sort(xs)) = counta(xs).

Q.E.D.
   Количество вычислений,  необходимых даже для простых доказатель-
ств выглядит удручающе.  Но сами эти вычисления довольно  просты  и
сродни тем, которые производят системы компьютерной алгебры.
   Заманчиво, конечно, заставить выполнять их компьютер.
   Исследования в  этой  области начались относительно недавно,  но
вполне возможно,  что когда-нибудь мы  сможем  записать  формальную
спецификацию функции и получить по ней работающую программу.
