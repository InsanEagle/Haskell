    2ЛАБОРАТОРНАЯ РАБОТА 11.
    2ПОИСК ЭЛЕМЕНТОВ В СПИСКЕ. СОРТИРОВКА СПИСКА

 ш1.0
                                  1Вам поклоняюсь, вас желаю, числа 0!
                                  1Свободные, бесплотные, как тени,
                                  1Вы радугой связующей повисли
                                  1К раздумьям с вершины вдохновенья.
                                                            1В.Брюсов
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Знать понятия . 0:
 ш1.1
   - " 1прагматика 0", " 1прагматика языка программирования 0";
    1- "линейный поиск в массиве 0 ( 1списке 0) 1" 0;
    1- "бинарный поиск в упорядоченном массиве 0 ( 1списке 0) 1" 0;
    1- "интерполяционный поиск в массиве  0( 1списке 0) 1" 0;
   - " 1внутренние методы сортировки 0", " 1внешние методы сортировки 0";
    1- "сортировка  обменом",  "сортировка включениями",  "сортировка
 1выбором", "быстрая сортировка" 0;
   -  1технологию  использования  встроенной  функции  для сортировки
 1списков 0.

 ш1.2
    _ 1Уметь . 0:
 ш1.1
   - применять  классические  алгоритмы поиска для решения задач,  в
которых требуется использовать поиск.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                      3Понятие "прагматика языка
                          3программирования"
   Напомним, что  применительно  к  1знаковым системам 0 (в частности к
языкам программирования)  говорят об  их   1синтаксисе 0,   1семантике 0  и
 1прагматике 0.
    2Определение 0.
 ш1.1
    2(1)  _ 1Прагматика . 0 - это отношение символов и групп  символов  к  их
интерпретации и использованию.
    2(2)  _ 1Прагматика . 0 - это раздел  _ 1семиотики . 0, изучающий отношение чело-
века, использующего знаковую систему (например, язык программирова-
ния), к самой знаковой системе.
   Прагматика определяет,  каким  образом воспринимающая система на
основании информации, не заложенной в воспринимаемом выражении, вы-
бирает  из  множества интерпретаций наиболее подходящую для данного
случая.
    2(3) 0  _ 1Прагматика . 0  ( 1в  программировании 0)  -  это оценка и сравнение
различных языков программирования,  программ и компьютерных  систем
по критериям полезности, выгодности, эффективности.
   В частности,   _ 1прагматика языка программирования . 0 - это,  по  сути
дела,  методология программирования,  т.е. описание методов и приё-
мов,  позволяющих,  исходя из постановки задачи составить программу
её решения.

 ш1.2
   Важно отметить,  что некоторые семантически правильные программы
могут оказаться прагматически совершенно неприемлемыми.
   Некоторые задачи,  хотя и формулируются крайне просто,  не имеют
алгоритма для их решения (например, такова задача:  1проверить, явля-
 1ется ли любая данная программа семантически правильной 0).
   Задачи этого рода называются  _ 1алгоритмически неразрешимыми . 0.
   Из-за существования  алгоритмически  неразрешимых  задач предмет
прагматики становится  расплывчатым и неопределённым - невозможно в
общем случае дать рекомендации, которые от постановки задачи гаран-
тированно приводили бы к её решению. Кроме того, из-за разнообразия
задач,  решаемых с помощью компьютера, те рекомендации, которые мо-
гут  быть  даны,  либо носят чересчур общий характер,  либо слишком
конкретны, т.е. относятся к узкому классу задач.
   Теория программирования, хотя и может гордиться рядом значитель-
ных достижений,  ориентирована больше на разработчиков программного
обеспечения, чем на пользователей. Многие её рекомендации представ-
ляют  собой  лишь  постановки задач,  решение которых потребует ещё
многих усилий системных программистов, если вообще когда-либо будет
достигнуто.  Поэтому  большую роль в овладении навыками составления
программ играет  _ 1всесторонний анализ примеров решения задач  различ-
 _ 1ных классов и разной степени сложности . 0.
   Учитывая сказанное,  обычно  мы  рассматриваеи  применение языка
Haskell к решению разнообразных проблем из области программирования
(другими словами,  обычно строятся  _ 1конкретные прагматические расши-
 _ 1рения языка . 0  1Haskell 0).

                       2Поиск элемента в списке

 ш1.0
                          1То, что ищешь, найдешь только обыскав все.
                                                          1Закон Буба
 ш1.2

                 21. 0  3Последовательный поиск элементов
                              3в списке
   Алгоритм поиска всегда отображает процесс просмотра списка в по-
исках некоторого конкретного элемента, называемого 1  _целевым . 0.
   При  _ 1последовательном поиске . 0 последовательно  просматривается  по
одному элементу списка, начиная с первого, до тех пор, пока не най-
дётся целевой элемент.  Очевидно, что чем дальше в списке находится
конкретное  значение ключа,  тем больше времени уйдёт на его поиск.
   При этом нет особой необходимости изначально сортировать список.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1.

 ш1.2
   Время, затрачиваемое  на последовательный поиск,  в среднем про-
порционально длине просматриваемого списка, что обозначается  7O 0(n).
   Если поиск выполняется  много  раз,  то  возможно,  имеет  смысл
по-другому организовать данные.
   Например, можно воспользоваться  1бинарным  деревом  поиска 0.  Ско-
рость  поиска  в  таком дереве,  вообще говоря,  зависит от порядка
включения в него узлов,  однако во многих случаях она будет пропор-
циональна двоичному логарифму от полного числа узлов.
                     22. 0  3Бинарный поиск элементов
                              3в списке
   Алгоритм бинарного поиска элемента в списке сводится к тому, что
определяется   окрестность  целевого  элемента,  которая  позволяет
уменьшить область поиска в два раза.
   При 1 бинарном поиске 0 сравнивается целевое значение  со  "средним"
элементом отсортированного списка. В случае совпадения значений по-
иск завершается, в остальных случаях отбрасывается половина списка,
где этого элемента явно нет.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 2.

 ш1.2
              23. 0  3Интерполяционный поиск 0  3в 0  3упорядоченном
                          3массиве 2 ( 3списке 2)
    _ 1Интерполяционный поиск . 0  основан  на принципе поиска в телефонной
книге или в словаре.  Вместо сравнения каждого элемента  с  искомым
как при линейном поиске,  данный алгоритм производит попытку  1предс-
 1казания 0 местонахождения элемента,  т.е.  поиск  происходит  подобно
двоичному  поиску,  но  вместо деления области поиска на две части,
интерполяционный поиск производит оценку новой  области  поиска  по
расстоянию между искомым значением и текущим значением элемента.
   Другими словами,  бинарный  поиск  учитывает  лишь знак разности
между искомым элементом и текущим значением,  а интерполирующий ещё
учитывает и модуль этой разности и по данному  значению  производит
предсказание позиции следующего элемента для проверки.
   Итак, если теперь предположить, что данные:
 ш1.1
   (1) упорядочены по возрастанию (убыванию);
   (3) распределены в массиве достаточно "равномерно",

 ш1.2
то можно значительно ускорить "сходимость"  процесса  поиска,  осу-
ществляя сужение интервала поиска из следующих неформальных сообра-
жений.
   Пусть элементы массива (списка) принимают значения от 1 до  1000
и необходимо найти элемент 10, то при первом шаге сужения всего ди-
апазона поиска гораздо эффективнее делить его не пополам  (учитывая
предположение о  "равномерности"  распределения  данных  в  массиве
(списке), новые интервалы будут содержать  значения  приблизительно
от  1  до 500 и от 501 до 1000),  а взять левый интервал меньшим по
размеру,  т.к.  предположительно, число 10 окажется гораздо ближе к
левой границе исходного диапазона.
   Приведём выражение для вычисления индекса, соответствующего раз-
биению интервала.  Пусть A - отсортированный массив (список) чисел,
содержащий n элементов, x - искомое значение.
   В дальнейшем будем обозначать a[i] i-й элемент массива (списка),
i=0,1,...n.
   Если известно,  что значение x расположено между a[l] и a[r], то
следующая проверка выполняется для элемента массива с индексом
 ш1.0

            x-a[l]
   l+(r-l) 77 0─────────.
           a[r]-a[l]

 ш1.2
   Приведём запись алгоритма на псевдокоде, похожим на язык C:
 ш1.0

   interpolationSearch(n,x):
     l=0;      // Левая граница поиска (элементы массива
               // нумеруются, начиная с 0)
     r=n-1;    // Правая граница поиска
     while a[l]<=x && x<=a[r]
     {
       m=l+(x-a[l])/(a[r]-a[l])*(r-l);
              // Элемент, с которым будем проводить сравнение
       if a[m]==x
         result=m;
       if a[m]<x
         l=m+1;
       else r=m-1;
       if a[l]==x
         result=l;
       else result=-1; // Элемент не найден
     }

 ш1.2
   Следующий пример на языке С показывает простейшую реализацию ин-
терполяционного поиска.  На каждой стадии алгоритм рассчитывает по-
зицию для  следующей проверки (как при двоичном поиске) и переносит
верхнюю или нижнюю границу, определяя тем самым новую область поис-
ка, содержащую искомое значение.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 2C.

 ш1.2
   Асимптотически интерполяционный  поиск  превосходит по своим ха-
рактеристикам бинарный поиск.
   Если ключи распределены случайным образом,  то за один шаг алго-
ритм  уменьшает количество проверяемых элементов с n до n 51/2 0,  т.е.
после k-ого шага количество проверяемых элементов уменьшается до
 ш1.0

     41/2 5k
   n 4     0.

 ш1.2
   Следовательно, остаётся проверить только два элемента (и  закон-
чить на этом поиск), когда
 ш1.0
 
   1/2 5k 0= 1log 4n 02=1/ 1log 42 0n.

 ш1.2
   В среднем  интерполяционный поиск производит
 ш1.0

    1log 0( 1log 0(n))

 ш1.2
операций, где n - число элементов, для которых производится поиск.
   Число необходимых операций зависит от равномерности  распределе-
ния значений  среди элементов.  В "плохом" случае (например,  когда
значения элементов экспоненциально возрастают) интерполяционный по-
иск может потребовать  7O 0(n) операций.
   Эксперименты показали,  что интерполяционный поиск не  настолько
снижает количество выполняемых сравнений, чтобы компенсировать тре-
буемое для дополнительных вычислений время (пока размеры массива не
очень велики).  Кроме того, типичные массивы недостаточно случайны,
да  и разница между значениями  1log 0( 1log 0(n)) и  1log 0(n) становится зна-
чительной только при очень больших n.
   На практике  при  поиске в больших массивах оказывается выгодным
на ранних стадиях применять  1интерполяционный поиск 0,  а затем, когда
диапазон существенно уменьшится, переходить к  1двоичному поиску 0.
                   24. 0  3Сравнение алгоритмов поиска
   В таблице  показаны приближённые  _ 1оценки сложности алгоритмов по-
 _ 1иска в массиве . 0 (в наихудшем и наилучшем вариантах).
 ш1.0

                    ┌─────────────────┬───────────────┐
                    │ 3Наихудший вариант 0│ 3Средний вариант 0│
   ┌──────────── 1── 0──┼─────────────────┼───────────────┤
   │ 1Линейный поиск   0│       7O 0(n) 1  0      │      7O 0(n) 1  0     │
   ├──────────── 1── 0──┼─────────────────┼───────────────┤
   │ 1Бинарный поиск   0│     7O 0( 1log 42 0n)     │    7O 0( 1log 42 0n)    │
   ├──────────── 1── 0──┼─────────────────┼───────────────┤
   │ 1Интерполяционный 0│     1   7O 0(n)  1   0    │  7O 0( 1log 42 1log 42 0n)  │
    1│поиск           │                 │               │
   └──────── 1── 0──────┴─────────────────┴───────────────┘

 ш1.2
   При анализе  1наихудшего варианта 0 оценивают максимальный объём ра-
боты,  необходимой для решения задачи заданного размера, а при ана-
лизе  1среднего варианта 0 - вероятный объём работы.
   Таким образом, бинарный поиск намного лучше линейного.
   Например,  1log 42 01000000=19,  поэтому алгоритм линейного поиска вы-
полнит миллион сравнений,  в то время как алгоритм бинарного поиска
- не более 20.  Если размерность массива (списка) велика, то бинар-
ный поиск намного эффективнее линейного. Однако следует иметь в ви-
ду, что условие упорядоченности массива (списка) приводит к  допол-
нительным затратам, которые могут стать существенными.

                   2Внутренняя сортировка элементов
                              2в списках
    2Определение 0.
 ш1.1
    _ 1Сортировка . 0 -  это  алгоритмический процесс перестановки объектов
данной последовательности в определённом заданном порядке.
    _ 1Целью сортировки . 0 является облегчение последующего поиска элемен-
тов в отсортированной последовательности (в  этом  смысле  элементы
сортировки присутствуют во многих задачах).

 ш1.2
   Проблема сортировки неупорядоченной последовательности относится
к  классическим  проблемам  теоретической информатики.  Она кажется
простой (ведь всем приходилось  выполнять  какую-либо  механическую
сортировку, была ли то раскладка игральных карт, гардеробных номер-
ков, карточек из библиотечного каталога или денежных счетов), одна-
ко  эта  простота иллюзорна.  Хотя первые программы сортировки были
написаны американским математиком Дж. фон Нейманом ещё  в 1945  г.,
какого-либо значительного продвижения в теории сортировки не наблю-
далось в течение последующих двадцати лет.
   Методы сортировки подразделяются на  1внутренние 0 и  1внешние 0.
    2Определение  0(по [Лорин,1983,с.10]).
 ш1.1
    2(1)  _ 1Внутренние методы сортировки . 2  0-  это  методы,  которые  могут
применяться  с  приемлемой производительностью только к тем спискам
данных, которые целиком помещаются в оперативной памяти процессора.
    2(2)  _ 1Внешние методы сортировки . 0 - это методы,  приемлемые для фай-
лов данных, которые слишком велики, чтобы поместиться в оперативной
памяти, и поэтому должны в течение процесса сортировки располагать-
ся на  1устройствах внешней памяти 0 (лентах, дисках, CD-дисках).

 ш1.2
   В процессе внешней сортировки часть файла считывается  в  опера-
тивную память, там упорядочивается, а затем переписывается на внеш-
ние устройства. Этот процесс повторяется требуемое число раз.
   Внутренние методы используются для перестановки данных,  обраба-
тываемых между пересылками.  Поэтому, когда говорят о сортировке на
дисках,  то  подразумевают не только процесс считывания и записи на
эти диски,  но также и внутреннюю сортировку, которая упорядочивает
и комбинирует элементы с этих дисков по мере их считывания.
   Рассмотрим несколько  _ 1алгоритмов внутренней сортировки . 0.

                        21. 0  3Сортировка обменом

 ш1.0
           1Лучше, если тебе скажут 0: 1 взойди 0  1выше, нежели 0: 1 сойди вниз.
                                                              1Талмуд
 ш1.2

    _ 1Сортировка обменом . 0 - это термин,  используемый для описания  се-
мейства методов сортировки, предусматривающих систематический обмен
местами между элементами пар, в которых нарушается упорядоченность,
до тех пор, пока таких пар не останется.
    2Определение 0.
 ш1.1
    _ 1Сортировка обменом . 0  - это метод сортировки,  при котором все со-
седние элементы списка попарно сравниваются друг с другом и меняют-
ся местами в том случае,  если предшествующий элемент больше после-
дующего.  В результате этого максимальный элемент постепенно смеща-
ется вправо по списку и в конце концов занимает крайнее правое мес-
то в списке, после чего он исключается из дальнейшей обработки.
   Затем процесс повторяется, и своё место занимает второй по вели-
чине элемент,  который также исключается из дальнейшего  рассмотре-
ния. Так продолжается пока весь список не будет упорядочен.

 ш1.2
   Опишем более формально этот алгоритм применительно к  упорядочи-
ванию по возрастанию списка попарно различных чисел x 41 0,x 42 0,...,x 4n 0.
   Последовательным просмотром элементов x 41 0,...,x 4n 0 найдём i  такое,
что x 4i 0>x 4i+1 0;  поменяем x 4i 0 и x 4i+1 0 местами, 4  0продолжим просмотр с эле-
мента x 4i+1 0 и т.д. Тем самым в результате первого просмотра наиболь-
шее число передвинется на последнее место в списке.
   Следующие просмотры начинают вновь сначала,  уменьшая на единицу
количество просматриваемых элементов. Список будет упорядочен после
просмотра, в котором участвовали только первый и второй элементы.
   Сортировку обменом называют ещё " 1пузырьковой 0  1сортировкой 0" (в си-
лу очевидного сравнения с всплытием пузырьков воздуха в жидкости).
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 4.

 ш1.2
    3Замечание 0 [Лорин,1983,с.24].
 ш1.1
   Простыми формами сортировки обменом являются:  _ 1стандартный обмен . 0,
 _ 1парный обмен .  0и  _ 1просеивание . 0.
 ш1.2

                       22. 0  3Сортировка вставками

 ш1.0
                                 1Порядок ведёт ко всем добродетелям 0!
                                 1Но что ведёт к порядку 0?
                                                      1Г.К.Лихтенберг
 ш1.2

    2Определение 0 [Лорин,1983,с.33].
 ш1.1
    _ 1Сортировка вставками . 2  0- это название группы  методов  сортировки,
основанных на последовательной вставке новых элементов в увеличива-
ющийся упорядоченный список.
   Среди методов сортировки вставками имеются три метода  ( _ 1линейная
 _ 1вставка ., 0  _ 1центрированная вставка . и  _двоичная вставка . 0), которые разли-
чаются способом поиска подходящего места для вставки элемента.

 ш1.2
   Простейшим методом является  1линейная вставка 0.  В этом методе уже
существующий список рассматривается как линейный список, просматри-
ваемый поэлементно,  пока не будет найдена соответствующая  позиция
для нового элемента.
   Линейная вставка обычно используется тогда, когда процесс, внеш-
ний к данной сортировке,  динамически вносит добавления  в  список,
все  элементы  которого  известны и который должен поддерживаться в
упорядоченном состоянии.  Сортировка выполняется каждый раз при по-
лучении нового элемента, размещая этот элемент в нужное место спис-
ка.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 5.

 ш1.2
    3Замечание 0.
 ш1.1
   Сортировка включениями наиболее эффективна для случая почти упо-
рядоченного массива.

 ш1.2
                        23. 0  3Сортировка выбором
    2Определение.
 ш1.1
    _ 1Сортировка выбором . 0 - это метод сортировки,  при котором в неупо-
рядоченной последовательности выбирается минимальный элемент, кото-
рый исключается из дальнейшей обработки,  а  оставшаяся  последова-
тельность элементов принимается за исходную. Процесс повторяется до
тех пор, пока все элементы не будут выбраны. Очевидно, что все выб-
ранные элементы образуют упорядоченную последовательность.

 ш1.2
   Минимальный элемент,  выбранный в  исходной  последовательности,
может быть размещён на предназначенном ему месте упорядоченной пос-
ледовательности несколькими способами. Рассмотрим два из них:
 ш1.1
   (1) минимальный элемент после i-го просмотра перемещается на i-е
место  (i=1,2,3,...) заданного списка,  а элемент с i-го места - на
место выбранного.  После каждого просмотра  упорядоченные  элементы
(от первого до элемента с индексом i) исключаются из дальнейшей об-
работки, т.е. размер каждого последующего обрабатываемого списка на
единицу меньше размера предыдущего;
   (2) минимальный элемент после i-го просмотра перемещается на i-е
место, i=1,2,3,...,  другого специально созданного списка,  а в ис-
ходном  списке,  на месте выбранного элемента размещается некоторое
число, превосходящее по величине любой элемент сортируемого списка.
Изменённый подобным образом список принимается за исходный,  и осу-
ществляется следующий просмотр.

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 6.

                        24. 0  3Быстрая сортировка

 ш1.0
            1Всё становится интуитивно ясным после того, как поймёшь.
                                                    1Автор неизвестен
 ш1.2

   Алгоритм сортировки, разработанный английским информатиком Ч.Хоа-
ром действует следующим образом. На первом этапе выбирается элемент,
называемый  _ 1опорным элементом . 0.  Далее необходимо расположить элементы
таким образом,  чтобы элементы меньше опорного находились  слева,  а
больше или равные элементы находились справа.
   Далее необходимо рекурсивно повторить поиск для  левых  и  правых
подмассивов (подсписков).
   Обсудим сложность этого алгоритма.
   В общем случае на каждом шаге алгоритм делит массив (список)  по-
полам. Поэтому на каждом уровне рекурсии происходит оперирование с n
элементами массива (списка),  а количество   1уровней  рекурсии 0  равно
 1log 0(n),  следовательно сложность быстрой сортировки  _ 1в среднем случае
составляет
 ш1.0

    7O 0(n 77 1log 0(n)).

 ш1.2
   Однако может возникнуть случай,  при котором массив (список) де-
лится не на две примерно равны части,  или даже случай, при котором
подмассив (подсписок) становится "пустым".
   В таком случае количество  1уровней рекурсии 0 может вырасти до n, и
в результате сложность быстрой сортировки  _ 1в худшем случае . 0 составля-
ет
 ш1.0

    7O 0(n 52 0).

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 7, Пример 8.

 ш1.2
                       25. 0  3Сортировка слиянием
   В основе  _ 1сортировки слиянием . 0 лежит замечание,  согласно которому
слияние двух отсортированных списков выполняется быстро.
   Список из одного элемента уже отсортирован,  поэтому  сортировка
слиянием разбивает список на одноэлементные "куски", а затем после-
довательно выполняет их слияние.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 9, Пример 10.

 ш1.2
    3Замечание 0 [Романовский,2004,с.111].
 ш1.1
   Процедура слияния  настолько проста,  что иногда её проще не де-
лать заранее, а выполнять "на лету",  в ходе работы алгоритма,  ис-
пользующего результат  слияния.  Такой список,  создаваемый по мере
надобности, в программном отношении выглядит как обычный список.
   Программные объекты такого рода называются  _ 1виртуальными . 0.

 ш1.2
                26. 0  3Встроенная функция для сортировки
                               3списков
   Функция, производящая сортировку элементов целочисленного списка
в возрастающем порядке имеет следующий синтаксис:
 ш1.0

    2sort lst

   Например,

   > sort [1]   > sort [-2,-4,3,-5,12]
   [1]          [-5,-4,-2,3,12]

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   Для работы с функцией требуется подключить модуль List:

   > :load List

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 6.

                 27. 0  3Сравнение алгоритмов сортировки

 ш1.0
                       1...задача, стоящая перед программистом, - это
                       1интеллектуальный вызов высочайшего ранга. 0
                                                          1Э.Дейкстра
 ш1.2

   В таблице (см. [Каррано,Причард,2003,с.447]) показаны приближён-
ные  _ 1оценки сложности алгоритмов сортировки . 0 (в наихудшем и наилучшем
вариантах).
 ш1.0

   ┌────────────────────────────╥─────────────────┬───────────────┐
   │  2     0  2Методы сортировки 0     ║ 3Наихудший вариант 0│ 3Средний вариант 0│
   ╞════════════════════════════╬═════════════════╪═══════════════╡
   │ 1Сортировка обменами 0         1  0║       7O 0(n 52 0)      │      7O 0(n 52 0)     │
   ├────────────────────────────╫─────────────────┼───────────────┤
   │ 1Сортировка методом выбора    0║       7O 0(n 52 0)      │      7O 0(n 52 0)     │
   ├────────────────────────────╫─────────────────┼───────────────┤
   │ 1Сортировка методом включений 0║       7O 0(n 52 0)      │      7O 0(n 52 0)     │
   ├────────────────────────────╫─────────────────┼───────────────┤
   │ 1Быстрая сортировка           0║       7O 0(n 52 0)      │   7O 0(n 77 1log 0(n))  │
   ├────────────────────────── 1─ 0─╫─────────────────┼───────────────┤
   │ 1Сортировка слиянием 0        1  0 ║    7O 0(n 77 1log 0(n))   │   7O 0(n 77 1log 0(n))  │
   ├────────────────────────────╫─────────────────┼───────────────┤
   │ 3Древовидная сортировка 0     1  0 ║       7O 0(n 52 0)      │   7O 0(n 77 1log 0(n))  │
   ╞════════════════════════════╬═════════════════╪═══════════════╡
   │Пирамидальная сортировка   1  0 ║    7O 0(n 77 1log 0(n))   │   7O 0(n 77 1log 0(n))  │
   ├────────────────────────────╫─────────────────┼───────────────┤
   │Поразрядная сортировка     1  0 ║       7O 0(n)       │      7O 0(n)      │
   └────────────────────────── 1─ 0─╨─────────────────┴───────────────┘

 ш1.2
   При анализе  1наихудшего варианта 0 оценивают максимальный объём ра-
боты,  необходимой для решения задачи заданного размера, а при ана-
лизе  1среднего варианта 0 - вероятный объём работы.
    3Замечания 0 ( 1важные 0) [Каррано,Причард,2003,с.448].
 ш1.1
    21. 0 Если размер задачи невелик,  не стоит слишком подробно анали-
зировать сложность алгоритма. В этом случае основным фактором явля-
ется его  1простота 0.  Например, для сортировки небольшого массива (не
более  25  элементов)  вполне  подходит простой алгоритм сортировки
включениями, хотя его сложность 1  7O 0(n 52 0).
    22. 0 При  сортировке  очень  большого  массива (списка) алгоритмы,
сложность которых оценивается величиной  7O 0(n 52 0), не эффективны.
    23. 0 Алгоритм  быстрой  сортировки  следует выбирать,  только если
элементы массива (списка) записаны в произвольном порядке.
   Хотя в худшем случае сложность алгоритма быстрой сортировки оце-
нивается величиной  7O 0(n 52 0),  на практике такая  ситуация  встречается
крайне редко.
 ш1.2

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 1.
 ш1.1

 ш1.2

    2Пример 2.
 ш1.1

 ш1.2

    2Пример 3.
 ш1.1

 ш1.2

    2Пример 4.
 ш1.1

 ш1.2

    2Пример 4 41 2.
 ш1.1

 ш1.2

    2Пример 5.
 ш1.1

 ш1.2

    2Пример 6.
 ш1.1

 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                              1Многое разное значит у русского народа
                              1почёсывание в затылке.
                                       1Н.В.Гоголь. Мёртвые души, т.1
 ш1.2

    20. 0 (По [Анисимов,Пупышев,2006,с.287,№16.188])
   Найдите ошибки,  описки, неточности и прочие изъяны в данной ла-
бораторной работе.
                21. 3 Применение методов поиска в списке
    21 5* 2. 0 (По [Окулов,2002,с.270])
   Напишите программу,  осуществляющую поиск k-го элемента в неупо-
рядоченном массиве следующим образом, называемым  _ 1случайным поиском . 0.
   Выбирается случайным образом элемент с номером q.  Массив A раз-
бивается на три части:  элементы, меньшие A[q], равные A[q] и боль-
шие A[q].  Далее,  в  зависимости  от количества элементов в каждой
части рекурсивно выбирается одна из частей для дальнейшего поиска.
    22. 0 (По [Окулов,2002,с.277])
   Напишите программу,  осуществляющую поиск элемента массива, бли-
жайшего к его наименьшему элементу.
    23. 0 (По [Окулов,2002,с.269])
   Дана позиция элемента Pos в упорядоченном массиве A из N элемен-
тов и количество допустимых сравнений L.
   Определите все интервалы значений в диапазоне [1,10000], при ко-
торых элемент  A  с  номером Pos может быть найден за L сравнений с
помощью алгоритма бинарного поиска в упорядоченном массиве.
    _ 1Тесты . 0. Если Pos=10,  L=3, то интервалы таковы: (12,12), (16,17),
(28,29), (80,87). Если Pos=9000, L=2, то решений нет.
 ш1.1
    _ 1Указание . 0.
 ш1.0

   import List
   -- ***********************
   res a lst = search a lst 0
   ----------------------------------------
   search:: Ord a => a -> [a] -> Int -> Int
   search a lst res | null lst        = res
                    | length lst == 1 = res + 1
                    | a == mid        = res + 1
                    | a <  mid        = search a lst1 (res + 1)
                    | a >  mid        = search a lst2 (res + 1)
        where mid  = last lst1
              z    = length lst `div` 2
              lst1 = take z lst
              lst2 = drop z lst
   ----------------------------------------------------
   test k = filter (\x -> res 10 [1..x] == k) [1..1000]

 ш1.2
    24. 0 Напишите программу, осуществляющую " _ 1одновременный . 0" поиск наи-
меньшего и наибольшего элемента массива.
                      22. 0  3Медиана и мода массива
                              2( 3списка 2)
    21.  0Напишите программу для нахождения медианы в массиве,  опираю-
щуюся на следующий алгоритм:  вначале произведите сортировку масси-
ва, а затем выберите "средний" элемент.
 ш1.1
    _Указание ..  _ 1Медианой массива,  содержащего . 4  1N  _элементов . 0, называется
элемент,  значение которого меньше (или равно) половины N элементов
и больше (или равно) другой половины.
   Например, медианой массива, содержащего элементы 16 1, 0 22 1, 0 99 1, 0 95,
18, 87, 10 является 18.

 ш1.2
    22. 0 Напишите программу, которая либо вычисляет моду массива, либо
устанавливает, что массив её не имеет.
 ш1.1
    _Указание ..  _ 1Модой массива . 0 называется число M,  которое встречается
в массиве наиболее часто. Если в массиве имеется несколько наиболее
часто встречающихся элементов и число их  вхождений  совпадает,  то
считается, что массив не имеет моды.

 ш1.2
    23. 0 Напишите программу,  определяющую, есть ли в заданном массиве
мажорирующий элемент, и если есть, то укажите его.
 ш1.1
    _Указание ..  _ 1Мажорирующим  элементом  массива . 0  A[1..N] назовём эле-
мент, встречающийся в массиве более N/2 раз.

 ш1.2
                  23. 3 Применение сортировки списков
    21 4* 2. 0 Используя любой алгоритм сортировки,  в одноуровневом число-
вом списке найдите максимальный элемент.
    22 4* 2. 0 Используя любой алгоритм сортировки,  в одноуровневом число-
вом списке найдите элемент, ближайший к минимальному.
    23 4* 2. 0 Дан одномерный числовой список. Напишите предикат, проверяю-
щий, является ли он упорядоченным по убыванию 2  0(возрастанию).
    24 4* 2. 0 Напишите  функцию  для  нахождения  1медианы числового списка 0,
опирающуюся на следующий алгоритм:  вначале произведите  сортировку
списка, а затем выберите "средний" элемент.
 ш1.1
    _Указание ..  _ 1Медианой списка,  содержащего . 4  1n  _элементов . 0,  называется
элемент,  значение которого меньше (или равно) половины n элементов
и больше (или равно) другой половины.
   Например, 22 является медианой списка [16,22,99,95,18,87,10].

 ш1.2
    25 5* 2. 0 Найдите  количество  различных чисел среди элементов данного
списка. Число действий должно быть порядка n 77 1log 42 0n.
 ш1.1
    _Указание .. Отсортируйте  список,  а  затем  посчитайте количество
различных элементов, просматривая элементы списка по порядку.

 ш1.2
                 24. 3 Реализация алгоритмов сортировки
    21. 0 Напишите  функцию,  реализующую следующий  _ 1алгоритм сортировки
 _ 1обменами . 0: последовательными просмотрами чисел a 41 0,...,a 4n 0 найдите на-
именьшее i такое, что a 4i 0>a 4i+1 0. Поменяйте a 4i 0 и a 4i+1 0 местами и возоб-
новите просмотр с начала списка.  Когда не удается найти i,  список
будет упорядочен.
    22. 0 Реализуйте сортировку выбором.
    23 5* 2. 0 (По [Шень,1995])
   Практически важный алгоритм сортировки таков:  чтобы  отсортиро-
вать список,  выберем случайный его элемент b, и разобьём список на
три части:  меньшие b, равные b и большие b. Теперь осталось отсор-
тировать первую и третью части: это делается тем же способом.
   Приведите рекурсивную реализацию этого алгоритма сортировки.
    3Замечание 0.
 ш1.1
   Время работы  этого алгоритма - случайная величина;  можно дока-
зать,  что в среднем он "работает" C 77 0n 77 1log 0(n)  единиц  времени  (на
практике - он один из самых быстрых).

 ш1.2
    24. 0 Реализуйте операцию " 1соединение двух списков 0" с помощью функ-
ции, объединяющей элементы двух списков на основе заданных тестов:
 ш1.0

   > merge (<) [2,4,6,8,10] [3,5,7,11]
   [2,3,4,5,6,7,8,10,11]
   > merge (<=) [2,4,6,8,10] [2,4,6,8]
   [2,2,4,4,6,6,8,8,10]
   > merge (=) [2,4,6] [3,5,7,11]
   [2,4,6,3,5,7,11]

 ш1.2
    25 5* 2. 0 Упорядочите целочисленный список по неубыванию следующим  _ 1ме-
 _ 1тодом фон Неймана . 0.  Сформируйте два списка A и B и поместите исход-
ный список в A; упорядочите пары соседних чисел (A 41 0 и A 42 0, A 43 0 и A 44 0 и
т.д.) и запишите их в список B;  возьмите из списка B по две сосед-
ние упорядоченные пары и, "слив" их в упорядоченные четвёрки, снова
запишите в список A; затем каждые две соседние четвёрки из B "слей-
те" в упорядоченные восьмёрки и перенесите в список A и т.д.
    26 5* 2. 0 Докажите,  что следующий  1функционал 0 реализует сортировку за-
данного списка:
 ш1.0

   sortG :: (t -> t -> Bool) -> [t] -> [t]
   sortG comp []    = []
   sortG comp (a:x) = sortG comp sml ++ [a] ++ sortG comp lrg
       where sml = [b | b <- x, comp b a]
             lrg = [b | b <- x, comp a b]
   --------------------------------------
   test1 = sortG (>=) [4,3,5,2,6,1,2]
   test2 = sortG (<)  [4,3,5,2,6,5,5]

 ш1.2
    27 5* 2. 0 Опишите функцию, 4  0упорядочивающую по неубыванию  _ 1числовой . 0 спи-
сок x следующим методом:  все числа из x упорядочить  по   1последней
цифре  и  перенести  во вспомогательный список y;  затем числа из y
упорядочить по  1предпоследней 0 цифре (при равенстве этих цифр  сохра-
нять упорядоченность по последней цифре) и записать их снова в спи-
сок x; далее числа из x упорядочить по  1третьей от конца 0 цифре и пе-
ренести в список y и т.д.
   Учесть, что в конце концов числа должны оказаться в списке.
    28. 0 (По [Макдауэлл,2012,с.77])
   Массив A[1..n] содержит целые числа от 0 до n, но одно число от-
сутствует. Элементы массива A хранятся в двоичном виде.
   Невозможно получить доступ к любому элементу в массиве A  с  по-
мощью  операции   1A 0[ 1i 0],  однако доступ к элементам можно осуществить
только при помощи команды " 1Извлечь j-й бит из A 0[ 1i 0]", имеющей фикси-
рованное время выполнения.
   Напишите код, обнаруживающий отсутствующее целое число.
   Можно ли выполнить эту задачу за время 7 O 0(n)?
