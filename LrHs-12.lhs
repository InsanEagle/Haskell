> import Random
> import IO
> import Monad

    2УПРАЖНЕНИЕ 12.
    2ГЕНЕРАЦИЯ ЗНАЧЕНИЙ  СЛУЧАЙНОЙ  ВЕЛИЧИНЫ ПО ЕЁ ЗАКОНУ РАСПРЕДЕЛЕ-
 2НИЯ. ГЕНЕРАЦИЯ ПСЕВДОСЛУЧАЙНЫХ ЧИСЕЛ И СПИСКОВ 0

 ш1.0
                 1В основе теории 0  1колмогоровской сложности лежит сле-
                 1дующая простая и естественная идея 0: 1  сложность объ-
                 1екта измеряется длиной его кратчайшего описания. 0
                                                       1В.А.Успенский
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Вспомогательные понятия . 0:
 ш1.0
    1- 0  1генерация псевдослучайных чисел в языке C 0 ( 1повторение 0);
    1- 0  1генерация псевдослучайных чисел в языке LISP 0.

 ш1.2
    _ 1Основные понятия . 0:
 ш1.0
    1- методы получения случайных чисел 0: 1  физические генераторы  слу-
 1чайных  чисел,  таблицы  случайных чисел, 0   1псевдослучайные числовые
 1последовательности 0;
    1- генераторы  равномерно  распределённых  псевдослучайных чисел 0:
 1метод середины квадратов, линейный конгруэнтный метод 0;
    1- генерация  дискретной  случайной  величины,  заданной  законом
 1распределения 0;
    1- генерация нормально распределённых 0  1случайных чисел 0;
    1- генерация случайных чисел, имеющих 0  1показательное распределение 0;
    1- генерация случайных чисел, 0  1распределённых по закону Коши 0;
    1- проверка качества генераторов 0  1псевдослучайных чисел 0: 1  алгоритм
 1Брента, критерий  7c 52 1 проверки генератора случайных чисел 0;
    1- 0  1генераторы псевдослучайных чисел 0  1в языках 0  1C и Lisp. 0
    1- 0  1технология генерации псевдослучайных чисел 0  1в языке Haskell.

 ш1.2
    _ 1Уметь . 0:
 ш1.0
   - генерировать  1псевдослучайные 0 числа;
   - генерировать  1псевдослучайные 0 списки;
   - использовать генерацию псевдослучайных чисел для компьютерного
решения простейших задач теории вероятностей, относящихся к законам
распределения случайных величин.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ

 ш1.0
                                    1В горячку времени стремглав 0!
                                    1В разгар случайностей с разбегу 0!
                                                              1И.Гёте
 ш1.2

    2Определение 0.
 ш1.1
    _ 1Случайные числа . 0 - это значения случайной величины, получаемые по
её закону распределения.

 ш1.2
   Случайные числа используются:
 ш1.1
   (1)  _ 1в прикладных задачах . 0:
    - в методе Монте-Карло для численного интегрирования;
    - в  статистическом  анализе для исследования генеральных сово-
купностей по большим выборкам;
    - для моделирования природных явлений (ядерный распад и т.п.);
   (2)  _ 1в программировании . 0:
    - для генерации простых чисел;
    - для выбора случайных элементов из заданного множества;
    - для генерации ключей и работы защищённых протоколов  в  крип-
тографии;
    - для тестирования программ.
 ш1.2

                  3Методы генерации случайных чисел

 ш1.0
                        1Для того, чтобы приготовить яблочный пирог с
                        1нуля, сначала придётся придумать Вселенную. 0
                                                             1К.Саган
 ш1.2

   Фраза " 1получение значений случайных величин с помощью  компьюте-
 1ра 0" может  вызвать недоумение:  ведь всё,  что выполняет компьютер,
должно быть заранее запрограммировано:  откуда же возникает случай-
ность?
   Различают  1три способа получения случайных чисел 0.
    21. 0  _ 1Физические генераторы . 0 ( _ 1истинно . 0)  _ 1случайных чисел . 0.
    1Физическим генератором 0  ( 1датчиком  случайного двоичного разряда 0)
называется специальное приспособление для компьютера, в котором ре-
зультаты некоторого  1случайного физического процесса 0 преобразуются в
последовательность значений дискретной случайной величины 2 x 0 с неко-
торым законом распределения
 ш1.0

   (x 41 0,p 41 0),(x 42 0,p 42 0),(x 43 0,p 43 0),..., x 4i 7е ═R 0, p 41 0+p 42 0+ 7777 0=1.

 ш1.2
   Истинно случайные числа можно получить с помощью следующих физи-
ческих генераторов:
   (а) подбрасывая  1правильную 0 монету или  1правильную  0игральную кость;
   (б) вращая колесо "правильной" рулетки;
   (в) отслеживая направление перемещения компьютерной мыши;
   (г) используя случайный  1процесс радиоактивного распада 0:  пусть в
компьютере имеется источник излучения радиоактивных частиц; счётчик
подсчитывает количество радиоактивных частиц за некоторое время  7D 0t;
если число частиц - чётное, то в двоичный разряд посылается 1, если
нечётное, то - 0.  Время  7D 0t выбирается таким, чтобы вероятность по-
лучения 1 в разряде (как и вероятность получения 0) была равна  51 0/ 42 0.
   Естественно, что при параллельной работе k генераторов будет по-
лучено значение k-разрядной двоичной дроби.
    22. 0  _ 1Таблицы случайных чисел . 0.
   Для того, чтобы не тратить время на получение значений случайной
величины  с  равномерным  распределением на отрезке [0,1],   1заранее
составлены таблицы этих значений,  используя,  например, физические
генераторы  случайных чисел;  эти таблицы называются  _ 1таблицами слу-
 _ 1чайных чисел . 0 (см.  _ 1Приложение . 0).
   Таблицы случайных чисел имеет смысл использовать только при  1руч-
 1ных расчётах 0. Для  1компьютерных вычислений 0 использование таблиц слу-
чайных  чисел,  хранящихся во внешней памяти компьютера,  замедляет
процесс вычислений.  Однако в связи с постоянно возрастающей опера-
тивной памятью  таблицы вновь становятся весьма практичными в прог-
раммировании.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1H.

 ш1.2
    23. 0  _ 1Псевдослучайные последовательности чисел . 0.
   Наиболее распространенный метод заключается в  применении   _ 1алго-
 _ 1ритма . 0,  вырабатывающего  в  случае необходимости "случайные" числа,
используемые компьютерной программой.
   Поскольку подобные числа генерируются алгоритмом, они не являют-
ся случайными, и их следует называть  _ 1псевдослучайными числами . 0.
    2Определение 0.
 ш1.1
    _ 1Генераторами псевдослучайных чисел . 0 называются алгоритмы,  порож-
дающие псевдослучайные числа по заданному закону распределения.

 ш1.2
   Псевдослучайные числа не являются случайными  в  строгом  смысле
слова. Этим обстоятельством, однако, можно пренебречь, если сущест-
вуют алгоритмы, производящие " 1высококачественные 0" случайные числа.
   Прежде всего обратим внимание на то, что бессмысленно говорить о
"случайности" какого-то одного числа,  т.к. математические критерии
случайности всегда применяются к  1последовательности чисел 0.
    2Определение 0 (по [Кнут,2000,т.2,п.3.1]).
 ш1.1
    _ 1Случайной последовательностью . 0  называется последовательность не-
зависимых случайных чисел с определённым законом  распределения,  в
котором каждый элемент вырабатывается  _ 1случайно . 0 и  _ 1независимо . 0 от всех
других членов последовательности и принимает значение из некоторого
диапазона с определённой вероятностью.

 ш1.2
   Слова " 1случайно 0"  и " 1независимо 0" используются здесь,  чтобы под-
черкнуть,  что характер и способ взаимодействия событий, определяю-
щих выбор конкретного числа,  слишком сложен,  чтобы распознать его
статистическими или какими-то другими тестами.
   Теоретические достичь этого идеала детерминированными процедура-
ми невозможно. Цель же многочисленных алгоритмических средств гене-
рации чисел - как можно ближе приблизиться к этому идеалу.
   Параллельно разрабатываются  теоретические  и эмпирические  _ 1тесты
для распознавания характера и структуры  последовательностей  псев-
дослучайных чисел и,  следовательно, для оценки качества алгоритмов
генерации этих последовательностей.
    _ 1Преимущества . 0 использования псевдослучайных чисел таковы:
 ш1.1
   (а) для  получения  каждого числа используется несколько простых
операций, поэтому скорость генерирования псевдослучайных чисел име-
ет тот же порядок, что скорость работы процессора;
   (б) любое псевдослучайное число может быть легко воспроизведено;
   (в) необходимо только один раз проверить "качество" такой после-
довательности, затем её можно использовать многократно.

 ш1.2
    _ 1Недостатком . 0 метода является его  1псевдослучайность 0,  т.е. наличие
 1периодичности 0 (повторяемости), что приводит к ограниченности "запа-
са" псевдослучайных чисел.
    3Замечание 0 ( 1важное 0).
 ш1.1
   Для краткости будем иногда опускать слово  " 1псевдо 0"  и  говорить
просто " 1случайные числа 0", " 1случайные последовательности 0" и " 1генера-
 1торы случайных чисел 0".
 ш1.2

                 2Моделирование псевдослучайных чисел

 ш1.0
            1Всякий, кто питает слабость к арифметическим методам по-
            1лучения случайных чисел, грешен вне всякого сомнения. 0
                                                1Дж. 0  1фон Нейман, 1949
 ш1.2

   Методы, вырабатывающие псевдослучайные числа с некоторым распре-
делением, обычно основаны на первоначальном получении псевдослучай-
ного целого числа,   1равномерно распределённого на 0 [0,n],  n 7е ═N 0,  или
псевдослучайного действительного числа,   1равномерно распределённого
 1на 0 [0,1].
   Полученное число затем "приспосабливается" с помощью  некоторого
алгоритма к требуемому закону распределения.

                     21. 0  3Метод середины квадратов

 ш1.0
             1Гений не делает ошибок. Его промахи - преднамеренные...
                                                           1Дж. 0  1Джойс
 ш1.2

   Классический метод генерации последовательности  псевдослучайных
натуральных чисел состоит в выборе  1некоторой 0 функции f: ═N 0─ 76 ═N 0,  отоб-
ражающей множество натуральных чисел в себя;  далее, выбирается  1не-
 1которое 0 (?!) число х 40 7е ═N 0 и каждое следующее натуральное число порож-
дается с помощью  1рекуррентного соотношения
 ш1.0

   x 4k+1 0=f(x 4k 0), х 40 7е ═N 0.

 ш1.2
   Приведём один из  первых  алгоритмов (Дж. фон Нейман, 1946), на-
званный  _ 1методом середины квадратов . 0.
   Для порождения  1псевдослучайного бита 0 функция f: ═N 0─ 76 ═N 0, конструиру-
ется следующим образом:
 ш1.1
   (1) задаётся некоторое 31-разрядное двоичное число;
   (2) оно возводится в квадрат: получается 62-разрядное число;
   (3) выбирается его 31-й (средний) разряд.

 ш1.2
   Для порождения  последовательности  значений случайной величины,
равномерно распределённой на [0,1],  используется следующий  _ 1вариант
 _ 1метода середины квадратов . 0.
   Возьмём некоторое число r 40 0=0.9876 и приступим к вычислениям:
 ш1.0

      r 40 0=0.9876 => r 40 52 0=0.97 _5353 .76 =>

   => r 41 0=0.5353 => r 41 52 0=0.28 _6546 .09 =>

   => r 42 0=0.6546 => r 42 52 0=0.42 _8501 .16 => 7 777

 ш1.2
   Последовательность чисел  r 41 0,r 42 0,r 43 0,...  примем за последователь-
ность значений случайной  величины,  равномерно  распределённой  на
[0,1].
   Другими словами,  предшествующее  случайное  число  возводится в
квадрат,  и в качестве следующего случайного числа в последователь-
ности берутся цифры из  1середины 0  десятичного  представления  числа,
полученного в результате возведения предшествующего в квадрат.
   Однако метод имеет существенный  _ 1недостаток . 0: число r 4k 0 может иног-
да (непредсказуемо), обратиться в 0, и тогда все последующие значе-
ния r 4k+1 0,r 4k+2 0,... будут равны 0.
   Для наглядной демонстрации этого рассмотрим ещё один  _ 1вариант ме-
 _ 1тода середины квадрата . 0 [Бакнелл,2003,с.211]:  возьмём n-значное на-
туральное число, возведём его в квадрат и из результата, выраженно-
го в виде 2n-значного числа (при необходимости  дополненного  слева
нулями до 2n-значного), возьмём средние n цифр.
   Это число - следующее число в последовательности.
   Приведём несколько  _ 1удачных . 0 (!)  _ 1тестовых примеров . 0:
   (1) пусть в  последовательности  четырёхзначных  псевдослучайных
чисел  встретилось число меньшее 10;  тогда при вычислении квадрата
будет получено число,  меньшее 100, и, следовательно, все последую-
щие числа в последовательности будут равны 0;
   (2) если в качестве начального числа взять число 1234, то до по-
падания в 0 последовательность будет содержать всего 55 чисел.
   Первыми числами будут:
 ш1.0

   1234, 5227, 3215, 3362, 3030, 1809,...;

 ш1.2
   (3) если начать,  например,  с числа 4100, то последовательность
будет содержать
 ш1.0

   4100,6100,2100, 4100,6100,2100,...
    ═└ 0───── ═┬ 0────── ═┘ 0   ═└ 0───── ═┬ 0────── ═┘

 ш1.2
   Итак, несмотря на простоту,  применение метода середины квадрата
предельно ограничено, а использование для генерации псевдослучайных
чисел функции f  _ 1без теоретического анализа . 0 часто приводят к катаст-
рофическим последствиям.
                3Работа с демонстрационными примерами
   См. Пример 2H.

                 22. 0  3Генерация линейных конгруэнтных
                         3последовательностей

 ш1.0
                        1- Он может быть мной,  - заметил отец Браун,
                        1беззаботно пренебрегая правилами грамматики.
                            1Г.К.Честертон. Проклятие золотого креста
 ш1.2

   Рассмотрим часто используемый  _ 1метод генерации линейных конгруэн-
 _ 1тных последовательностей . 0, предложенный Д.Лемером ( 1D.H.Lehmer 0, 1951).
    3Замечание 0.
 ш1.1
    _ 1Конгруэнтность . 0 (лат.  1congruens 0 -  1соразмерный 0,  1соответствующий 0).

 ш1.2
    2Определение 0.
 ш1.1
    2(1) 0  _ 1Линейной  конгруэнтной последовательностью . 0 называется после-
довательность натуральных чисел, элементы которой получаются по за-
данному  1начальному значению 0 x 40 7е ═N 0 из  1линейного рекуррентного соотно-
 1шения 0
 ш1.0

   x 4i+1 0=( 3a 0x 4i 0+ 3c 0) 4  0mod  3m 0, i=0,1,2,...,

где используются следующие термины:

     3m 0  -  _ 1модуль . 0,      3m 7е ═N 1, 0  1  0     3m 0>0;
     3a 1  0  1-  _множитель . 0,  2  3a 7е ═N 0, 2     00 7, 3a 0< 3m 0;
     3c 0  -  _ 1приращение . 0,  3c 7е ═N 1,  2    00 7, 3c 0< 3m 0;
    x 40 0 -  _ 1начальное значение . 0, 7  00 7, 0x 40 0<m.

 ш1.2
    2Определение 0.
 ш1.1
    2(1) 0  _ 1Мультипликативным конгруэнтным методом . 0 называется метод  по-
лучения линейной конгруэнтной последовательности при  3c 0=0, т.е.
 ш1.0

   x 4i+1 0= 3a 0x 4i  0mod  3m 0, i=0,1,2,...

 ш1.1
    2(2) 0  _ 1Смешанным конгруэнтным методом . 0 называют метод получения  ли-
нейной конгруэнтной последовательности при c 7- 00.

 ш1.2
   Вычисление остатков по модулю m  отчасти  напоминает  определён-
ность попадания шарика в  1ячейку 0 крутящегося колеса рулетки.
   Например, для  3m 0=10,  3a 0=7,  3c 0=7, x 40 0=7 получим последовательность
 ш1.0

                               ║ x 40 0=1 => 1, 4, 5, 2, 1,...
   7,6,9,0,7,6,9,0,7,6,9,0,... ║
    ═└ 0── ═┬ 0── ═┘ 0  ═└ 0── ═┬ 0── ═┘ 0  ═└ 0── ═┬ 0── ═┘ 0     ║ x 40 0=4 => 4, 5, 2, 1, 4,...

 ш1.2
   Итак, последовательность может оказаться "весьма детерминирован-
ной" при некоторых наборах чисел  3m 0,  3a 0,  3c 0, x 40 0.
   Линейная конгруэнтная последовательность всегда  образует  " 1пет-
 1ли 0", т.е. всегда существует бесконечный цикл. Это свойство является
общим для всех последовательностей вида
 ш1.0

   x 4n+1 0=f(x 4n 0),

 ш1.2
в которых функция f преобразует  1конечное 0 множество в себя.
    2Определение 0.
 ш1.1
    _ 1Периодом . 0 называется  повторяющийся участок линейной конгруэнтной
последовательности.

 ш1.2
   Например, период последовательности в примере выше равен 4.
   Безусловно, что последовательности,  используемые  на  практике,
обязаны обладать достаточно длинным периодом.
   Несмотря на кажущуюся простоту, линейные конгруэнтные последова-
тельности обладают хорошими свойствами "случайности", которые зави-
сят от выбора "волшебных" чисел:
 ш1.0

    3m 0,  3a 0,  3c 0, x 40 0,  3m 0>0, 0 7, 3a 0, 3c 0,x 40 0< 3m 0.

 ш1.2
    1Д.Кнут 0 [2000,т.2,с.25] показал, что линейная конгруэнтная после-
довательность с тщательно подобранными параметрами успешно проходит
испытание статистическими тестами,  однако  _ 1случайный выбор парамет-
 _ 1ров . 0 почти всегда приводит к плачевным результатам.
   Автор делает  _ 1важный вывод . 0:
 ш1.0

   ї...  1случайные числа не следует генерировать методом,
         1выбранным 0  1наудачу 0Ї.

 ш1.2
   Итак, необходимо  приложить усилия,  чтобы максимально увеличить
длину цикла или даже  построить  генератор,  вырабатывающий  только
последовательности с максимальной длиной цикла.
   Сформулируем  _ 1критерий . 0, позволяющий создавать именно такие линей-
ные конгруэнтные последовательности.
    2Теорема 0 [Кнут,2000,т.2,с.36] ( 1важная 0).
 ш1.1
   Линейная конгруэнтная последовательность с параметрами   3m 0,  3a 0,  3c 0,
x 40 0, имеет период длиной m  1тогда и только тогда, когда 0:
 ш1.0

    2(1) 0 НОД( 3c 0, 3m 0)=1;

 ш1.1
    2(2) 0 для каждого простого p такого,  что p│ 3m 0 (читается:  "p делит
m"), выполняется p│( 3a 0-1).
   Другими словами,  надо выполнить факторизацию натурального m,  а
затем для  _ 1всех . 0 полученных простых делителей проверить  выполнимость
p│( 3a 0-1);
    2(3) 0 если 4│ 3m 0, то 4│( 3a 0-1).

 ш1.2
    2Доказательство 0. См. [Кнут,2000,т.2,с.37-39].
    3Замечание 0 ( 1важное 0).
 ш1.1
   Выбор в качестве  3m 0 степени двойки обладает очевидным преимущест-
вом: вычислить вычет по модулю m можно с помощью операции AND.
   Однако имеется недостаток: младшие двоичные разряды генерируемых
чисел характеризуются гораздо меньшей случайностью,  чем старшие, а
значит, необходимо быть аккуратным при работе с такими числами.
   Выбор чисел   3a 0  и   3m 0 влияет на периодичность последовательности:
поскольку элементы последовательности могут принимать конечное чис-
ло  ( 3m 0)  различных значений,  последовательность начнёт повторяться
самое позднее на ( 3m 0+1)-м элементе.
   Точка входа в цикл - не обязательно начальное значение  x 40 0;  это
может быть и некоторое "более позднее" значение x 4t 0.

 ш1.2
    2Примеры 0 ( 1для знатоков императивных языков программирования 0).
 ш1.1
    21. 0 Генератор случайных чисел в TURBO Pascal определяется так:
 ш1.0

         4┌ 0                 4┐
   x 4i+1 0=│129 77 0x 4i 0+907633385│ 4  0mod 2 532 0.
         4└ ═└┬┘ 0     ═└ 0─── ═┬ 0─── ═┘ 4┘ 0      ═└┬┘
          a         c           m

 ш1.2
    22. 0  _ 1Стандарт ISO-C . 0 рекомендует использовать  для  функции  rand()
 1линейную  конгруэнтную последовательность 0,  параметры которой удов-
летворяют приведённому выше критерию:
 ш1.0

         4┌ 0                    4┐
   x 4i+1 0=│1103515245 77 0x 4i 0+12345│ 4  0mod 2 5k 0,
         4└ ═└ 0─── ═┬ 0──── ═┘ 0     ═└ 0─ ═┬ 0─ ═┘ 4┘ 0     ═└┬┘
             a           c        m

 ш1.1
где k выбирается так,  чтобы 2 5k 0-1 было наибольшим  числом,  которое
можно задать типом unsigned int (в частности k=31).
   Недостатком этого  генератора (отмеченного в документации) явля-
ется то, что младшие биты генерируемого случайного числа "не совсем
случайны".
    23. 0 [Вельшенбах,2004,с.260] В функции rand() библиотеки GNU-C ис-
пользуются параметры
 ш1.0

   a=69069, c=5, m=2 532 0.

 ш1.1
   Число a=69069, предложенное Дж.Марсальей, показывает в сочетании
с модулем  m=2 532 0  хорошие  статистические результаты и максимальную
длину периода.
 ш1.2

             23. 0  3Генерация значения дискретной случайной
                  3величины 0  3по закону распределения

 ш1.0
                 1Ясно даже и ежу -
                 1Этот Петя был буржуй.
                     1В.В.Маяковский. Сказка о Пете, толстом ребёнке,
                                     1и о Симе, который тонкий 0 (1925)
 ш1.2

   Опишем алгоритм  генерации значения дискретной случайной величи-
ны, заданной  1законом распределения 0:
 ш1.0

      7( 0                            7)
    2x 0: 7* 0(x 41 0,p 41 0),(x 42 0,p 42 0),...,(x 4n 0,p 4n 0) 78 0.
      79 0                            70

 ш1.2
   Вначале разобъём отрезок [0,1] оси x на n частичных интервалов:
 ш1.0

        7D 41 7    D 42 7      D 43 7                D 4n-1 7        0  7D 4n
      ═┌ 0─ ═┴ 0─ ═┐ 0  ═┌ 0─ ═┴ 0─ ═┐ 0  ═┌ 0─── ═┴ 0─── ═┐ 0  ═┌ 0─ ═┴ 0─ 7777 0  7777 0── ═┴ 0─── ═┐ 0  ═┌ 0──── ═┴ 0──── ═┐
   ── ═O 0──── ═O 0───── ═O 0───────── ═O 0─────── 7777 0──────── ═O 0─────────── ═O 0── 76 0x
      20 0   7  0 p 41 0  p 41 0+p 42 0    p 41 0+p 42 0+p 43 0    7   0   p 41 0+p 42 0+ 7777 0+p 4n-1 0     21

 ш1.2
   Далее, генерируем вспомогательное случайное число z,  равномерно
распределённое на (0,1); если z 7еD 4i 0, то результатом генерации значе-
ния случайной величины 2 x 0 является число x 4i 0,  взятое из закона расп-
ределения.
                3Работа с демонстрационными примерами
   См. Пример 9H.

           24. 0  3Генерация значений нормально распределённой
                         3случайной величины

 ш1.0
                                                1У случая нет памяти.
                                                    1Автор неизвестен
 ш1.2

   Более сложным является генерация значения случайной  величины  с
непрерывным  распределением.  Однако некоторые часто используемые и
важные распределения достаточно хорошо исследованы.
   Наиболее известным является  1стандартное нормальное распределение
N(0,1), у которого a=1,  7s 0=1.
   Рассмотрим три  алгоритма:   1простейший  алгоритм 0,   1алгоритм Бок-
 1са-Мюллера 0,  1алгоритм Марсальи-Брея 0.
    2(а) 0  _ 1Простейший алгоритм . 0 таков:
   (1) генерируем числа y 41 0,y 42 0,...,y 412 0, равномерно распределённые на
[0,1);
 ш1.0

   (2) x 4i ═+ 02y 4i 0-1, i=1,2,...,12,

где x 4i 0 - случайные числа, равномерно распределённые на [-1,1);

   (3) z ═+ 0x 41 0+x 42 0+ 7777 0+x 412 0.

 ш1.2
   Полученный результат  z является  _ 1приближённым значением . 0 (!) неп-
рерывной случайной величины,  распределённой по  стандартному  нор-
мальному закону N(0,1).
    2(б) 0  _ 1Алгоритм Бокса-Мюллера . 0 (по [Кельберт,Сухов,2010,с.226]).
   Опишем классический алгоритм генерирования гауссовских случайных
величин на  компьютере,   предложенный   Дж.Боксом   и   М.Мюллером
( 1G.E.P.Box 0,  1M.E.Muller 0, 1958).
   Пусть случайные величины  2s 0 и  2t 0 независимы и равномерно распреде-
лены на [-1,1].  Генерируем числа s и t,  равномерно распределённые
на [-1,1], и проведём следующие вычисления:
 ш1.0

       7|\\\\ 0       s   7|\\\\\\\ 0     t   7|\\\\\\\
   r ═+ 7? 0s 52 0+t 52 0 => x ═+ 0 ─ 77? 0-2 1ln 0(r 52 0), y ═+ 0 ─ 77? 0-2 1ln 0(r 52 0).
                  r               r

 ш1.2
   Получены значения  независимых случайных величин  2x 0 и  2y 0,  имеющих
стандартное гауссовское распределение N(0,1).
    2(в) 0  _ 1Алгоритм Марсальи-Брея . 0 является модификацией алгоритма  Бок-
са-Мюллера. Приведём его, следуя [Афонин,Федосин,2012,с.57]:
   (1) генерируем два независимых случайных числа u 41 0 и  u 42 0,  равно-
мерно распределённых на [0,1);
   (2) конструируем два числа, равномерно распределённых на [-1,1):
 ш1.0

   v 41 ═+ 02u 41 0-1, v 42 ═+ 02u 42 0-1;

   (3) s ═+ 0v 52 41 0+v 52 42 0;

 ш1.2
   (4) если s>1,  то вернёмся к выполнению пунктов (1)-(3) (на этом
шаге теряется 22% эффективности алгоритма);
 ш1.0

              7|\\\\\\\\ 0         7|\\\\\\\\
   (5) x 41 ═+ 0v 41 7? 0-2 1ln 0(s)/s, x 42 ═+ 0v 42 7? 0-2 1ln 0(s)/s.

 ш1.2
   Получены значения независимых случайных величин  2x 41 0 и  2x 42 0, имеющих
стандартное гауссовское распределение N(0,1).
   Даже для малого количества генерируемых случайных чисел  (n=256)
среднее значение  близко к 0 ( 7~ 00.01),  а стандартное отклонение - к
единице ( 7~ 00.91).
            25. 0  3Генерация случайных чисел, 0  3распределённых
                           3по закону Коши
    _ 1Первый способ . 0.  Для  конструирования значений случайной величины
 2x 0, распределённой по  _ 1закону Коши . 0, используется соотношение
 ш1.0

    2x 0= 2y 0/ 2z 0,

 ш1.2
где  2y 0,  2z 0 - независимые стандартные нормальные случайные величины.
    _ 1Второй способ . 0.  Воспользуемся для моделирования выборки из этого
распределения  _ 1методом обратной функции . 0.
   Вначале выпишем функцию распределения для закона Коши:
 ш1.0

         1   1
    7а 0(x) ═+ 0 ─ + ─ 77 1arctg 0(x).
         2    7p

 ш1.2
   Обозначим y ═+ 7а 0(x)  и  решим  полученное  уравнение относительно x
(воспользуемся явным представлением обратной функции x= 7а 5-1 0(y))
 ш1.0

                              4┌ 0         4┐
   y= 51 0/ 42 0+1/ 7p7 1arctg 0(x) => x= 1tg 0│ 7p 0(y- 51 0/ 42 0)│=- 1ctg 0( 7p 0y).
                              4└ 0         4┘

 ш1.2
   Остаётся генерировать y -  равномерно  распределённое  случайное
число на (- 7$ 0, 7$ 0) и вычислить x - значение  случайной величины,  рас-
пределённой по закону Коши.
                26. 0  3Генерация случайных чисел, имеющих
                     3показательное распределение
   Воспользуемся для  моделирования  выборки из этого распределения
 _ 1методом обратной функции . 0:
 ш1.0

          7( 01- 1e 5- 7Ф 5x 0, если x 7. 00;                         1
     7а 0(x) ═+ 7* 0                  => y ═+ 01- 1e 5- 7Ф 5x 0, x 7. 00 => x=- ─ 77 1ln 0(1-y).
          79 00,      если x<0                           7a

 ш1.2
   Остаётся генерировать y -  равномерно  распределённое  случайное
число на (0,1) и вычислить x - значение случайной величины с  пока-
зательным распределением с параметром  7a 0.

                    2Проверка качества генераторов
                        2псевдослучайных чисел

 ш1.0
           1- Что ж,  - спокойно произнёс священник. - Действительно,
           1я верю в разные вещи,  в которые вы, возможно, не верите.
           1Но  мне  придётся очень долго объяснять,  во что я верю и
           1почему считаю, что я прав. С другой стороны, можно за две
           1секунды открыть эту дверь и доказать, что я ошибаюсь.
                                    1Г.К.Честертон. Чудо "Полумесяца"
 ш1.2

   Итак, генераторы линейных конгруэнтных последовательностей,  ис-
пользующие рекуррентные соотношения, в определённой степени страда-
ют корреляцией между последовательными генерируемыми числами.
   Поэтому необходимо тщательно проверять полученные  псевдослучай-
ные числа:
 ш1.1
   (а) вычислением длины периода псевдослучайной последовательности;
   (б) статистическими тестами;
   (в) решением  1модельных задач 0, т.е. задач с известным ответом.

 ш1.2
   Обсудим алгоритмы проверки для тестов пунктов (а) и (б).
    3Замечание 0 ( 1важное 0) (по [Успенский,2006,с.5]).
 ш1.1
   Перечислим свойства,  которыми обладает  _ 1случайная . 0 (!) последова-
тельность нулей и единиц:
   (1) она  _ 1частотоустойчива . 0, т.е. если 0 и 1 равновероятны, то час-
тота 0,  как и частота 1,  стремится к  51 0/ 42 0 ( 1частота нулей 0 - это  их
доля в  1начальном 0 (!) отрезке последовательности).
   Более того,  в случайной последовательности  указанная  устойчи-
вость  частот выполняется не только для последовательности в целом,
но и для любой её законной,  _ 1разумной . 0 подпоследовательности;
   (2)  _ 1последовательность хаотична . 0,  т.е.  она сложно устроена и не
может иметь  _ 1разумного . 0 описания.
   Например, цепочка
 ш1.0

   1000101110111101000010001011101111010000...

 ш1.1
воспринимается как  случайная  (хотя это и не так!) потому,  что её
устройство нельзя коротко описать, а вот цепочки
 ш1.0

   1111111111111111111111111111111111111111...,
   0101010101010101010101010101010101010101...

 ш1.1
имеют простое, легко описываемое устройство;
   (3) она  _ 1типична . 0,  т.е. принадлежит любому  _ 1разумному . 0 (подавляюще-
му) большинству;
   (4) она  _ 1непредсказуема . 0, т.е. играя против неё на деньги (пытаясь
угадать  члены  последовательности и делая ставки),  последователь-
ность невозможно обыграть вне зависимости от  _ 1разумности . 0 стратегии.
   Слово " 1разумный 0",  встречающееся в объяснениях перечисленных че-
тырёх свойств нуждается в уточнении.
   Теория алгоритмов как раз и предлагает такие уточнения, наполняя
это слово точным смыслом - своим для каждого из четырёх свойств.
 ш1.2

               21. 0  3Алгоритм Брента 0  3проверки 0  3генератора
                           3случайных чисел

 ш1.0
         1Генератор случайных чисел во многом подобен сексу 0:  1когда он
         1хорош - это прекрасно, когда он плох, всё равно приятно. 0
                                                  1Дж.Марселья  0( 11984 0)
 ш1.2

   Алгоритм Р.П.Брента позволяет проверить,  удовлетворяет ли неко-
торым условиям конкретная реализация генератора случайных чисел  на
языке программирования (исходный текст реализации, как правило, не-
известен).
   Этот алгоритм вычисляет длину 7  0периода последовательности, вычис-
ленной с помощью рекуррентного соотношения
 ш1.0

   x 4i+1 0=f(x 4i 0), i=1,2,..., x 40 7е ═N 0,

 ш1.2
где f: ═N 0─ 76 ═N 0 - порождающая функция.
   Пусть  7l 0 - длина периода последовательности.
    _ 1Алгоритм Р.П.Брента . 0 (по [Вельшенбах,2004,с.260]).
 ш1.0

    2(1) 0 y:=x 40 0, r:=1, k:=0;

    2(2) 0 x:=y, j:=k, r:=2*r;

    2(3) 0 k:=k+1,  y:=f(y).

 ш1.1
   Повторяйте шаг (3), пока не выполнится условие (x==y) 7v 0(k 7. 0r).
 ш1.0

    2(4) 0 Если x 7- 0y, то вернитесь на шаг (2), иначе  7l 0:=k-j.

 ш1.2
   Процесс завершится  1успехом 0,  если на шаге (3) получается   _ 1точное
значение f(y),  и  1неудачей 0 (как для ISO-рекомендации),  если вместо
точных значений будут определены лишь их старшие разряды.
   Пусть  7m 0 - длина  1начальной 0 (до периодического участка)  1части 0 пос-
ледовательности.
   Тогда алгоритм "вычисляет" функцию f не более
 ш1.0

         7( 0    7)
   2 77 1max 7*m 0, 7l8 0 раз.
         79 0    70

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 6H, Пример 6C.

                 22. 0  3Критерий 0  7c 52 3 проверки 0  3генератора
                           3случайных чисел

 ш1.0
                1- Объяснитесь.
                1- Когда придёт время, я объясню вам всё, будьте спо-
                1койны. 0  1Вы не апостол Павел, а я не Христос, однако я
                1скажу вам 0:  1"Маловерный, зачем ты усомнился 0! 1" 0
                   1А.Дюма. Виконт де Бражелон, или Десять лет спустя
 ш1.2

   Пусть n -  _ 1объём выборки . 0,  содержащей  псевдослучайные  числа  из
 _ 1множества категорий . 0
 ш1.0

                      ║  1  0    1Категория 0  1Категория 0        1Категория
   M={0,1,...,m-1},   ║  1  0── ═O 0───────── ═O 0───────── ═O 0─ 7777 0─ ═O 0───────── ═O 0─ 76
                      ║   1  0   ═└ 0─── ═┬ 0─── ═┘ 0  ═└ 0─── ═┬ 0─── ═┘ 0        ═└ 0─── ═┬ 0─── ═┘
   n=h 40 0+h 41 0+...+h 4m-1 0,  ║    1  0 h 40 0  1чисел 0   h 41 0  1чисел 0       h 4m-1 0  1чисел
                      ║

 ш1.2
где h 4m 0 - количество значений m 7е 0М в выборке.
   Рассматриваемый ниже  тест корректен только для  1достаточно боль-
 1шой выборки 0:
 ш1.0

   n 7. 05m.

 ш1.2
   Вычислим
 ш1.0

       5m-1 0               5m-1
       7░▒ 0 (h 4i 0-n/m) 52 0   m  7░▒
    7c 52 0=  7▓ 0 ───────── = ─ 77 0  7▓ 0 h 4i 52 0-n.
       7│┤ 0    n/m      n  7│┤
       5i=0 0               5i=0

 ш1.2
   Проверка повторяется для нескольких случайных выборок.
    _ 1Грубая аппроксимация . 0  7c 52 0- _ 1распределения . 0 позволяет  сделать  вывод,
что в  большинстве случаев результат  7c 52 0 должен находиться в следую-
щем интервале:
 ш1.0

    4┌ 0     7|\ 0      7|\ 4┐ 0           4┌ 0     7|\ 0      7|\ 4┐
   │m-2 7? 0 m,m+2 7? 0 m│, т.е.  7c 52 7е 0│m-2 7? 0 m,m+2 7? 0 m│.
    4└ 0              4┘ 0           4└ 0              4┘

 ш1.2
   В противном  случае данную последовательность можно считать "не-
достаточно" случайной.
   При этом  вероятность принять действительно "хорошую" псевдослу-
чайную последовательность за "плохую" на основании результатов тес-
та  7c 52 0 приблизительно равна 2%.
   Проверка по  7c 52 0-критерию часто производится три (и более)  раз  с
разными данными.
   Если по крайней мере два из трёх результатов  1  0оказываются   1подо-
 1зрительными 0, то числа рассматриваются как недостаточно случайные.
                3Работа с демонстрационными примерами
   См. Пример 7.

                  2Генераторы псевдослучайных чисел
                 2в языках, отличных от языка Haskell

 ш1.0
                      1Электрический мозг будет думать за  нас  точно
                      1так же, как электрический стул за нас умирает.
                                                               1Е.Лец
 ш1.2

           21. 0  3Работа с псевдослучайными числами в языке C
                           ( 1повторение 0)
   Функция  2rand() 0  генерирует   1равномерно распределённое 0 псевдослу-
чайное целое число в диапазоне от 0 до RAND_MAX  (другими  словами,
каждое  натуральное  число  между 0 и RAND_MAX имеет равную вероят-
ность быть выбранным при каждом вызове функции rand()).
   Здесь RAND_MAX - символическая константа, определённая в заголо-
вочном файле stdlib.h.
    2Определение 0 ( 1в программировании 0).
 ш1.1
    2(1) 0  _ 1Масштабированием . 0  называется  следующее  сочетание   функции
rand() с операцией взятия по модулю (%):
 ш1.0

   rand()%n,

 ш1.1
используемое для генерирования случайных целых чисел в диапазоне от
0 до n-1.
    2(2) 0  _ 1Коэффициентом масштабирования . 0 называется число n.

 ш1.2
   При вызове rand() генерируется последовательность чисел, которые
выглядят случайными.  Однако эта последовательность повторяется при
каждом новом выполнении программы. При  _ 1отладке программы . 0 эта повто-
ряемость  является  существенным  фактором для доказательства того,
что исправления, внесённые в программу, работают правдоподобно.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1C.

 ш1.2
   Когда программа будет отлажена,  можно модифицировать её для ге-
нерации  различных  последовательностей случайных чисел для каждого
выполнения. Эта технология называется  _ 1рандомизацией . 0 и обеспечивает-
ся функцией стандартной библиотеки  2srand() 0.
   Функция  2srand() 0 получает в качестве аргумента  целое  без  знака
(типа unsigned), называемое  _ 1семенем . 0, которое позволяет получать при
использовании rand() различные последовательности  случайных  чисел
при каждом исполнении программы.
   Если мы хотим проводить рандомизацию без ввода семени,  мы можем
вызвать функцию srand() с параметром time(NULL), т.е. написать
 ш1.0

   srand(time(NULL));

 ш1.2
   Компьютер здесь считывает показания  1внутренних часов 0,  чтобы ав-
томатически получить значение, не определённое заранее.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 2C, Пример 3C, Пример 4C.

 ш1.2
                 22. 0  3Генерация псевдослучайных чисел
                              3в языке C
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 5C.

 ш1.2
                23. 0  3Работа с псевдослучайными числами
                            3в языке 0  3LISP
   Опишем синтаксис и семантику функций библиотеки RANDOM.LSP.
   Для генерации псевдослучайных чисел используется  _ 1метод генерации
 _ 1линейной конгруэнтной  последовательности . 0,  по  которому  очередное
число  2seed 0 получается по формуле:
 ш1.0

   seed=(seed*p+i) MOD m.

 ш1.2
   (а) Функция
 ш1.0

   ( 2RANDOMIZE  0seed p i m)

 ш1.2
инициализирует начальные значения для генератора "случайных"  чисел
RAND.
   Если несколько (или все) аргументы функции отсутствуют или равны
NIL, то начальные значения переменных устанавливаются следующими:
 ш1.0

   seed ( 1семя 0) получает значение таймера (TIME),
   p=25173,
   i=13849,
   m=65536.

 ш1.2
   Значения трёх последних переменных позволяют получать последова-
тельность с  _ 1периодом . 0 65536.
   Инициализация семени значением системного таймера приводит к то-
му, что при каждом новом запуске  muLISP  функция  RAND  возвращает
различные числа.
   (б) Функция
 ш1.0

   ( 2RAND 0 N)

 ш1.2
возвращает "случайное" натуральное число.
   Если N является натуральным числом меньшим  m,  то  возвращаемое
функцией значение находится в диапазоне от 0 до (N-1) включительно.
   В противном случае значение функции находится в диапазоне  от  0
до  (m-1)  включительно.  Переменная  m по умолчанию имеет значение
65536 (см. функцию RANDOMIZE).
   Если перед  вызовом функции RAND в текущем сеансе системы muLISP
не была ни разу вызвана функция RANDOMIZE,  то она  вызывается  без
аргументов функцией RAND.
    2Пример 0.
 ш1.0

   $ (RAND)         $ (RANDOMIZE 35)       $ (RAND 10)
   21572            35                     4

   $ (RAND 1)       $ (RAND)
   0                42936

   $ (RAND 5)       $ (RAND)
   4                22065

 ш1.2
   Приведём маленькую библиотеку random.lsp,  реализующую генератор
случайных чисел  1методом смешанных вычетов 0:
 ш1.0

   ; Демонстрация реализации генератора случайных чисел random
   ; (метод смешанных вычетов)
   ; Автор: А.В.Коротков, 11.07.2004
   ; -------------------------------
   (DEFUN RANDOMIZE (LAMBDA L
   ; Функция рандомизации. Устанавливает семя в (CAR L).
   ; L=(rand-seed rand-p rand-i rand-m)
   ; ----------------------------------------------------------
      (COND ( (INTEGERP (CAR L))    (SETQ rand-seed  (CAR L)) )
            ( T                     (SETQ rand-seed   (TIME)) ))
      (COND ( (INTEGERP (CADR L))   (SETQ rand-p    (CADR L)) )
            ( T                     (SETQ rand-p       25173) ))
      (COND ( (INTEGERP (CADDR L))  (SETQ rand-i   (CADDR L)) )
            ( T                     (SETQ rand-i       13849) ))
      (COND ( (INTEGERP (CADDDR L)) (SETQ rand-m  (CADDDR L)) )
            ( T                     (SETQ rand-m       65536) ))
      (SETQ rand-seed (MOD rand-seed rand-m))
   ))
   ; ---------------------
   (DEFUN RAND (LAMBDA (M)
   ; Функция возвращает случайное натуральное число. 
   ; Обращение к функции:
   ;   (RAND)   - диапазон: от 0 до 65535;
   ;   (RAND M) - диапазон: от 0 до (M-1);
   ; ----------------------------------------------------
      (COND ( (EQUAL 'rand-seed rand-seed) (RANDOMIZE) ))
      (SETQ rand-seed (MOD (+ (* rand-seed rand-p) rand-i) rand-m))
      (COND ( (INTEGERP M) (mod rand-seed M))
            ( T rand-seed))
   ))
   (RDS)

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 8L.

                   2Генерация псевдослучайных чисел
                           2в языке Haskell

 ш1.0
                       1Если человек  может  рассказать идею фильма в
                       125 слов, из этого можно сделать хорошее кино.
                       1Я люблю идеи, которые можно подержать в руке.
                                                          1С.Спилберг
 ш1.2

   Язык программирования  Haskell  является  чистым  функциональным
языком, т.е. он обладает свойством  _ 1детерминированности . 0, которое вы-
ражается в том,  что если функции дважды передать один и тот же ар-
гумент, она должна дважды вернуть один и тот же результат.
   Это, конечно, удобно, поскольку облегчает размышления о програм-
мах. Однако из-за этого получать случайные числа не так-то просто.
   Как императивные языки вычисляют псевдослучайные числа?  Они по-
лучают некоторую информацию от компьютера, например: текущее время,
как часто  и в каком направлении перемещается мышь,  какие звуки вы
издаёте, когда сидите за компьютером, и, основываясь на этом, выда-
ют число, которое на самом деле выглядит случайным.
   Комбинации этих факторов (их случайность), вероятно, различаются
в каждый  конкретный  момент времени;  таким образом,  и получаются
разные случайные числа.
   Также вы можете создавать случайные числа и в языке Haskell, ес-
ли напишете функцию, которая принимает случайные величины как пара-
метры и, основываясь на них, возвращает некоторое число (или другой
тип данных).
   Рассмотрим  1технологии генерации псевдослучайных списков 0.
                 21. 3 Генерация псевдослучайных чисел
                     3без использования 0  3библиотек
   Воспользуемся (по  [Роганова,2002,с.144]) простым алгоритмом для
получения  целых  чисел,  равномерно  распределённых  на  интервале
[0,2147483647], который реализуем на языке Haskell:
 ш1.0

> next_seed:: Int -> Int
> next_seed n = case test > 0 of
>                 True  -> test
>                 False -> test + 2147483647
>     where test = 48271 * lo - 3399 * hi
>           hi   = n `div` 44488
>           lo   = n `mod` 44488

 ш1.2
   Начальное значение может быть выбрано произвольно.
   Для получения различных случайных чисел следует применить данный
алгоритм к другому начальному значению.
   Вызов функции next_seed даёт первое псевдослучайное число, пере-
даваемое ей вновь в качестве нового аргумента. Для реализации этого
подхода удобно использовать функционал iterate
 ш1.0

> rand:: [Int]
> rand = iterate next_seed 23765492

 ш1.2
   Из бесконечного списка,  генерируемого  функцией  rand,  следует
выбрать требуемое число начальных элементов при помощи функции take:
 ш1.0

> test1 = take 10 rand

 ш1.2
   Для получения списка случайных чисел,  меньших заданного  значе-
ния, можно брать остаток от деления случайного числа на данное:
 ш1.0

> rand' :: Int -> [Int]
> rand' a = [x `mod` a | x <- rand]

 ш1.2
   В результате использования этой функции  получается  бесконечный
список чисел в диапазоне от 0 до (a-1):
 ш1.0

> test2 = take 20 (rand' 5)

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 3H, Пример 4H.

 ш1.2
   Для простейшего  тестирования  построенного  генератора  напишем
функцию [Роганова,2002,с.145],  которая  подсчитывает долю чётных и
нечётных чисел в последовательности, получаемой с помощью описанно-
го выше генератора.
   Сначала определим  функцию  quantum,  возвращающую  пару чисел -
число нечётных и чётных чисел в списке,  являющемся аргументом дан-
ной функции:
 ш1.0

> quantum:: [Int] -> (Int,Int)
> quantum [] = (0,0)
> quantum (x:xs) = case odd x of
>                    True  -> (u+1, v)
>                    False -> (u, v+1)
>     where (u,v) = quantum xs

 ш1.2
   Подсчитаем с её помощью число чётных и нечётных чисел среди пер-
вой тысячи целых чисел:
 ш1.0

> test3 = quantum [1..1000] == (500,500)

 ш1.2
   Функция proportion подсчитывает долю каждого элемента пары от их
суммарного количества:
 ш1.0

> proportion:: (Int,Int) -> (Float,Float)
> proportion (0,0) = (0.0,0.0)
> proportion (0,_) = (0.0,1.0)
> proportion (_,0) = (1.0,0.0)
> proportion (a,b) = (fromInt a/c,fromInt b/c)
>     where c = fromInt (a + b)

 ш1.2
   Остаётся применить композицию этих функций  к  списку  случайных
чисел, полученного с помощью функции rn:
 ш1.0

> rn:: Int -> [Int]
> rn n = take n rand
> ---------------------------
> test:: Int -> (Float,Float)
> test = proportion . quantum . rn

 ш1.2
   Функция test определена в в виде композиции трёх функций. Теперь
проведём тестирование полученной последовательности:
 ш1.0

> test4 = test 500  == (0.508, 0.492)
> test5 = test 5000 == (0.5008,0.4992)

 ш1.2
   Итак, доли чётных и нечётных чисел достаточно близки.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 5H.

 ш1.2
                 22. 3 Генерация псевдослучайных чисел
                   3с 0  3использованием модуля Random
   Перечислим (по   [Липовача,2012,с.250-255])  часто  используемые
функции из модуля  2Random 0,  в котором задействованы следующие  _ 1классы
 _ 1типов . 0:
 ш1.1
   (а)  3RandomGen 0 предназначен для типов,  которые могут служить  1ге-
 1нераторами случайности 0 (другими словами, источниками случайности);
   (б)  3Random 0 предназначен для типов,  которые могут принимать слу-
чайные значения.

 ш1.2
    21. 0 Рассмотрим функцию random, имеющую следующий тип:
 ш1.0

    3random 0 :: (RandomGen g, Random a) => g -> (a,g)

 ш1.2
   Функция принимает   _ 1генератор случайности . 0 ( 1источник случайности 0),
а возвращает пару,  содержащую случайное значение и новый генератор
случайности.
   Зачем она  возвращает новый генератор вместе со случайным значе-
нием?
   Чтобы воспользоваться функцией random,  нам нужно получить  один
из генераторов случайности.
   Модуль Random  экспортирует  полезный тип  3StdGen 0,  который имеет
экземпляр класса RandomGen.  Мы можем создать значение типа  StdGen
вручную или "попросить" систему автоматически выдать генератор слу-
чайности.
    22. 0 Для создания генератора "вручную", используйте функцию
 ш1.0

    3mkStdGen 0 :: Int -> StdGen,

 ш1.2
которая принимает целое число и основывается на нём, возвращает ге-
нератор.
   Функция random может возвращать значения  любого  типа,  который
входит в класс типов Random,  поэтому мы должны указать,  какой тип
мы желаем получить в результате;  также вспомним, что функция возв-
ращает случайное значение и генератор в паре:
 ш1.0

> test6 = random (mkStdGen 100) :: (Int, StdGen)
>                             -- (-1352021624,651872571 1655838864)
> test7 = fst test6

 ш1.2
   Первый компонент кортежа - это случайное число, второй элемент -
 _ 1текстовое . 0 представление нового генератора.
   Вызовем функцию random с тем же генератором снова:
 ш1.0

> test8 = random (mkStdGen 100) :: (Int, StdGen)
>                             -- (-1352021624,651872571 1655838864)

 ш1.2
   Получен тот же результат для тех же аргументов.
   Теперь передадим другой генератор в аргументе:
 ш1.0

> test9 = random (mkStdGen 949494) :: (Int, StdGen)
>                             -- (539963926,466647808 1655838864)

 ш1.2
   Получено другое число!
   Теперь будем использовать аннотацию типа  и  получать  случайные
значения разных типов:
 ш1.0

> test10 = random (mkStdGen 949488) :: (Float, StdGen)
>                             -- (0.8938442,1597344447 1655838864)
> test11 = random (mkStdGen 949488) :: (Bool, StdGen)
>                             -- (False,1485632275 40692)
> test12 = random (mkStdGen 949488) :: (Integer, StdGen)
>                             -- (1691547873,1597344447 1655838864)

 ш1.2
    2Пример 0 [Липовача,2012,с.252-253].
 ш1.1
   Напишем функцию, эмулирующую  _ 1трёхкратное . 0 подбрасывание монеты.
   Если бы функция random не возвращала новый генератор  вместе  со
случайным значением,  то  пришлось бы передавать в функцию три слу-
чайных генератора в качестве параметров и затем возвращать  резуль-
тат  подбрасывания  монеты  для каждого из них.  Но это выглядит не
очень разумным, потому что если один генератор может создавать слу-
чайные  значения типа Int (а он может принимать довольно много раз-
ных значений),  его должно хватить и на  троекратное  подбрасывание
монеты (что даёт восемь комбинаций).
   В таких случаях оказывается очень полезно,  что  функция  random
возвращает новый генератор вместе со значением.
   Будем представлять монету с помощью Bool:  True - это  выпадения
"орла", а False - "решки":
 ш1.0

> threeCoins :: StdGen -> (Bool,Bool,Bool)
> threeCoins gen = let (firstCoin, newGen)   = random gen
>                      (secondCoin, newGen') = random newGen
>                      (thirdCoin, newGen'') = random newGen'
>                  in (firstCoin,secondCoin,thirdCoin)

 ш1.1
   Мы вызываем функцию random с генератором, который передали в ар-
гументе,  и получаем монету и новый генератор.
   Затем снова вызываем функцию random,  но на этот раз с новым ге-
нератором, чтобы получить вторую монету;  далее, делаем то же самое
с третьей монетой.
   Если бы мы вызывали функцию random с одним генератором, то в ре-
зультате мы могли бы получать только (False,False,False) или (True,
True,True).
 ш1.0

> test13 = threeCoins (mkStdGen  21) == (True,True,True)
> test14 = threeCoins (mkStdGen  22) == (True,False,True)
> test15 = threeCoins (mkStdGen 943) == (True,False,True)
> test16 = threeCoins (mkStdGen 944) == (True,True,True)

 ш1.2
    23. 0 Функция
 ш1.0

    3randoms 0 :: (Random a, RandomGen g) => g -> [a]

 ш1.2
принимает генератор g и возвращает список,  содержащий  бесконечную
последовательность значений, основываясь на переданном генераторе.
   Рассмотрим несколько примеров:
 ш1.0

> test17 = (take 5 $ randoms (mkStdGen 11) :: [Int])
>     == [-1807975507,545074951,-1015194702,-1622477312,-502893664]
> -----------------------------------------------------------------
> test18 = (take 5 $ randoms (mkStdGen 11) :: [Bool])
>     == [True,True,True,True,False]
> ----------------------------------------------------
> test19 = (take 5 $ randoms (mkStdGen 11) :: [Float])
>     == [7.904789e-2,0.62691015,0.26363158,0.12223756,0.38291094]

 ш1.2
   Почему функция randoms не возвращает новый генератор  вместе  со
списком? Мы легко могли бы реализовать функцию randoms вот так:
 ш1.0

> randoms' :: (RandomGen g, Random a) => g -> [a]
> randoms' gen = let (value, newGen) = random gen
>                in value: randoms' newGen

 ш1.2
   Мы получаем случайное значение и новый генератор из текущего ге-
нератора,  а затем создаём список, который помещает сгенерированное
значение в "голову" списка,  а значения,  сгенерированные по новому
генератору, в "хвост".
   Так как теоретически мы можем генерировать бесконечное количест-
во чисел, вернуть новый генератор нельзя. Создадим функцию, которая
генерирует конечный список чисел и новый генератор:
 ш1.0

> finiteRandoms :: (RandomGen g, Random a, Num n)
>                                             => n -> g -> ([a],g)
> finiteRandoms 0 gen = ([],gen)
> finiteRandoms n gen =
>            let (value,newGen) = random gen
>                (restOfList,finalGen) = finiteRandoms (n-1) newGen
>            in (value : restOfList, finalGen)
> --------------------------------------------------------------
> test20 = finiteRandoms 10 (mkStdGen 100) :: ([Integer],StdGen)

 ш1.2
   Если нужно 0 чисел, то возвращаем пустой список и исходный гене-
ратор.
   Для любого  другого количества требуемых случайных значений вна-
чале получаем одно случайное число и  новый  генератор.  Это  будет
"голова" списка.
   Затем мы говорим,  что "хвост" будет состоять из (n-1)-го числа,
сгенерированного новым генератором.
   Далее возвращаем объединенные "голову" и остаток  списка  и  фи-
нальный генератор,  который получили после вычисления (n-1) случай-
ных чисел.
    24. 0 Функция
 ш1.0

    3randomR 0 :: (RandomGen g, Random a) => (a,a) -> g -> (a,g)

 ш1.2
по диапазону,  заданному парой (a,a),  возвращает пару,  содержащую
список  случайных значений в указанном диапазоне,  полученный с по-
мощью генератора случайности g, и новый генератор случайности.
   Рассмотрим несколько примеров:
 ш1.0

> test21 = randomR (1,6) (mkStdGen 359353) :: (Integer,StdGen)
>                                           -- (6,1494289578 40692)
> test22 = randomR (1,6) (mkStdGen 35935335) :: (Integer,StdGen)
>                                           -- (3,1250031057 40692)

 ш1.2
    25. 0 Функция
 ш1.0

    3randomRs 0 :: (Random a, RandomGen g) => (a,a) -> g -> [a]

 ш1.2
возвращает список случайных значений с помощью заданного генератора
случайности g в заданном диапазоне (a,a).
   Рассмотрим пример:
 ш1.0

> test23 = (take 10 $ randomRs ('a','z') (mkStdGen 3) :: [Char])
>                                                  == "ndkxbvmomg"

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 7H.

 ш1.2
                 23. 3 Генерация псевдослучайных чисел
                    3с помощью 0  3модулей Random и IO
    3Замечание 0 ( 1важное 0).
 ш1.1
   Для понимания  последующего изложения требуется иметь опыт в ра-
боте с монадой IO. Поэтому при первом чтении этот раздел можно про-
пустить!

 ш1.2
   До сих  пор  генераторы  случайных чисел конструировались "вруч-
ную" с помощью задаваемых программистом некоторого начального  зна-
чения (" 1затравки 0").  Если действовать так,  то функции всегда будут
возвращать одинаковые  последовательности   псевдослучайных   чисел
(строк и т.п.). Поэтому модуль System.Random содержит функции, поз-
воляющие автоматически генерировать генераторы случайности.
    21. 0 Вначале рассмотрим  _ 1действие ввода-вывода
 ш1.0

    2getStdGen 0 :: IO StdGen.

 ш1.2
   При вызове  функции  у системы запрашивается некоторый генератор
случайных чисел, который затем сохраняется в специальном  _ 1глобальном
 _ 1генераторе . 0. Теперь  по  требованию  программиста  функция getStdGen
возвращает глобальный генератор.
    2Пример 0 ( 1функции, генерирующей случайную строку 0).
 ш1.0

> main1 = do
>           gen <- getStdGen
>           putStrLn $ take 20 (randomRs ('a','z') gen)

 ш1.1
   При этом  если дважды вызвать функцию getStdGen,  то система два
раза вернёт один и тот же генератор случайности и в результате  по-
лучатся одинаковые результаты.
   Например:
 ш1.0

> main2 = do
>           gen1 <- getStdGen
>           putStrLn $ take 20 (randomRs ('a','z') gen1)
>           gen2 <- getStdGen
>           putStr $ take 20 (randomRs ('a','z') gen2)

 ш1.2
    22. 0 Для реализации  _ 1автоматического . 0 выбора генератора  случайности
используется  1действие ввода-вывода 0  2newStdGen 0, которое разбивает те-
кущий глобальный генератор на два генератора. Далее,  1действие 0 заме-
щает глобальный  генератор  одним из результирующих генераторов,  а
второй генератор возвращает в качестве результата:
 ш1.0

> main3 = do
>           gen <- getStdGen
>           putStrLn $ take 20 (randomRs ('a','z') gen)
>           gen' <- newStdGen
>           putStrLn $ take 20 (randomRs ('a','z') gen')
>           gen'' <- getStdGen
>           putStrLn $ take 20 (randomRs ('a','z') gen'')

 ш1.2
   Более того,  мы не только получаем новый генератор, когда связы-
ваем с gen' значение, возвращённое функцией newStdGen, но и заменя-
ем глобальный генератор.  Так что,  если мы воспользуемся  функцией
getStdGen ещё раз и свяжем его с gen'',  то получим генератор,  от-
личный от генератора gen.
                3Работа с демонстрационными примерами
   См. Пример 8H.

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 1.
 ш1.0

 ш1.2

    2Пример 2.
 ш1.0

 ш1.2

    2Пример 3.
 ш1.0

 ш1.2

    2Пример 4.
 ш1.0

 ш1.2

    2Пример 5.
 ш1.0

 ш1.2

    2Пример 0  26 0 [Липовача,2012,с.257-259].
   Рассмотрим функцию,  которая  требует от пользователя угадывания
загаданного числа:
 ш1.0

> main4 :: IO ()
> main4 = do
>           gen <- getStdGen
>           askForNumber gen
> -------------------------------
> askForNumber :: StdGen -> IO ()
> askForNumber gen =
>      do
>        let (randNumber, newGen) = randomR (1,10) gen
>                                                  :: (Int, StdGen)
>        putStr "Я задумал число от 1 до 10. Какое? "
>        numberString <- getLine
>        when (not $ null numberString) $
>           do
>             let number = read numberString
>             if randNumber == number
>               then putStrLn "Правильно!"
>               else putStrLn $ "Извините, но правильный ответ "
>                               ++ show randNumber
>             askForNumber newGen

 ш1.2
   Здесь мы  создаём  функцию  askForNumber,  принимающую генератор
случайных чисел и возвращающую действие ввода-вывода, которое спро-
сит число у пользователя и сообщит ему, угадал ли он.
   В этой функции мы сначала генерируем случайное число и новый ге-
нератор, основываясь на исходном генераторе; случайное число мы на-
зываем randNumber, а новый генератор - newGen.
   Допустим, что было сгенерировано число 7.
   Затем мы предлагаем пользователю угадать, какое число мы задума-
ли. Вызываем функцию getLine и связываем её результат с идентифика-
тором numberString. Если пользователь введёт 7, то numberString бу-
дет равно 7.
   Далее мы используем функцию when для того,  чтобы проверить,  не
ввёл ли пользователь пустую строку:  если "да", то выполняется пус-
тое действие ввода-вывода  return(),  которое  закончит  выполнение
программы; если же ответ "нет",  то выполняется действие, состоящее
из блока do.  Мы вызываем функцию read со значением numberString  в
качестве параметра, чтобы преобразовать его в число; образец number
становится равным 7.
   Если пользователь  введёт  то,  что  функция read не сможет про-
честь, то функция "упадёт" с сообщением об ошибке.
   Если вы не хотите, чтобы функция "падала" на некорректном вводе,
используйте функцию reads:  она возвращает пустой  список,  если  у
функции не получилось считать строку.
   Если чтение прошло удачно,  то функция вернёт список  из  одного
элемента, содержащий пару, один компонент которой содержит желаемый
элемент;  второй компонент хранит остаток строки  после  считывания
первого.
   Мы проверяем, равняется ли number случайно сгенерированному чис-
лу, и выдаём пользователю соответствующее сообщение.
   Затем рекурсивно вызываем функцию askForNumber,  но на сей раз с
вновь полученным генератором; это возвращает такое же действие вво-
да-вывода,  как мы только что выполнили, но основанное на новом ге-
нераторе. Затем это действие выполняется.
   Функция main4 состоит из получения генератора случайных чисел от
системы  и вызова функции askForNumber с этим генератором для того,
чтобы получить первое действие.
   Посмотрим, как работает функция:
 ш1.0

   Я задумал число от 1 до 10. Какое?
   4
   Извините, но правильный ответ 3
   Я задумал число от 1 до 10. Какое?
   10
   Правильно!
   Я задумал число от 1 до 10. Какое?
   2
   Извините, но правильный ответ 4
   Я задумал число от 1 до 10. Какое?
   5
   259
   Извините, но правильный ответ 10
   Я задумал число от 1 до 10. Какое?

 ш1.2
   Можно написать эту же программу по-другому:
 ш1.0

> main5 :: IO ()
> main5 = do
>           gen <- getStdGen
>           let (randNumber, _) = randomR (1,10) gen
>                                                 :: (Int, StdGen)
>           putStr "Я задумал число от 1 до 10. Какое? "
>           numberString <- getLine
>           when (not $ null numberString) $
>             do
>               let number = read numberString
>               if randNumber == number
>                 then putStrLn "Правильно!"
>                 else putStrLn $ "Извините, но правильный ответ "
>                                 ++ show randNumber
>               newStdGen
>               main5

   Эта версия функции очень похожа на предыдущую,  но вместо созда-
ния функции,  которая принимает генератор и вызывает сама себя  ре-
курсивно с вновь полученным генератором, мы производим все действия
внутри функции main'.
   После того  как пользователь получит ответ,  угадал ли он число,
мы обновим глобальный генератор и снова вызовем функцию main'.
   Первый способ  предусматривает  меньше действий в функции main и
даёт функцию, которую можно легко использовать повторно.
 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                 1Не беспокойтесь ни о чём, если у вас есть смелость.
                   1А.Дюма. Виконт де Бражелон, или Десять лет спустя
 ш1.2

    20 5* 2. 0 Приведите возражения к следующему "обоснованию":
   "Кто сказал,  что компьютер неспособен получить случайное число?
   Практически любому студенту, овладевшему основами программирова-
ния,  не составит никакого труда написать свой генератор  случайных
чисел (заметим, что не псевдослучайных, а именно случайных!).
   Способов достаточно,  например,  можно  обратиться  к системному
времени.  В самом деле,  невозможно предсказать в какую именно долю
секунды  программе  требуется воспользоваться генератором случайных
чисел".
               21. 3 Генерация псевдослучайных равномерно
                  3распределённых 0  3натуральных чисел
    21. 0 Реализуйте метод середины квадрата Дж. фон Неймана.
    22. 0 Реализуйте метод генерации псевдослучайных целых чисел с  по-
мощью построения  1линейной конгруэнтной последовательности 0.
   Параметры метода выберите самостоятельно. Вычислите период.
    23 4* 2. 0 Реализуйте  на языке C следующий алгоритм генерации  псевдо-
случайных целых чисел:
 ш1.0

   var seed: Integer        (* Глобальная переменная *)
         7777
   { ------------------ }
   FUNCTION Random: Real;
      const a = 16807;
            m = 2147483647;
            q = 127773;     (* q = m div a *)
            r = 2836;       (* r = m mod a *)
      var lo,hi,test: Integer;
   BEGIN
      hi:=seed DIV q; lo:=seed MOD q; test:=a*lo-r*hi;
      If test>0
        then seed:=test
        else seed:=test+m;
      Random:=seed/m
   END;

 ш1.2
    24. 0 Напишите функцию,  генерирующую параметры  3m 0,  3a 0,  3c 0, x 40 0 для ли-
нейного конгруэнтного генератора.
               22. 3 Генерация псевдослучайных 0  3нормально
                        3распределённых чисел
    21. 0 Реализуйте  метод генерации нормально распределённого случай-
ного числа с помощью  1простейшего алгоритма 0.
    22. 0 Реализуйте  метод генерации нормально распределённого случай-
ного числа с помощью  1алгоритма Бокса-Мюллера 0.
    23. 0 Реализуйте  метод генерации нормально распределённого случай-
ного числа с помощью  1алгоритма Марсальи-Брея 0.
    24. 0 Реализуйте на языке C следующий алгоритм генерации псевдослу-
чайных вещественных чисел:
 ш1.0

   var seed : real            (* Глобальная переменная *)
        7777
   { ------------------ }
   FUNCTION Random: Real;
      const a = 16807.0;
            m = 2147483647.0;
            q = 127773.0;     (* q=m div a *)
            r = 2836.0;       (* r=m mod a *)
        var lo,hi,test: Real;
   BEGIN
      hi:=Trunc(seed/q); lo:=seed-q*hi; test:=a*lo-r*hi;
      If test>0.0
        then seed:=test
        else seed:=test+m;
      Random:=seed/m
   END;

 ш1.2
                       23. 3 Проверка генераторов
                           3случайных чисел
    21 4* 2. 0 Реализуйте алгоритм Брента проверки генератора случайных чи-
сел.
    22 4* 2. 0 Реализуйте критерий  7c 52 0 проверки генератора случайных чисел.
    23 4* 2. 0 Проверьте генератор равномерно распределённых случайных  би-
тов, который выдаёт следующие "подозрительные" последовательности:
 ш1.1

   (а) 1000101110111101000010001011101111010000...;
   (б) 1111111111111111111111111111111111111111...;
   (в) 0101010101010101010101010101010101010101....

 ш1.2
               24. 3 Использование собственной реализации
                 3линейного конгруэнтного генератора
    3Замечание 0.
 ш1.1
   В каждой  задаче необходимо воспользоваться  _ 1собственным . 0 линейным
конгруэнтным генератором (разумеется, с проверенными свойствами).

 ш1.2
                               _ 1Монеты
    21 4* 2. 0 Промоделируйте  процесс многократного подбрасывания монеты и
фиксации результата её падения на одну из сторон: лицевую ("решка")
или обратную ("орел").
    22 4* 2. 0 Вычислите частоту выпадения "орла" или "решки" при 100 и при
1000 "подбрасываниях" монеты.
                           _ 1Игральные кости
    23 4* 2. 0 Промоделируйте процесс многократного подбрасывания игральной
кости.  Результатом работы программы является случайное целое число
в диапазоне от 1 до 6.
    24 4* 2. 0 Промоделируйте процесс бросания игральной кости двумя  игро-
ками. Определите, кто из игроков получил больше очков.
    25 4* 2. 0 Промоделируйте процесс бросания каждым из двух игроков n иг-
ральных  костей.  Определите,  кто из игроков получил большую сумму
очков.
    26 4* 2. 0 С помощью компьютерного моделирования определите частоту вы-
падения каждого из натуральных чисел в диапазоне от 1 до  6  при  n
подбрасываниях игральной  кости;  значение параметра n определяется
случайным натуральным числом (n 7. 01).
                            _ 1Кости домино
    27 4* 2. 0 Промоделируйте выбор одной кости домино  из  полного  набора
костей (кость конструируется так: 0+0, 0+1,..., 6+6).
   Выведите значения "полей"  выбранной  кости  домино  (значениями
"полей являются случайные натуральные числа).
    28 4* 2. 0 Промоделируйте выбор двух костей домино  из  полного  набора
костей (кость конструируется так: 0+0, 0+1,..., 6+6).
   Выведите значения полей каждой из выбранных костей и определите,
можно ли "приставить" одну кость к другой в соответствии с правила-
ми игры в домино.
                           _ 1Игральные карты
    29 4* 2. 0 Промоделируйте выбор одной карты из  набора  игральных  карт
одной масти, включающего карты следующих достоинств: "6", "7", "8",
"9", "10", "валет", "дама", "король", "туз".
   При этом укажите достоинство выбранной игральной карты.
    210 4* 2. 0 Промоделируйте выбор одной карты из полного набора  играль-
ных карт,  включающего 4 масти ("пики", "трефы", "бубны", "черви"),
которые содержат карты 9 достоинств в каждой масти ("6",  "7", "8",
"9", "10", "валет", "дама", "король", "туз").
   При этом определите достоинство выбранной игральной карты  и  её
масть (например, "король пик").
                      25. 3 Дополнительные задачи
    21 5* 2. 0 Дан  1частотный словарь 0 для некоторого текста.  Постройте слу-
чайный текст, обладающий частотным словарём, "близким" к исходному.

    _ 1Домашнее задание . 0 (06.06.2014-13.06.2014):
 ш1.0

   №№ 21 41-4 0;  22 41-4 0;  23 41-3 0 ( 111 задач 0).

 ш1.2
    _ 1Дополнительные задачи . 0: №№ 23 41-10 0.
