    2ПРИЛОЖЕНИЕ 1.
    2ПОНЯТИЕ ОБ ОТЛАДКЕ И ТЕСТИРОВАНИИ

 ш1.0
              _ 1Определение .. Тестирование  -  это  процесс  нахождения
              1ошибок в тексте. Хороший тест должен содержать ошибки,
              1компенсирующие их нехватку в тестируемой программе. 0
                                            1В.Тихонов. Теория ошибок
 ш1.2

    _ 1Основные понятия . 0:
 ш1.0
    1- разработка программы и её основные этапы 0;
    1- типы ошибок  программирования 0:   1синтаксические,  семантические,
 1логические 0;
    1- шутливая классификация ошибок  программирования 0: 1  ошибка  Бора,
 1ошибка Гейзенберга, ошибка Мандельброта, ошибка Шрёдингера 0;
    1- отладка программ 0;
    1- тестирование программ 0;
    1- принципы тестирования 0;
    1- методы тестирования, их преимущества и недостатки 0;
    1- 0  1основной тест, вырожденный тест, тест граничных значений, ава-
 1рийный тест 0;
   -  1локализация ошибки 0;
    1- малая автоматизация тестирования 0;
    1- 0  1сопровождение "старых" кодов 0;
    1- 0  1об одном критерии качества 0  1документации.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
   В настоящее  время  обеспечение качества программ является одной
из наиболее актуальных задач в области применения компьютеров.
   Современное программное обеспечение -  это  сложнейший  продукт,
создаваемый большим коллективом специалистов на протяжении длитель-
ного времени. Сложность, большой объём, участие большого числа спе-
циалистов - это основные факторы,  из-за которых возникают ошибки в
процессе разработки программного обеспечения.
   Если ошибки своевременно не обнаружены,  то значительные ресурсы
тратятся на их исправление в ходе эксплуатации.
   Естественно, что  для  решения  поставленной  задачи  необходимо
иметь  _ 1внешнее . 0 ( 1по отношению к программе 0)  _ 1описание решаемой  задачи . 0,
содержащее  информацию о том,  какие функции должна выполнять прог-
рамма (какой она должна быть).
   Причём это описание в процессе подготовки задачи к решению с по-
мощью компьютера  1должно предшествовать 0 написанию программы.
   Такими внешними по отношению к программе описаниями решаемой за-
дачи являются:
 ш1.1
   (1)  _ 1техническое задание на программу . 0,  в котором содержатся тре-
бования к функционированию  программы:  ограничения  на  программу,
описания функций, которые должна реализовывать программа, входные и
выходные данные и т.д.  Информация,  необходимая для отладки, может
быть описана в техническом задании как в явном виде,  так и в неяв-
ном.  Во втором случае требуется анализ некоторых положений  техни-
ческого задания для того, чтобы выделить необходимую информацию;
   (2) описание  _ 1математической модели . 0 решаемой задачи,  которая яв-
ляется формализованным  описанием задачи.  В описании явно выделены
все исследуемые параметры, входные и выходные данные, процессы пре-
образования информации,  необходимые критерии оценки получаемых ре-
зультатов. Описаны взаимосвязи между различными величинами задачи;
   (3)  _ 1алгоритм решения задачи . 0, который описывает метод решения за-
дачи и фиксирует все процессы преобразования входных данных  в  вы-
ходные так, как это должно осуществляться в компьютере. В алгоритме
присутствуют наиболее важные переменные и константы, которые должны
быть  использованы  в  программе,  описаны соотношения между ними и
введены другие параметры, уточняющие математическую модель задачи;
   (4)  _ 1проект программы . 0, который является описанием алгоритма реше-
ния задачи в терминах,  близких к конструкциям языка программирова-
ния;
   (5)  _ 1данные . 0,  поставляемые заказчиком; они могут содержать допол-
нительные уточняющие сведения о решаемой задаче,  деталях техничес-
кого задания, функциях алгоритмов, программе.
   (6)  _ 1тесты . 0, подготовленные для проверки функционирования програм-
мы, в которых могут находиться специфические данные программы, кри-
тические значения переменных,  констант,  описание путей выполнения
программы, диапазоны изменения переменных, типы и структуры данных;
   (7)  _ 1собственное понимание программы самим разработчиком . 0.
   Это связано с тем, что, как правило, трудно полностью формализо-
вать задачу, решаемую с помощью компьютера.

 ш1.2
   В каждом  из  перечисленных внешних описаний решаемой задачи ин-
формация о том, какой должна быть отлаживаемая программа, содержит-
ся в виде, специфичном для этого описания.
   Кроме того,  часто процесс окончательной постановки  задачи,  её
более полного понимания происходит в ходе её решения,  например,  в
результате длительного общения разработчика с  заказчиком.  Поэтому
некоторые  особенности  программы  могут быть не формализованы и не
отражены ни в одном документе. Хранителем этих особенностей являет-
ся сам разработчик.
    1Процесс разработки программ 0 опишем с помощью следующей схемы:
 ш1.1
   (1) постановка задачи;
   (2) построение математической модели;
   (3) выбор и построение алгоритмов решения;
   (4) проектирование программы;
   (5) программирование;
   (6) автономная отладка;
   (7) комплексная отладка;
   (8) передача в эксплуатацию;
   (9) сопровождение.
 ш1.2

                       2Ошибки программирования

 ш1.0
                 1Если Вы думаете, что разработка и кодирование прог-
                 1раммы 0  1- вещь трудная, то Вы еще ничего не видели. 0
                                                  1Популярный афоризм
 ш1.2

    2Определение 0 [Майерс,1980,1982].
 ш1.1
   Будем говорить, что  _ 1в программе имеется ошибка . 0, если её выполне-
ние не оправдывает ожиданий пользователя.

 ш1.2
   Оказывается, что  практически  невозможно для достаточно сложной
программы быстро найти и устранить все имеющиеся в ней ошибки.
   Однако неопытный  программист,  как правило,  переоценивает свои
возможности и, разрабатывая программу, исходит из того, что в прог-
рамме  ошибок не будет.  А говоря про только что составленную прог-
рамму, готов уверять, что она на 99% правильна, и её остаётся толь-
ко  для  большей  уверенности  один  или  два (!) раза выполнить на
компьютере с какими-нибудь (!) исходными данными.  Естественно, что
каждый неверный результат, каждая найденная ошибка вызывают изумле-
ние и считаются, конечно, последними. Вследствие такого подхода по-
лучение надёжных результатов по составленной программе откладывает-
ся на длительный и неопределённый срок.
   Даже профессиональные разработчики иногда недооценивают реальный
уровень ошибок,  что приводит к сдвигу сроков завершения разработки
программ, увеличению реальных затрат ресурсов в 2-3 раза по сравне-
нию с первоначальными оценками.
   Трудности программирования подчеркивает следующий  популярный  в
среде  программистов  афоризм:  " 1В каждой программе есть по крайней
 1мере одна ошибка 0".
   Поэтому можно сказать,  что наличие ошибок в только что разрабо-
танной программе - вполне нормальное и закономерное явление. А сов-
сем из ряда вон выходящим фактом является отсутствие ошибок в прог-
рамме,  которая  не была ещё подвергнута тщательному тестированию и
отладке. Поэтому разумно уже при разработке программы на этапах ал-
горитмизации  и программирования готовиться к обнаружению ошибок на
стадии отладки и принимать профилактические меры для их  предупреж-
дения.  Более  того,  целесообразно  сосредоточить усилия на поиске
максимального числа ошибок на возможно более ранних стадиях  отлад-
ки, когда стоимость их обнаружения минимальна.
                   21. 0  3Типы ошибок программирования
    _ 1Ошибки . 0, которые  могут  быть  допущены  человеком  при написании
программы, можно разделить на три вида:
 ш1.1
   (1) 3  _ 1синтаксические ошибки . 0 возникают при вызове команды,  не вхо-
дящей  в систему команд конкретного языка программирования;  обычно
их обнаруживает   1транслятор 0  (компилятор или интерпретатор) данного
языка программирования;
   (2)  _ 1семантические ошибки . 0 возникают при вызове команды  в  ситуа-
ции, когда эта команда не может быть исполнена, эти ошибки приводят
к отказу транслятора;
   (3) 1  _логические ошибки . 0 возникают, если 1  0компьютер "выполнил" прог-
рамму,  но цель,  поставленная человеком, не достигнута. Эти ошибки
не фиксируются ни компьютером, ни компилятором.

 ш1.2
   Важно понимать,  что  "безотказное"  выполнение программы ещё не
означает её  _ 1правильность . 0.

                  22. 0  3Шутливая классификация ошибок
                          3программирования

 ш1.0
                 1Чтобы избегать ошибок, надо набираться опыта, чтобы
                 1набираться опыта, надо делать ошибки. 0
                                    1Принцип компетентности по Питеру
 ш1.2

   Приведём классификацию типов ошибок, названных в честь известных
учёных (Н.Бора,  В.Гейзенберга, Б.Мандельброта, Э.Шрёдингера) [Хэз-
филд,Кирби,2001,с.161-163].  Ошибки классифицированы скорее  по  их
симптомам, чем по причинам, их вызывающих.
    2А. 0  _ 1Ошибка Бора . 0 - ошибка, имеющая простую (возможно, неизвестную)
причину.  Если  причина  обнаружена и удалена или внесены изменения
нужным образом, то ошибка пропадает.
   Такие детерминистические ошибки проще всего найти и исправить.
   К счастью, большинство ошибок попадает именно в эту категорию.
   Например, оператор вывода с неверным текстом сообщения относится
к детерминистическим ошибкам.
   Ошибки Бора  -  это чаще всего простые ошибки логики приложений,
опечатки,  приводящие к правильному коду (например,  = вместо  ==),
случайно закомментированные части программы и т.п.
    2Б. 0  _ 1Ошибка Гейзенберга . 0 ( 1Гейзенбаг 0) - это прекрасное название  для
рассматриваемого класса ошибок. Каламбур удачен, т.к. принцип неоп-
ределённости Гейзенберга (вольно  пересказанный)  звучит  приблизи-
тельно так:   1нельзя наблюдать явление, не изменив его 0. Эта ситуация
характерна для квантовой физики, но для программистов является нас-
тоящим кошмаром. Опишем этот тип ошибок.
   Ваша программа не работает; хорошо, используем отладчик.
   Вы знаете,  что  она не работает,  поэтому аккуратно работаете в
пошаговом режиме. Она работает. Отлично! Вы вновь запускаете её вне
отладчика.  Она не работает. Вы опять прогоняете её под отладчиком,
но уже без пошагового режима. Она работает. Ага! Она работает толь-
ко тогда, когда вы пытаетесь выследить ошибку.
   Возникают два естественных вопроса:  "Почему это происходит"?  и
"Что я могу сделать?"
   Обычно ошибка Гейзенберга говорит о  недопустимом  использовании
памяти исполнителя программы:  либо какой-то указатель указывает не
на то, на что следует, либо неверен используемый индекс массива.
   Если мы  затрагиваем  не отведённую нам область памяти (неважно,
для чтения или для записи),  мы вызываем  неопределённое  поведение
программы.  Проблема с неопределённым поведением состоит в том, что
мы не можем определить его, поэтому не следует удивляться тому, что
"вытворяет" наша программа.
   Рассмотрим пример неинициализированного указателя:
 ш1.0

   char *p;

и результат действия такого оператора:

   strcpy(p,q);

 ш1.2
где q - некоторый допустимый указатель, указывающий на сравнительно
длинную  строку.  Компилятор  выделит  некоторую область памяти для
указателя p так же,  как он выделяет память для любой другой  пере-
менной. Содержимое, находящееся по адресу, на который указывает пе-
ременная p, может быть произвольным.
   Каковы теперь шансы на то, что p указывает на безопасную область
памяти? Возможно,  p указывает на безопасную область, а может быть,
и нет. Точно сказать нельзя.
   Ошибка Гейзенберга возникает,  если указатель p не указывает  на
безопасную область памяти, вызывая ошибку выполнения программы.
   Поэтому вы запускаете отладчик,  что приводит к перемещению дан-
ных  в памяти,  и в результате этого p начинает указывать на совер-
шенно безобидное место.
   Что же можно с этим поделать?  Первая линия обороны строится пу-
тём инициализации всех указателей в NULL при определении (это долж-
но стать привычкой). Если этого недостаточно, то приходит время ис-
пользовать отладчик или,  если программа работает в реальном режиме
времени, трассировочный код.
    2В. 0  _ 1Ошибки Мандельброта ..  0Некоторые ошибки кажутся совершенно слу-
чайными.  Лежащие  в  их  основе причины представляются непостижимо
сложными,  как легендарное множество Мандельброта, в честь которого
они и названы. Программа работает в течение только 70% времени (для
конкретных входных данных) или работает  только  вне  отладчика  (в
противоположность ошибки Гейзенберга), или выдаёт ложные результаты
в среду, или работает только на компьютере приятеля и т.п.
   Наиболее раздражающей является ошибка Мандельброта,  при которой
прекращается даже выполнение программы.  Это особенно расстраивает,
когда вы  знаете,  что  ваша программа прекрасно работает на другой
платформе.
   Когда оказываешься в такой ситуации, естественно, предполагаешь,
что какая-то часть программы работает правильно,  а в  чём-то  есть
ошибка. Поэтому можно начать с пустой функции main() и добавлять за
один раз определённую её часть,  проводя затем  проверку.  В  конце
концов,  мы внесём ошибку, из-за которой останавливается программа.
Это локализует ошибку.  Можно,  конечно, начать с полной программы,
убирая модули,  функции,  строки;  в  определённый момент программа
будет выполняться без ошибки неверного обращения к памяти, что так-
же  может помочь в решении проблемы.  Обе эти стратегии не содержат
риска до тех пор, пока у вас есть резервная копия программы.
   Когда мы обнаружим сегмент программы,  в котором, как нам кажет-
ся, находится ошибка, мы вернёмся к упорной детективной работе.
    2Г. 0 В  умозрительном эксперименте Э.Шрёдингера "Кот" гипотетичес-
кий кот помещается в закрытую коробку при обстоятельствах,  которые
приводят к удивительному выводу - кот оказывается живым и мёртвым в
одно и то же время. Заглянув в коробку, мы сводим две возможности к
одной определённости.  Э.Шрёдингер придумал этот умозрительный экс-
перимент для демонстрации того,  что он считал неотъемлемо присущим
квантовой теории.
    _ 1Ошибка Шрёдингера . 0 - это ошибка, находящаяся в состоянии спячки.
   Программа служит  в  течение  многих  лет.  Затем кто-то находит
ошибку, читая старый листинг исходного кода.  И в этот момент прог-
рамма  перестаёт  работать и начинает работать снова,  только когда
ошибка исправлена.  Сам факт нахождения ошибки превращает две  воз-
можности - есть ошибка или её нет - в твёрдую уверенность,  что она
есть.
   Звучит невероятно, не так ли? Но такие случаи существуют. Не так
просто найти рациональное объяснение этому:  либо ошибка находилась
в мало используемой части программы, либо влияла на вывод программы
несущественным образом; ошибка была в программе всё время, но никто
её не замечал.  Когда вы выявили ошибку в листинге и начали  искать
отклонения в поведении программы, вы найдёте их.
   Истинная ошибка Шрёдингера интересна,  но трудна в исследовании.
По определению,  вы знаете, где в коде присутствует ошибка, поэтому
вопрос заключается только в её использовании.

                          2Отладка программ
                         21. 3 Основные понятия
    2Определение 0.
 ш1.1
    _ 1Отладка программы . 0 - это один из этапов её решения,  во время ко-
торого  с  помощью  компьютера происходит обнаружение и исправление
ошибок, имеющихся в программе.
   В ходе  отладки программист добивается определённой степени уве-
ренности в том, что его программа соответствует своему назначению и
не делает того, для чего она не предназначена.

 ш1.2
   Составные части процесса отладки изобразим схематически в "форме
Бэкуса-Наура":
 ш1.0

   < 1Процесс отладки 0>::=< 1Процесс поиска ошибки 0> +
                       < 1Процесс исправления этой ошибки 0>

   < 1Процесс поиска ошибки 0>::=< 1Процесс тестирования 0> +
                             < 1Процесс локализации ошибки 0>

 ш1.2
   Итак,  1отладка 0 объясняет причину ошибки и исправляет её, а  1тести-
 1рование 0 устанавливает факт  наличия  ошибки;  при  этом  (см.  [Ма-
йерс,1982]) время,  которое необходимо для адекватного тестирования
программ,  составляет от 30-50% общего времени разработки программ-
ного проекта.
   Процесс  1отладки программ 0 сводится к следующей  схеме,  состоящей
из основных пяти шагов:
 ш1.1
   (1) формирование гипотезы о наличии в программе ошибок,  опреде-
ляемых критерием отладки;
   (2) формирование  на основе некоторого (отличного от самой прог-
раммы) представления данных,  описывающих функции,  которые  должна
выполнять программа;
   (3) формирование на основе самой программы  данных,  описывающих
функции, которые в действительности выполняет программа;
   (4) выполнение процесса сравнения этих двух типов данных,  полу-
ченных на втором и третьем шаге соответственно;
   (5) на основе результатов сравнения двух видов данных, выполнен-
ного на  шаге  (4),  формирование  выводов о наличии или отсутствии
ошибки в программе,  а в случае её наличия - о характере и местона-
хождении.

 ш1.2
   Естественно, что  для отладки необходимо иметь  _ 1внешнее . 0 ( 1по отно-
 1шению к программе 0)  _ 1описание решаемой задачи . 0,  содержащее информацию
о том, какие функции должна выполнять программа.
   Для  _ 1отладки программы . 0 обычно пользуются следующими приёмами:
 ш1.1
   (1) пошаговое выполнение программы;
   (2) просмотр значения любой переменной или выражения;
   (3) установка  1контрольных точек  0(точек, в которых программа вре-
менно останавливает свою работу для возможности оценки  промежуточ-
ных результатов).  При этом  _ 1контрольной печатью . 0 обычно называют вы-
вод промежуточных результатов на экран.

 ш1.2
    _ 1Контроль правильности программы . 0 состоит, как правило, из следую-
щих этапов:
 ш1.1
   1. 3  1Просмотр 0.  Текст программы просматривается на предмет обнару-
жения описок и расхождений с алгоритмом решения.  Просмотреть орга-
низацию циклов, убедиться в правильности команд, задающих количест-
во  повторений.  Просмотреть  логические  выражения  в конструкциях
ветвления и выбора, вызов процедур и функций.
   2. 3  1Проверка 0.  При проверке программы необходимо постараться мыс-
ленно восстановить вычислительный процесс, определяемый программой,
и сравнить его с требуемым процессом.
   3. 3  1Прокрутка 0.  Пошаговое выполнение программы вручную человеком.
   Для выполнения прокрутки необходимо  задать  исходные  данные  и
производить над ними необходимые вычисления. Исходные данные должны
подбираться так,  чтобы в прокрутку вовлекалось большинство  ветвей
алгоритма.
 ш1.2

                         22. 0  3Ручная прокрутка

 ш1.0
                     1Программисту не всегда нужна ЭВМ, иногда полез-
                     1нее удобное кресло и спокойная обстановка. 0
                                                     1А.Архангельский
 ш1.2

   Прокрутка является первым этапом в процессе поиска ошибок. Осно-
вой прокрутки является имитация программистом  процесса  выполнения
программы  (алгоритма) компьютером с целью более конкретного и наг-
лядного представления о процессе,  определяемом текстом проверяемой
программы. Прокрутка дает возможность приблизить последовательность
проверки программы к последовательности её выполнения, что позволя-
ет проверять программу как бы в динамике её работы,  проверять эле-
менты вычислительного процесса, задаваемого проверяемой программой,
а не только статичный текст программы.
   Ручную прокрутку (" 1walkthrough 0" -  " 1сквозной  контроль 0")  иногда
называют  "сухой"  прокруткой  (" 1dry running 0" - " 1пробный прогон 0") в
отличие от метода прокрутки, использующего компьютер.
   Для выполнения  прокрутки  обычно задают какие-то конкретные ис-
ходные данные и производят над ними необходимые вычисления, исполь-
зуя только текст программы.  Для программ со сложной логикой, в ко-
торых,  например,  характер работы одного участка программы зависит
от  результатов работы других ее участков,  необходимо осуществлять
ручную прокрутку программы для ряда специально подобранных исходных
данных и параметров.
   Трудность применения прокрутки - большой объём ручной работы при
попытке точного моделирования работы программы.  Поэтому успех при-
менения прокрутки заключается в выборе  такой  необходимой  степени
детализации моделирования,  чтобы,  с одной стороны, выявить макси-
мальное количество ошибок,  а с другой - затратить на это минималь-
ные усилия.
   Например, тело цикла можно прокрутить лишь для первых  двух-трёх
проходов  (проверка входа в цикл) и для последних одного-двух (про-
верка выхода из цикла).
   Использование прокрутки  весьма полезно потому,  что она содейс-
твует глубокому  осознанию  программистом  логики  составленной  им
программы и того реального вычислительного процесса, который ею за-
дается.
   Поговорим теперь о методике проведения ручной прокрутки.
   Нарисуйте на листе бумаги "начальную обстановку",  а затем, "ис-
полняйте"  операторы  программы  по одному,  отмечая все изменения,
происходящие при этом в запоминающем устройстве. Поэтому для ручной
прокрутки  нужно  уметь изображать на бумаге начальную обстановку в
оперативном запоминающем устройстве и происходящие в нём изменения.
   Удобнее всего рисовать блоки памяти и  их  содержимое  мелом  на
 1школьной доске 0:  ведь для того, чтобы поместить в блок новое содер-
жимое,  нужно "уничтожить" (стереть) старое - на доске это  сделать
очень просто.  Каждый блок можно рисовать в виде "домика", на "кры-
ше" которого записано имя блока,  а внутри размещается  содержимое.
Форма крыши может говорить о типе переменной.
   Если ручная  прокрутка  выполняется  на  1бумаге 0,  то таблицу имен
блоков приходится изображать по-другому,  потому что стирать старые
значения на бумаге неудобно,  лучше их зачеркивать,  а рядом писать
новые значения.

                     23. 0  3Метод контрольных тестов

 ш1.0
                 1Никогда не берите на корабль два хронометра, берите
                 1один или, если есть возможность, три, но не два. 0
                            1Наставление мореплавателям начала XIX в.
 ш1.2

   Как бы ни была тщательно проверена и "прокручена"  программа  за
столом, решающим этапом, устанавливающим её пригодность для работы,
является контроль программы по результатам выполнения на  компьюте-
ре. Поэтому рассмотрим универсальный метод контроля,  который назы-
вается  _ 1методом контрольных тестов . 0 (англ.   1test 0 -  1испытание 0,  1провер-
 1ка 0).  1Тестирование 0  - это важнейший этап в программировании и предс-
тавляет собой контроль программы по результатам  её  выполнения  на
системе  1тестов 0.
    2Определение 0 [Майерс,1982].
 ш1.1
    2(1) 0  _ 1Тестирование . 0 - это процесс исполнения программы на компьюте-
ре с целью  1обнаружения ошибок 0.
    2(2) 0  _ 1Тестом . 0 будем называть информацию, состоящую из исходных дан-
ных,  специально подобранных для отлаживаемой программы, и из соот-
ветствующих им эталонных результатов (не только окончательных, но и
промежуточных), используемых в дальнейшем для контроля правильности
работы программы.

 ш1.2
   Поясним это определение.
   Если поставить целью демонстрацию отсутствия ошибок,  то мы под-
сознательно будем стремиться к этой цели, выбирая текстовые данные,
на которых вероятность появления ошибки мала.  В то же время,  если
вашей  задачей станет обнаружение ошибок,  то создаваемый нами тест
будет обладать большей вероятностью обнаружения ошибки.  Такой под-
ход заметнее повысит качество программы.
    1Тестирование 0 - это процесс деструктивный (т.е.  обратный созида-
тельному,  конструктивному). Именно этим и объясняется, почему мно-
гие считают его трудным. Большинство людей склонно к конструктивно-
му  процессу созидания объектов и в меньшей степени - к деструктив-
ному процессу разделения на части.  Для усиления определения тести-
рования проанализируем два понятия - "удачный" и "неудачный".
   Большинство назовет тестовый прогон неудачным,  если  обнаружена
ошибка и, наоборот, удачным, если он прошел без ошибок.
   Из определения тестирования  следует  противоположное:  тестовый
прогон будет назван удачным, если в процессе его выполнения обнару-
жена ошибка, и, неудачным, если получен корректный результат.
   Вопрос о  позиции программиста по отношению к продукту его труда
связан, как это показано Вейнбергом,  с принципами безличного прог-
раммирования и когнитивного диссонанса.
    _ 1Когнитивный диссонанс . 0  1- 0 это психологический принцип, который ру-
ководит действиями человека, чьи представления о себе оказались под
угрозой. "Программист, который искренне считает программу продолже-
нием своего "я",  не будет пытаться найти все ошибки в ней.  Напро-
тив,  он постарается показать,  что программа правильна,  даже если
это  означает не замечать ошибок,  чудовищных для постороннего гла-
за... Человеческий глаз имеет почти безграничную способность не ви-
деть то, чего он видеть не желает".
   Спасти в такой ситуации может безличное программирование. Вместо
того,  чтобы  быть скрытным и защищать свою программу,  программист
занимает противоположную  позицию:  он  открыто  приглашает  других
программистов  читать а конструктивно критиковать её.  Когда кто-то
находит ошибку в его программе, программист, конечно, не должен ра-
доваться,  что ошибся;  его позиция примерно такова:  "О!  Мы нашли
ошибку в нашей программе! Хорошо, что мы нашли её сейчас, а не поз-
же! Поучимся на этой ошибке, а заодно посмотрим, не найдём ли ещё!"
   Программист, обнаруживший ошибку в чужой программе,  не  кричит:
"Посмотри  на  свою  идиотскую ошибку!",  а реагирует примерно так:
"Как любопытно! Интересно, не сделал ли и я такой ошибки в написан-
ном мною модуле?".
   При использовании метода  тестов   _ 1программа . 0  (или  отдельный  её
блок)   _ 1считается  правильной . 0,  если пропуск программы для выбранной
системы тестовых исходных данных дает правильные результаты.
   Таким образом,  контроль программы сводится к тому, чтобы подоб-
рать систему тестов,  получение правильных результатов для  которой
гарантировало бы правильную работу программы и для остальных исход-
ных данных на области, указанной в решаемой задаче.
   Для реализации метода контрольных тестов должны быть изготовлены
или заранее известны эталонные результаты,  на основании  сверки  с
которыми получаемых тестовых результатов, можно было бы сделать вы-
вод о правильности работы программы на данном тесте.
   Эталонные результаты  для  вычислительных  задач можно получить,
осуществляя вычисления вручную, применяя результаты, полученные ра-
нее  на другом компьютере или по другой программе,  или,  используя
известные факты, свойства, физические законы.
   Разрабатывая систему тестов,  нужно стремиться к тому, чтобы ус-
пешный пропуск ее на компьютере доказывал наличие ошибок в програм-
ме  (или  отдельном  её блоке),  хотя для многих достаточно сложных
программ,  особенно если над ними работает несколько программистов,
можно  практически  говорить лишь о большей или меньшей вероятности
правильности программы.  Это объясняется тем,  что  изготовление  и
пропуск всех тестов, необходимых для доказательства, может потребо-
вать такого объёма работ,  который затянет этап контроля на  многие
месяцы или годы. Поэтому при разработке системы тестов наряду с за-
дачей всестороннего и глубокого тестирования,  стоит задача миними-
зации количества необходимых тестовых результатов, машинного време-
ни и усилий программиста.
   В большинстве  случаев при использовании метода контрольных тес-
тов вопрос о доказательстве  отсутствия  ошибок  практически  можно
ставить лишь для небольших блоков (модулей) программы,  а для целой
программы приходится ограничиваться той или иной  вероятностью  от-
сутствия ошибок в программе.
   Неоднократно экспериментально установлено,  что в любой  сложной
программе в процессе эксплуатации обнаруживаются ошибки,  даже если
проведено самое тщательное  тестирование.  Тем  самым  утверждается
объективная реальность, заключающаяся в невозможности формализовать
и обеспечить абсолютную полноту всех эталонных  значений,  а  также
провести  всеобъемлющее  исчерпывающее тестирование и устранить все
ошибки в сложных программах.
   Опыт показывает, что до начала тестирования число ошибок в слож-
ных программах - порядка 1-2% от общего числа операторов в програм-
ме.  Самое тщательное тестирование сложных программ позволяет полу-
чить  программы  с   вероятностью   ошибки   в   каждом   операторе
0.0001-0.00001,  т.е. несколько ошибок может остаться. После завер-
шения тестирования программы в течение нескольких лет  эксплуатации
могут быть выявлены еще десятки ошибок.
   Перечислим  _ 1основные принципы тестирования . 0 [Майерс,1980].
   Эти принципы интересны тем,  что в основном они интуитивно ясны,
но в то же время на них часто не обращают должного внимания.
    2А. 0 Описание  предполагаемых значений выходных данных или резуль-
татов должно быть необходимой частью тестового набора.
   Нарушение этого  очевидного принципа представляет одну из наибо-
лее распространенных ошибок. Ошибочные, но правдоподобные результа-
ты  могут быть признаны правильными,  если результаты теста не были
заранее определены. Здесь мы сталкиваемся с явлением психологии: мы
видим то,  что хотим увидеть.  Другими словами, несмотря на то, что
тестирование по определению - деструктивный процесс, есть подсозна-
тельное желание видеть корректный результат. Один из способов борь-
бы с этим состоит в поощрении детального анализа выходных  перемен-
ных заранее, ещё при разработке текста.
    2Б. 0 Следует избегать тестирования программы её автором.
   Многие, кому приходилось самому делать дома ремонт,  знают,  что
процесс обрывания старых обоев (деструктивный процесс) нелегок,  но
он просто невыносим, если не кто-то другой, а вы сами первоначально
их наклеивали.  Вот так же и большинство программистов не может эф-
фективно  тестировать свои программы,  потому что им трудно демонс-
трировать собственные ошибки.
    2В. 0 Необходимо  досконально изучать результаты применения каждого
теста.
   Представляется достоверным,  что значительная часть всех обнару-
женных в конечном итоге ошибок могла быть выявлена в результате са-
мых первых тестовых прогонов,  но они были пропущены вследствие не-
достаточно тщательного анализа результатов первого тестового прого-
на.
    2Г. 0 Тесты для неправильных  и  непредусмотренных  входных  данных
следует  разрабатывать так же тщательно,  как для правильных и пре-
дусмотренных.
   Вполне вероятно, что тесты, представляющие неверные и неправиль-
ные входные данные,  обладают большей обнаруживающей  способностью,
чем тесты соответствующие корректным исходным данным.
    2Д. 0 Необходимо проверять не только,  делает ли программа то,  для
чего она предназначена, но и ни делает ли она то, что не должна де-
лать.
    2Е. 0 Не следует выбрасывать тесты,  даже если программа уже не ис-
пользуется.
   Обычно тестирующий сидит за терминалом, на лету придумывает тес-
ты и запускает программу на выполнение.  При такой  тактике  работы
после применения тесты пропадают. После внесения изменений или исп-
равления ошибок необходимо повторить тестирование, тогда приходится
заново  изобретать  тесты.  Как правило,  этого стараются избегать,
поскольку повторное создание тестов требует значительной работы.
    2Ж. 0 Нельзя планировать тестирование в предположении,  что  ошибки
не будут обнаружены.
    2З. 0 Вероятность наличия необнаруженых ошибок  в  части  программы
пропорциональна числу ошибок, уже обнаруженных в этой части.
   На первый взгляд,  этот принцип лишен смысла,  но тем  не  менее
подтверждается многими программами. Например, допустим, что некото-
рая программа состоит из модулей A и B. К определенному сроку в мо-
дуле А обнаружено пять ошибок,  а в модуле В - только одна,  причем
модуль А не подвергался более тщательному  тестированию.  Тогда  из
рассматриваемого  принципа следует,  что вероятность необнаруженных
ошибок в модуле А больше,  чем в  модуле  В.  Справедливость  этого
принципа подтверждается еще и тем,  что для ошибок свойственно рас-
полагаться в программе в виде неких скоплений,  хотя данное явление
пока еще никем не объяснено.
   Таким образом,  если в какой-нибудь части  программы  обнаружено
больше ошибок, чем в других, то на её тестирование должны быть нап-
равлены дополнительные усилия.
    2И. 0 Тестирование - процесс творческий.  Вполне вероятно,  что для
тестирования большой программы требуется больший творческий  потен-
циал, чем для ее проектирования.
   Чтобы подчеркнуть некоторые мысли,  высказанные в этом  разделе,
приведем еще раз три наиболее важных принципа тестирования.
    1Тестирование 0  1- 0 это процесс выполнения программ на  компьютере  с
целью обнаружения ошибок.  1Хорошим 0 считается тест, который имеет вы-
сокую вероятность обнаружения еще не выявленной ошибки.  1Удачным 0 яв-
ляется тест, который обнаруживает еще не выявленную ошибку.
                       24. 0  3Методы тестирования
   При  1неупорядоченном тестировании 0 (" 1smoke test 0" - " 1грубая провер-
 1ка работоспособности простым запуском 0",  " 1дымовой  тест 0")  исходные
данные,  имитирующие внешнюю среду,  случайным образом генерируются
во всем диапазоне возможного изменения параметров.  При этом многие
значения исходных данных характеризуются малой вероятностью обнару-
жения ошибок и не оправдывают затраты на  выполнение  тестирования.
Кроме того,  возможно появление логически противоречивых данных.  В
то же время данные, наиболее важные с позиции реального использова-
ния программ и возможностей обнаружения ошибок, могут оказаться не-
охваченными в процессе тестирования.
   Поэтому на  практике  последовательно применяют следующие методы
тестирования:  1статический 0,  1детерминированный 0 и  1стохастический 0.
    _ 1Статическое тестирование .  0(англ.   1static check 0) является наиболее
формализованным методом проверки корректности программ.  Тестирова-
ние проводится без исполнения программы путем  формального  анализа
текста  программы  на языке программирования.  Операторы и операнды
текста программ при этом анализируются в символьном  виде,  поэтому
такой метод называют также 1 символическим тестированием 0.
   Наиболее трудоемкими и детализирующими являются методы 1   _детерми-
 _ 1нированного  тестирования . 0.  При  таком  тестировании контролируется
каждая комбинация исходных эталонных данных  и  соответствующая  ей
комбинация эталонных результатов.  Разумеется, в сложных программах
невозможно перебрать все комбинации исходных данных и  проконтроли-
ровать результаты функционирования программы на каждой из них.
   В таких случаях применяется  _ 1стохастическое тестирование . 0, при ко-
тором  исходные тестовые данные задаются множеством случайных вели-
чин с соответствующими распределениями и для  сравнения  полученных
результатов  используются также распределения случайных величин.  В
результате при стохастическом тестировании возможно  более  широкое
варьирование  исходных данных,  хотя отдельные ошибки могут быть не
обнаружены,  если они мало искажают средние статистические значения
или распределения.
   Стохастическое тестирование применяется в основном для обнаруже-
ния ошибок, а для диагностики и локализации ошибок приходится пере-
ходить  к детерминированному тестированию с использованием конкрет-
ных значений параметров из области изменения использовавшихся  слу-
чайных величин.
   Рассмотрим некоторые 1 правила тестирования 0,  в  которых  делается
попытка  учесть как желательность доказательства правильности конт-
ролируемой программы,  так и ограниченность человеческих возможнос-
тей при проведении такого доказательства [Безбородов,1982].
    1Проход участков. 0  Каждый линейный участок программы должен  быть
обязательно пройден при выполнении,  по крайней мере, одного теста.
В том случае,  когда выполнение некоторого участка программы меняет
порядок выполнения или характер работы других участков,  может пот-
ребоваться перебор всех ветвей программы,  т.е. проход по всем воз-
можным путям выполнения программы.
    1Точность проверки. 0  Контроль арифметических блоков (как и других
блоков)  производится путем сверки результатов,  полученных при вы-
полнении блока,с эталонными результатами.  Для  арифметических  ре-
зультатов  дополнительная  сложность заключается в определении точ-
ности,  с которой необходимо сверять (и, тем самым, вычислять) эта-
лонные и тестовые результаты, с тем, чтобы можно было действительно
удостовериться в правильности работы блока.
    1Достоверность эталонов. 0  Нужно  обратить внимание и на достовер-
ность процесса получения эталонных результатов.  По возможности они
должны вычисляться не самим программистом,  а кем-то другим,  с тем
чтобы одни и те же ошибки в понимании задания не проникли и в прог-
рамму,  и  в эталонные результаты.  Если тесты готовит сам програм-
мист,  то эталоны нужно вычислять до получения на компьютере  соот-
ветствующих  результатов.  В противном случае имеется опасность не-
вольной подгонки вычисляемых значений под желаемые,  полученные ра-
нее на компьютере. В качестве эталонных результатов часто использу-
ют и данные, полученные при ручной прокрутке программы.
    1Планирование. 0 При   отсутствии  планового  подхода  тестирование
обычно сводится к тому,  что программист берет какие-то, можно ска-
зать, первые попавшиеся исходные данные и пропускает программу мно-
гократно,  исправляя ее при обнаружении ошибок  и  добиваясь  того,
чтобы получаемые результаты походили на желаемые.
   Ясно, что при этом контролируется только некоторая часть  блоков
и  операторов,  а  остальные  выполняются в первый раз уже во время
счета, и будут ли при этом найдены ошибки, имеющиеся в них, зависит
только от случая.
   При плановом подходе программа проверяется последовательно  блок
за блоком, причем если программа состоит из центрального блока, ко-
торый проводит обращения к периферийным блокам, мало связанным друг
с другом, то возможны следующие два основных подхода к контролю та-
кой программы,  два основных направления тестирования: от периферии
к центру (восходящее тестирование) или, наоборот, от центра к пери-
ферии (нисходящее тестирование).
   При первом, восходящем способе, применяемом обычно для небольших
программ,  сначала тестируют отдельные периферийные блоки,  а затем
переходят  к тестированию центральной части,  которая,  разумеется,
взаимодействует только с уже отлаженными блоками.
   При нисходящем тестировании, используемом для достаточно больших
программ,  параллельно с контролем периферийных блоков (или даже до
начала их контроля) производится и контроль центрального блока, вы-
полняемого на компьютере совместно с имитаторами периферийных  бло-
ков,  называемых "заглушками". В задачу имитаторов входит моделиро-
вание работы соответствующих блоков с целью поддержать функциониро-
вание  центрального блока.  Обычно "заглушки" выдают простейший ре-
зультат,  например константу и сообщение о факте своего  участия  в
работе. Вместо постоянной величины на более поздней стадии тестиро-
вания может выдаваться и случайная величина в требуемом диапазоне.
   К сожалению часто неверно понимают функции, выполняемые "заглуш-
ками".  Так  порой можно услышать,  что "заглушка" должна выполнять
лишь запись сообщения, устанавливающего: "Модуль подключился".
   В большинстве  случаев эти утверждения ошибочны.  Когда модуль А
вызывает модуль В,  А предполагает,  что В выполняет некую  работу,
т.е.  модуль А получает результаты работы модуля В. Когда же модуль
В просто возвращает управление или выдпет некое сообщение без пере-
дачи  в  А определенных осмысленных результатов,  модуль А работает
неверно не вследствие ошибок в самом модуле, а из-за несоответствия
ему модуля - "заглушки". Более того, результат может оказаться неу-
довлетворительным, если "ответ" модуля-"заглушки" не меняется в за-
висимости от условий теста.  Если "заглушка" всегда возвращает один
и тот же фиксированный результат вместо конкретного значения, пред-
полагаемого вызывающим модулем именно в этом вызове,  то вызывающий
модуль срабатывает как ошибочный (например,  зациклится) или выдаст
неверное выходное значение. Следовательно, создание модулей-"заглу-
шек" - задача нетривиальная.
   Преимуществом ранней  отладки  центрального блока при нисходящем
тестировании является  то,  что  программист  получает  возможность
быстро проверить периферийные блоки в условиях, которые в необходи-
мой степени приближены к реальным. Действительно, центральный блок,
снабженный  хотя  бы  и  простейшими функциональными возможностями,
можно рассматривать как реальную среду, в которую "погружаются" от-
лаживаемые блоки, добавляемые к центральной части. Добавление отла-
живаемых блоков удобно производить по одному для быстрейшего  поика
ошибок,  возникающих при стыковке с центральным блоком. Подключение
каждого нового блока к центральной части позволяет  постепенно  ус-
ложнять испытания, которым подвергается тестируемая программа.
   Строгой, корректной  процедуры подключения очередного последова-
тельно тестируемого модуля не существует. Единственное правило, ко-
торым следует руководствоваться при выборе очередного модуля,  сос-
тоит в том, что им должен быть один из модулей, вызываемых модулем,
предварительно прошедшим тестирование.
   Следует помнить,  что даже если изменения вносятся только в одну
подпрограмму, то повторному тестированию подлежит вся система. Этот
процесс называется   1тестированием  с  возвратом. 0  Проверять  работу
только  измененной  подпрограммы недостаточно!  Недостаточно полное
тестирование такого рода повышает вероятность неудач.
   Проведём сравнение нисходящего и восходящего тестирования,  при-
веденное в [Майерс,1980].
    _ 1Преимущества нисходящего тестирования . 0.
 ш1.1
    21. 0 Имеет преимущества, если ошибки, главным образом, в "верхней"
части программы.
    22. 0 Раннее формирование структуры программы позволяет провести ее
демонстрацию пользователю и служит моральным стимулом.

 ш1.2
    _ 1Недостатки нисходящего тестирования . 0.
 ш1.1
    21. 0 Необходимо  разрабатывать  модули-"заглушки" ,  которые часто
оказываются сложнее, чем кажется в начале.
    22. 0 Может  оказаться трудным или невозможным создать тестовые ус-
ловия.
    23. 0 Сложнее оценка результатов тестирования.
    24. 0 Стимулируется незавершение тестирования некоторых модулей.

 ш1.2
    _ 1Преимущества восходящего 0  1тестирования . 0.
 ш1.1
    21. 0 Имеет  преимущества,  если  ошибки,  главным образом в модуле
нижнего уровня.
    22. 0 Легче создавать тестовые примеры.
    23. 0 Проще оценка результатов.

 ш1.2
    _ 1Недостатки восходящего тестирования . 0.
 ш1.1
   Программа как единое целое не существует до тех пор, пока не до-
бавлен последний модуль.

 ш1.2
   Значительное повышение корректности и надёжности программ дости-
гается применением  _ 1двойного . 0 ( 1N- _кратного . 0)  _ 1программирования . 0 (от англ.
 1duplication check 0 -  1двойной пересчёт 0,  1двойная проверка 0).
   При этом  методе  при разных алгоритмах и на разных языках прог-
раммирования создается несколько вариантов программы.  Эти варианты
реализуют  одни  и те же функции и при определенных тестовых данных
должны выдавать тождественные результаты.  Различие результатов при
тестировании указывает на наличие ошибок по крайней мере в одном из
вариантов.  Обычно при разработке вариантов программы  используется
один  и  тот же алгоритм,  но программы создаются на разных языках,
разных компьютерах и разными программистами.
   На практике  применяется  программирование  с  N 7, 02.  Практически
очень редки случаи,  когда реальная программа создавалась в трёх  и
более вариантах.
                           25. 0  3Типы тестов
    _ 1Основным тестом . 0 будем называть тест,  проверяющий основные функ-
циональные возможности программы.  Однако существует опасность, что
после успешного  окончания  основного  тестирования  "на  радостях"
обычно  забывают  о  необходимости  дальнейшего,  более тщательного
контроля программы и отдельных е 1ё 0 участков, да и настроиться на та-
кой  контроль становится уже психологически трудно.  Поэтому помимо
основного теста необходимо применить следующие типы тестов.
    _ 1Вырожденный тест . 0 - это тест,  который затрагивает работу отлажи-
ваемой программы в самой минимальной степени.  Обычно  тест  служит
для проверки правильности выполнения самых внешних функций програм-
мы, например обращения к ней и выхода из неё.
    _ 1Тест граничных значений . 0 ( _ 1стрессовый тест . 0) (от англ.  1high-low bi-
 1as cheking 0,   1twin check 0) - это тест, который проверяет работу прог-
раммы для граничных значений параметров,  определяющих вычислитель-
ный процесс. Часто для граничных значений параметра работа програм-
мы носит особый характер, который тем самым требует и особого конт-
роля.
   Итак, перечислим  _ 1этапы тестирования . 0:
 ш1.1
   (1) проверка  _ 1нормальных условий . 0, заключающаяся в тестировании на
основе данных,  характерных для реальных  условий  функционирования
программы;
   (2) проверка  _ 1экстремальных условий . 0. Тестовые данные включают гра-
ничные  значения  области  изменения  исходных переменных,  которые
должны восприниматься программой как правильные  данные.  Типичными
примерами могут  служить  "очень маленькие" и "очень большие" числа
или отсутствие входных данных;
   (3) проверка  _ 1исключительных ситуаций . 0. Проводится с использовани-
ем данных,  значения которых лежат за пределами допустимой  области
изменения.

 ш1.2
   Например, если в качестве примера рассмотреть тестирование подп-
рограммы сортировки, то нужно исследовать следующие ситуации:
 ш1.1
   (а) сортируемый массив пуст;
   (б) сортируемый массив содержит только один элемент;
   (в) все элементы в сортируемом массиве одинаковы;
   (г) массив уже отсортирован.

 ш1.2
    _ 1Аварийный тест . 0 - это тест,  который проверяет реакцию  программы
на  возникновение  разного  рода аварийных ситуаций в программе,  в
частности вызванных неправильными исходными данными, то есть прове-
ряется диагностика, выдаваемая программой, а также окончание её ра-
боты или,  может быть, попытка исправления неверных исходных данных
(разработчики реальных программ знают, что пользователи подобны ре-
бёнку,  играющему в отсутствие старших с телевизором или магнитофо-
ном).
   Поэтому в реальных программах,  спроектированных  с  достаточной
надежностью,  совокупности приказов, которые должны работать только
в особых аварийных ситуациях,  занимают порой более 90% общего объ-
ема  программы.  Эти  совокупности приказов называют иногда блоками
" 1защиты от дурака 0" (от англ.   1fool proof 0).  Такие системы,  обладая
достаточной надёжностью, устойчиво функционируют даже при самых не-
подходящих действиях работающих с ними людей.
   Фирмы, занятые разработкой программного обеспечения,  специально
нанимают профессионально неподготовленных людей,  чтобы они порабо-
тали с вновь созданными программами. В их задачу входит за короткое
время сделать столько неправильных обращений к  программе,  сколько
пользователь не сделает и за долгий период.
   Наконец, перечислим  _ 1правила тестирования . 0 для начинающих програм-
мистов:
 ш1.1
   (1) набор  тестов должен быть приготовлен  1заранее 0 вместе с соот-
ветствующими эталонными результатами;
   (2) тесты должны быть целенаправленными и систематизированными;
   (3) первый тест должен быть максимально прост;
   (4) усложнение тестовых данных должно быть постепенное.
   (5) очередной  тест  должен  контролировать то,  что ещё не было
проверено на предыдущих тестах;
   (6) должна быть испытана каждая "ветвь" программы.

 ш1.2
    2Пример 0.
 ш1.1
   Составим систему тестов для задачи нахождения корней квадратного
уравнения ax 52 0+bx+c=0:
 ш1.0

   (1) a=1, b=1, c=-2.   Хороший начальный тест.
   (2) a=1, b=0, c=0.25. Проверка в нормальных условиях.
   (3) a=0, b=0, c=0.    Что произойдет?
   (4) a=0, b=2, c=1.    Должен быть один корень.
   (5) a=2, b=1, c=0.    Все должно быть в порядке.
   (6) a=1, b=1, c=1.    Вещественных корней нет.
   (7) a=0, b=0, c=2.    Неправильное уравнение.
   (8) a=0, b=2, c=0.    Должен быть один корень.
   (9) a=2, b=0, c=0.    Должно быть два одинаковых корня.
   (10) a=1, b=0, c=4.   Должно быть два одинаковых корня.

 ш1.2
                   26. 0  3Принципы 0  3локализации ошибок
   После того как установлено,  что в программе или в конкретном её
блоке имеется ошибка,  возникает задача её 1 локализации 0,  т.е. уста-
новления точного места в программе, где она находится.
   Можно считать,  что процесс локализации ошибок состоит  из  трёх
основных компонентов:
 ш1.1
   (1) получение вручную или с помощью компьютера тестовых  резуль-
татов;
   (2) анализ тестовых результатов и сверка их с эталонными;
   (3) выявление  ошибки или формулировка предположения о характере
и месте ошибки в программе. Если ошибка найдена, то производится ее
исправление;  в противном случае осуществляется переход к пункту 1,
т.е. к получению дополнительных тестовых результатов.

 ш1.2
   В ходе  поиска  ошибок  программист,  анализируя  полученные  на
компьютере результаты, проверяет различные предположения о характе-
ре и месте ошибки в программе,  которые при этом приходят ему в го-
лову.  В случае несоответствия этих гипотез  выданным  результатам,
программист выдвигает новые гипотезы и проверяет их или в уме,  или
проводя вычисления за столом,  или обращаясь за новыми результатами
к компьютеру.
   В таком характере работы программиста можно найти нечто общее  с
расчётом  вариантов,  который осуществляет шахматист во время игры,
когла он путем расчётов в уме ищет выигрывающий ход  в  позиции  на
шахматной доске,  подвергая проверке один из заслуживающих внимания
ходов за другим.  Не найдя выигрывающего хода, шахматист делает ка-
кой-то, по его мнению, хороший ход, приближающий его к цели.
   Так и программист, не найдя ошибки путём исследования полученных
тестовых результатов,  делает новое предположение о месте или о ха-
рактере ошибки,  вставляет новую  отладочную  печать  или  изменяет
программу ("ход  программиста"),  а компьютер выдает новые тестовые
результаты ("ход компьютера"). Итак, компьютер выступает в качестве
партнёра, задача которого заключается в том, чтобы вскрыть ошибки в
рассуждениях программиста,  сформулированных им в тексте отлаживае-
мой программы. Продолжая аналогию, можно сказать, что подобно тому,
как нельзя реально надеяться выиграть партию в два-три хода, так же
нельзя найти все ошибки в реальной программе за несколько обращений
к компьютеру.
   Программистов, успешно проводящих поиск ошибок в программе, мож-
но условно разделить на  1аналитиков 0 и  1экспериментаторов 0.
   Аналитики отлаживают программу, редко используя компьютер и при-
меняя простейшие способы получения тестовых результатов путём  тща-
тельного изучения этих результатов и на основании чёткого представ-
ления о структуре и особенностях отлаживаемой программы.
   Экспериментаторы ищут ошибки,  изощрённо используя  всевозможные
отладочные  средства,  быстро получая необходимые для все большей и
большей локализации ошибок промежуточные результаты и легко  ориен-
тируясь в них.
    1Идеальным является  случай,  когда  программист  сочетает в себе
 1способность к глубокому расчёту в уме  различных  вариантов  работы
 1программы и навыки работы с разнообразными отладочными средствами 0.
   Если успех аналитического подхода к поиску ошибок зависит, види-
мо, от способностей и опыта программиста, то изучение и использова-
ние  средств,  помогающих  локализации  ошибок  -  главным  образом
средств получения необходимых промежуточных результатов, - доступно
каждому программисту.
   Приведём следующие принципы  1Г.Майерса 0 [1982].
 ш1.1
   1. Думайте!  Наиболее  эффективный  метод  отладки заключается в
глубоком анализе информации об ошибках.  Для ее эффективного прове-
дения  специалист  должен  обладать  способностью  точно определять
большинство ошибок без использования компьютера.
   2. Используйте средства отладки только как вспомогательные.
   Не применяйте эти средства вместо того, чтобы обдумывать задачу.
   Эксперименты показали,  что программисты,  избегающие применения
средств отладки, даже при отлаживании незнакомых им программ выпол-
няют её лучше, чем те, кто пользуется этими средствами.
   3. Избегайте экспериментирования. Пользуйтесь им только как пос-
ледним средством. Наиболее общей ошибкой, которую допускают начина-
ющие программисты,  занимающиеся отладкой,  является попытка решить
задачу посредством внесения в программу экспериментальных изменений
("Я не знаю,  где ошибка, но я изменю этот оператор и посмотрю, что
получится"). Экспериментирование  не  только  уменьшает вероятность
успеха, но часто и усложняет задачу, поскольку при этом в программу
вносятся новые ошибки.
   4. Если вы зашли в тупик,  отложите рассмотрение программы. Наше
подсознание является мощным механизмом решения проблем.  То, что мы
часто приписываем вдохновению,  оказывается всего лишь  выполненной
подсознанием работой по решению задачи, тогда как наша сознательная
деятельность в это время связана с чем-нибудь другим.
   Если вы  не можете локализовать ошибку в приемлемые сроки (пред-
положительно за 30 минут для небольших программ и за несколько  ча-
сов для больших), прекратите поиски и займитесь каким-нибудь другим
делом, так как эффективность работы значительно снизится.
   Проблему следует " забыть" до тех пор, пока вы подсознательно не
найдете её решения,  либо отдохнете и будете готовы вновь  рассмот-
реть симптомы ошибки.
   Наконец, если вы окончательно зашли в тупик,  то изложите задачу
кому-нибудь ещё. Сделав это, вы, вероятно, обнаружите что-то новое.
   Часто случается так,  что просто пересказав задачу хорошему слу-
шателю, вы вдруг найдёте решение даже без помощи с его стороны.
 ш1.2

                   27. 0  3Принципы исправления ошибок

 2   0ш1.0
           1Вы должны радоваться, что мост разрушился, - я планировал
           1построить еще тринадцать по тому же проэкту. 0
                1Замечание, приписываемое Х.Брюнелю, адресованное ди-
                1рекции Большой западной железной дороги 0
 ш1.2

   Перечислим  1принципы исправления ошибок 0 по  1Г.Майерсу 0 [1982].
   1. Там, где есть одна ошибка, вероятно есть и другие.
   Другими словами, ошибки имеют тенденцию группироваться. При исп-
равлении  ошибки  проверьте  её непосредственное окружение:  нет ли
здесь каких-нибудь подозрительных симптомов.
   2.  1Находите ошибку, 0  1а не её симптом. 0 Плохо, если вследствии это-
го вы устраненяете симптомы ошибки, а не её саму. Если предполагае-
мое  изменение  устраняет  не все симптомы ошибки,  то она не может
быть полностью выявлена.
   3.  1Вероятность правильного нохождения ошибки не равна 100%.
   Никогда нельзя предполагать,  что текст, который включен в прог-
рамму для исправления ошибки,  правилен. С этим, безусловно, согла-
шаются,  а в процессе исправления ошибки часто наблюдается иная ре-
акция  (например,  "да,  в большинстве случаев это справедливо,  но
данная корректировка столь незначительна, что она правильна").
   Можно утверждать, что корректировки более склонны к ошибкам, чем
исходный текст программы. Подразумевается, что корректирующая прог-
рамма должна тестироваться, возможно, даже более тщательно, чем ис-
ходная.
   4.  1Вероятность  правильного нахождения ошибки уменьшается с уве-
 1личением объёма программы.
   Это утверждение формулируется по-разному. Эксперименты показали,
что отношение числа неправильно найденных ошибок к  числу  первона-
чально  выявленных  увеличивается  для больших программ.  В большой
программе,  рассчитанной на широкое применение, каждая шестая вновь
обнаруженная ошибка может быть допущена при предшествующем внесении
изменений в программу.
   5.  1Остерегайтесь внесения новой ошибки при корректировке.
   Необходимо рассматривать не только неверные корректировки,  но и
те,  которые  кажутся верными,  однако имеют нежелательный побочный
эффект и таким образом приводят к новым ошибкам.
   Подобные ошибки называются  _ 1наведёнными ошибками . 0.
   Другими словами,  существует  вероятность  не  только того,  что
ошибка будет обнаружена неверно, но и того, что её исправление при-
ведет к наведённой ошибке.  Поэтому после проведения  корректировки
должно  быть выполнено повторное тестирование,  позволяющее устано-
вить, не внесена ли новая ошибка.

                 28. 0  3Малая автоматизация тестирования

 2   0ш1.0
                                1Программа, свободная от ошибок, есть
                                1абстрактное теоретическое понятие.
                                                        1Д.Ван Тассел
 ш1.2

   Итак, вы разработали алгоритм, написали программу, и она уже вы-
даёт правильные ответы на нескольких  подготовленных  вами  тестах.
Если всё-таки  появятся  тесты,  на которых она перестанет работать
правильно, то придётся вносить изменения в программу,  добиваясь её
правильной работы  и  на этих тестах.  Но ведь после изменения кода
нужно опять всё перепроверять.
   Предлагается поступить  следующим образом [Долинский,2005,с.85]:
сразу после того,  как вы написали программу и приступили к её тес-
тированию (а ещё лучше -  1до того 0),  составить тесты и разместить их
в файлах 1.in, 2.in, 3.in и т.д., 1.out, 2.out, 3.out и т.д.
   Причём в  файлы  *.in  должно  попадать то,  что нужно вводить в
программу в тесте с соответствующим номером, а в файлы *.out - дан-
ные, которые программа должна выводить в случае правильной работы.
   После этого составляются два пакетных файла
 ш1.0

   1. All.bat

   @echo off
   cls
   for %%i in (1,2) do call test.bat %%i

   2. Test.bat

   @echo off
   2-02.exe <%1.in >output.txt
   fc output.txt %1.out
   pause

 ш1.2
   В файле All.bat в скобках указываются номера тестов,  которые Вы
подготовили. Он циклически запускает для всех этих номеров пакетный
файл Test.bat (передавая ему в качестве параметра номер теста).
   Файл Test.bat  запускает  разработанную  вами  программу  (здесь
2-02.exe) и перенаправляет ей ввод и вывод (предполагается,  что по
умолчанию она вводила с клавиатуры и выводила на экран). При этом в
качестве входного подаётся подготовленный вами очередной тест,  а в
качестве выходного - для сохранения вывода вашей программы  -  файл
output.txt.
   Его содержимое потом сверяется с подготовленными вами эталонными
ответами утилитой  DOS fc (от англ.   1File Compare 0),  которая должна
быть практически на любом персональном компьютере.
   Пользуясь запуском All.bat,  в любой момент после очередной пос-
ледовательности изменений можно убедиться,  что программа  работает
на  всех  подготовленных  вами тестах,  или быстро обнаружить те из
них, на которых она  1ещё 0 или  1уже 0 не работает.
    3Замечание 0.
 ш1.1
   Есть по существу две вещи,  которые нужно автоматизировать и ко-
торые, по существу,  никто больше не автоматизировал,  но они самые
трудные:
   (а) генерация   _ 1контрольных примеров . 0 (англ.   1test cases 0),  потому
что их нужно как-то создавать,  а их может быть тысячи, десятки ты-
сяч, сотни тысяч;
   (б) проблема прогона этих десятков тысяч  тестов,  когда  кто-то
должен решать для каждого из них,  пройден он или нет,  и эта также
нужно автоматизировать с помощью  _ 1оракулов тестирования . 0 (англ.   1test
 1oracles 0).
 ш1.2

                      2Дополнительная информация
                   21. 0  3Сопровождение "старых" кодов
   Сопровождение "старых"  кодов  может  оказаться сложной задачей.
Если у вас есть исходные тексты, то это - всегда преимущество.
   Вы не слишком преуспеете в исправлении старого  кода,  если  для
этого у вас нет нужных средств. Решение таких проблем требует изоб-
ретательности и большого внимания.  Но вы можете сделать так, чтобы
ваша программа,  сейчас совершенно новая,  через какое-то время  не
создавала сложностей при её сопровождении.
   Как сделать так,  чтобы сопровождающий вашу программу специалист
и через десять лет не проклинал вас?
   Убедитесь, что  следующие вещи надёжно сохранены и при необходи-
мости будут доступны такому специалисту [Хэзфилд,Кирби,2001,с.163]:
 ш1.1
   (1)  1компьютер 0, работающий под управлением  1операционной системы 0;
   (2)  1компилятор 0, используемый первоначально (имейте доступ к ста-
рым компиляторам);
   (3) список  1опций 0 этого компилятора и его используемых ключей;
   (4)  1исходный код 0 вместе с заголовочными файлами;
   (5) вся доступная  1документация 0;
   (6)  1тестовые сценарии 0,  условия,  данные,  а также ожидаемые  1ре-
 1зультаты тестов 0.

 ш1.2
                    22. 0  3Об одном критерии качества
                            3документации
   Рассмотрим одну любопытную точку зрения ( 1метафору 0)  на  програм-
мный проект [Дзержински,1980].  Суть её в том, что любая документа-
ция оказывалась бы ненужной, если бы можно было сопровождать каждую
поставку программы её автором.  Иными словами, идеальная документа-
ция - это разработчик программного продукта;  он в состоянии давать
адресные и самые квалифицированные консультации,  конструктивно от-
вечать на вопросы пользователей.
   Таким образом,  в этой точке зрения отражён взгляд на документа-
цию как на заместителя разработчика при используемой программе.
   Отсюда следует и  _ 1критерий качества документации . 0:  она тем лучше,
чем точнее  имитирует непосредственное взаимодействие разработчиков
с пользователями.
   Взгляд на документацию как на заместителя разработчика позволяет
сделать явным разграничение между видами документов для разных  ва-
риантов использования:  в разных ситуациях требуются различные кон-
сультации и разъяснения.

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                      1Какую бы программу Вы ни писали, любая ошибка,
                      1которая может в неё вкрасться, - вкрадется.
                                   1Следствие первого закона Чизхолма
 ш1.2

                    21. 0  3Ручная прокрутка программ
    21. 0 Осуществите ручную прокрутку программы:
 ш1.0

   begin
      If b>c
        then h:=b else h:=c;
      If a<h
        then t:=a else t:=h;
      If a*a>b*b
        then z:=a*a else z:=b*b;
      n:=z-t; WriteLn(n)
   end.

при следующих исходных данных:

   (а) a=5, b=-2, c=0.4;  (б) a=1, b=0, c=0.

 ш1.2
    22. 0 Напишите программу,  которая  определяет  количество  гласных
букв в заданном слове ( _ 1словом . 0 назовём цепочку букв латинского алфа-
вита).  Осуществите ручную прокрутку программы при следующих исход-
ных данных:
 ш1.0

   (а) hklmnprstfg; (б) aabbcuuwyqoozp; (в) uyo.

 ш1.2
    23. 0 Осуществите ручную прокрутку программы:
 ш1.0

   For i:=1 to length(s) do
     If s[i]='('
       then h:=h+1
       else k:=k+1;
   If k=h
     then WriteLn('да ')
     else WriteLn('нет')

 ш1.2
при следующих исходных данных: (а) ((()); (б) (()()(().
                           22. 3 Тестирование
    21. 0 [Майерс,1982]
   Составьте тесты  для программы,  которая по трём заданным числам
печатает сообщение о том,  является ли  треугольник  со  сторонами,
длины которых равны данным значениям,   1неравносторонним 0,   1равнобед-
 1ренным 0 или  1равносторонним 0.
    22. 0 ( 1Классическая задача. 0) Оцените Ваш выбор тестов  1  0для предыду-
щей задачи,  попытавшись с его помощью ответить на приведённые ниже
вопросы. За каждый ответ "да" присуждается одно очко.
 ш1.1
   (1) Составили ли Вы тест, который представляет правильный нерав-
носторонний треугольник?  (Заметим, что ответ "да" на тесты со зна-
чениями 1, 2, 3, и 2, 5, 10  не обоснован, т.к. не существует треу-
гольников, имеющих такие стороны).
   (2) Составили ли Вы тест,  который представляет правильный  рав-
носторонний треугольник?
   (3) Составили ли Вы тест, который представляет правильный равно-
бедренный  треугольник?  (Тесты со значениями 2,  2,  4 принимать в
расчет не следует.)
   (4) Составили ли Вы,  по крайней мере, три теста, которые предс-
тавляют правильные равнобедренные треугольники,  полученные как пе-
рестановки двух равных сторон треугольника (например,  3,  3, 4; 3,
4, 3; 4, 3, 3)?
   (5) Составили ли Вы тест,  в котором длина одной из сторон треу-
гольника принимает нулевое значение?
   (6) Составили ли Вы тест,  в котором длина одной из сторон треу-
гольника принимает отрицательное значение?
   (7) Составили  ли  Вы  тест,  включающий три положительных целых
числа, сумма двух из которых равна третьему? (Другими словами, если
программа выдала сообщение о том,  что числа 1,  2,  3 представляют
собой стороны неравностороннего треугольника,  то  такая  программа
содержит ошибку.)
   (8) Составили ли Вы, по крайней мере, три теста с заданными зна-
чениями всех трех перестановок, в которых длина одной стороны равна
сумме длин двух других сторон (например, 1, 2, 3; 1, 3, 2; 3, 1,2)?
   (9) Составили ли Вы тест из трех целых положительных чисел,  та-
ких,  что сумма двух из них меньше третьего числа (т.е. 1, 2, 4 или
12, 15, 30)?
   (10) Составили ли Вы, по крайней мере, три теста из категории 9,
в которых Вами испытаны все три перестановки (например, 1, 2, 4; 1,
4, 2 и 4, 1, 2)?
   (11) Составили  ли  Вы тест,  в котором все стороны треугольника
имеют длину, равную нулю (0, 0, 0)?
   (12) Составили ли Вы, по крайней мере, один тест, содержащий не-
целые значения?
   (13) Составили ли Вы хотя бы один тест,  содержащий неправильное
число значений (например, два, а не три целых числа)?

 ш1.2
    3Замечание 0.
 ш1.1
   Профессиональные программисты набирают в среднем 7-8 очков из 13
возможных.

 ш1.2
    23. 0 Составьте тесты для программы,  которая по заданным  действи-
тельным числам x, y, z вычисляет значение функции
 ш1.0

    x 53 0+y 53 0+ 1max 0(x,y,z)
   ───────────────────.
    1max 0(x 52 0,y 52 0,z+1)+x 53 0-1

 ш1.2
    24. 0 Напишите программу, которая в данной матрице B[3,4] ищет сум-
му элементов строки, в которой располагается наименьший по значению
элемент.  Составьте всевозможные тесты  для  проверки  правильности
данной программы.
    25. 0 Напишите  программу,  которая  в заданной матрице C[5,5] ищет
элементы входящие в неё более одного раза. Составьте несколько тес-
тов для проверки правдоподобности данной программы.
    26. 0 Составьте тесты для программы,  которая вносит в данный текс-
товый файл, состоящий из списка фамилий, новую фамилию с сохранени-
ем упорядоченности.

                              2ЛИТЕРАТУРА
    1Безбородов Ю.М. 3   0Индивидуальная отладка программ.  - М.:  Наука,
1982. - 102 с.
    1Дзержинский Ф.Я. 0  Разработка программной документации: понятия и
принципы неформального программирования. - М.: ЦНИИатоминформ, 1980.
    1Йодан Э.   0Структурное программирование и  конструирование  прог-
рамм. - М.: Мир, 1979. - 416 с.
