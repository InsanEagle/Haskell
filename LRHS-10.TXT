    2ЛАБОРАТОРНАЯ РАБОТА 10.
    2ТРАНСФОРМАЦИЯ ПРОГРАММ С ПОМОЩЬЮ КОМБИНАТОРОВ

 ш1.0
           1... любое дело в конечном итоге есть энергопреобразование
           1окружающей среды... Цель жизни - энергопреобразование.
                                         1М.Веллер. Человек в системе
 ш1.2

    _ 1Вспомогательные понятия . 0:
 ш1.0
    1- 0  1частичное применение.

 ш1.2
    _ 1Знать . 0:
 ш1.0
   - понятия:  " 1левое сечение композиции 0", " 1правое сечение компози-
 1ции 0";
   - бесточечный стиль программирования на языке Haskell;
   - понятие " 1обфускация 0".

 ш1.2
    _ 1Уметь . 0:
 ш1.0
    1- преобразовывать 0  1функцию языка Haskell из 0   1аппликативной  формы
 1записи в бесточечную форму записи 0;
    1- преобразовывать 0   1функцию языка Haskell из 0  1композиционной формы
 1записи в бесточечную форму записи 0;
    1- преобразовывать 0  1функцию языка Haskell из 0  1бесточечной формы за-
 1писи в аппликативную или композиционную форму записи 0;
    1- 0  1использовать бесточечную нотацию 0  1для написания функций в языке
 1Haskell 0;
    1- строить коммутативную диаграмму по бесточечной записи 0.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ

 ш1.0
        1В наш век пострационализма всё большее число  работ  пишется
        1на символических языках и всё труднее понять почему 0: 1  какова
        1их действительная цель и в чём необходимость или преимущест-
        1во  быть  окружённым  томами,  состоящими  из  банальностей,
        1представленных в символической форме 0?  1Кажется, что символизм
        1становится  ценностью  в  себе и что он должен почитаться за
        1великую точность.  Речь идёт о новом выражении старых истин,
        1новом символическом ритуале, новой религиозной сути.
        1Однако единственная возможная ценность  такого  рода  вещей,
        1единственное  возможное  извинение за сомнительную претензию
        1на точность, кажется, в этом и состоит. Как только выявляет-
        1ся ошибка или противоречие,  всякая словесная увёртка стано-
        1вится неуместной 0: 1 достаточно доказать это. 0
                                  1К.Поппер. Логика научного открытия
 ш1.2

    1Сутью бесточечного стиля программирования 0 является конструирова-
ние функций  из  множества  базисных функций с помощью комбинаторов
без явного упоминания аргументов.
                 3Бесточечный стиль программирования
                          3на языке Haskell
   Часто для  задания  функции не нужно описывать как она действует
на аргумент,  а можно выразить её действие в целом,  не обращаясь к
существительным, обозначающим её аргументы (фактически используется
речевой   1эллипсис 0):  например,  "Прямые  наследники - это ближайшие
родственники" (в противовес: "Прямые наследники  1человека 0 - это бли-
жайшие родственники  1этого человека 0").
    3Замечание 0.
 ш1.1
    _ 1Эллипсис . 0 (от греч.   1ellipsis 0) - это опущение в речи  или  тексте
слов,  легко  подразумеваемых  или  восстанавливаемых  по контексту
(например, "я домой" вместо "я иду домой").

 ш1.2
   Вспомним, что существует два эквивалентных по  возможностям  ис-
числения,  образующих  1теоретическую основу функционального програм-
 1мирования 0: 7 l 0- _ 1исчисление . 0 и  _ 1комбинаторная логика . 0.
   В первом случае функции не имеют имён - они описываются как пре-
образования над аргументами;  во втором случае,  наоборот,  функции
имеют имена,  но не имеют аргументов - функции описываются как при-
менения базисных комбинаторов.
   Программирование на прикладных языках функционального программи-
рования представляет собой некоторый компромисс между  этими  край-
ностями.  Бесточечный стиль программирования тяготеет к комбинатор-
ной логике,  поэтому для него характерна удивительная краткость за-
писи.  Многие программисты,  однако,  отмечают низкую читабельность
программ, записанных в этом стиле.
    3Замечание 0.
 ш1.1
   Первое систематическое  описание такого подхода к программирова-
нию дано в знаменитой лекции Дж. Бэкуса " 1Can programming be libera-
 1ted from the von Neumann style 0?".  Помимо языка Haskell бесточечный
стиль используют в языках семейства ML и в наследниках языка  прог-
раммирования APL - языках  3J 0 и  3K 0.

 ш1.2
   При бесточечном стиле функции не  определяются  через  результат
вычислений над их аргументами (следовательно, анонимные  7l 0-выражения
не используются).  Вместо этого  функции  выражаются  через  другие
функции при помощи  1комбинаторов высшего порядка 0.
   Пожалуй, чаще всего используется   1оператор  композиции  функций 0,
обозначаемый точкой (.).
   Другими словами,  бесточечная запись заставляет думать о функци-
ях,  о том,  как их соединение порождает результат, а не о данных и
способе их передачи.  В результате можно выбрать простые функции  и
использовать композицию как "клей" для создания более сложных.
   Естественно, что такой стиль часто позволяет уменьшить определе-
ние функции, делая его более лаконичным (хотя это и требует опреде-
лённого привыкания).  С другой стороны, злоупотребление бесточечным
стилем негативно влияет на читаемость функций.
    2Пример 0.
 ш1.0

   f (g x y) = (.) f (g x) y = (.) ((.) f) g x y =
             = (.) (.) (.) f g x y = (.) . (.) f g x y
                                      ═└ 0─── ═┬ 0─── ═┘

 ш1.2
   При  _ 1программировании в бесточечном стиле . 0 (англ.  1points-free sty-
 1le 0,  1freepoint style 0,  1pointless style 0)  опускаются  аргументы (точки
применения) функции в левой и правой частях её определения.
   Другими словами:
 ш1.0

    _ 1Аппликативный стиль . 0:        _ 1Бесточечный стиль . 0:

   sum:: Num a => [a] -> a    sum:: Num a => [a] -> a
   sum  _xs . = foldr (+) 0  _xs .    sum = foldr (+) 0

 ш1.2
   Такое отбрасывание аргументов допустимо,  только если самый пра-
вый аргумент  в левой части (аргумент xs) является самым правым и в
правой части (и при этом больше нигде в правой части не использует-
ся). Подобная  ситуация,  удобная для реализации бесточечной версии
определения функции,  встречается довольно редко. Чаще самый правый
из  аргументов  функции используется не в правой позиции,  а внутри
некоторого выражения.
   Здесь приходит на помощь операция " 1композиция функций 0"
 ш1.0

   (.):: (b -> c) -> (a -> b) -> a -> c
   (f . g) x = f (g x)

 ш1.2
   Прочитав это определение в обратную сторону, легко увидеть,  что
существует способ "вытащить" аргумент из скобок.
    2Пример 0.
 ш1.1
   Для функции foo x = bar (baz (qux x)) преобразования
 ш1.0

   bar (baz (qux x)) = bar ((baz . qux) x) = (bar . (baz . qux)) x

позволяют перейти к эквивалентному бесточечному определению

   foo = bar . baz . qux

 ш1.2
   Метод перехода  от аппликаций к композиции,  проиллюстрированный
этим примером,  является одним из основных при построении бесточеч-
ных определений функций.  Поэтому для бесточечного стиля характерно
широкое использование операции " 1композиция 0".
   Работа с  подробными  композиционными цепочками выглядит неслож-
ной,  когда мы имеем дело с функциями одного аргумента. Эта же тех-
ника  легко  обобщается на выражения,  в которых функция нескольких
аргументов приведены к "одноаргументному" виду частичными  примене-
ниями.
    2Пример 0.
 ш1.1
   Напишем функцию product, которая перемножает первые три элемента
списка (take 3),  предварительно увеличенных на единицу  с  помощью
функционала (map succ):
 ш1.0

   f lst = product (take 3 (map succ lst))

   После очевидных преобразований, получим:

   f lst = product ((take 3) ((map succ) lst)) = f (g (h lst) =
            ═└ 0── ═┬ 0── ═┘ 0   ═└ 0── ═┬ 0─── ═┘ 0   ═└ 0─── ═┬ 0──── ═┘
                5f        g          h
         = (f . g . h) lst = (product . take 3 . map succ) lst

   f' = product . take 3 . map succ

   > f [1,2,3,42]       > f' [1,2,3,42]
   24                   24

 ш1.2
   Бесточечное программирование возможно не только для функций,  но
и для  1операций 0.
   Специфика бесточечного стиля для операций:
 ш1.1
   (а) существенно использует возможность записи любой  операции  в
функциональной  форме  после  заключения  имени  операции в круглые
скобки;
   (б) связана с понятием " 1сечение композиции 0".

 ш1.2
    2Пример 0 [Москвин,2010,с.91-92].
 ш1.1
   Рассмотрим функцию двух переменных
 ш1.0

   toSec min sec = min * 60 + sec

 ш1.1
и проведём преобразования с использованием:
 ш1.1
   (а) композиции (.) (аналог  _ 1комбинатора . 0  1B 0  в  комбинаторной логи-
ке);
   (б) функции flip (аналог  _ 1комбинатора . 0  1C 0)
   (в) префиксной формы записи выражения min*60+sec.

 ш1.1
   В результате получим:
 ш1.0
                                    (C)                         (B)
   min*60+sec = (+)  _((*) min 60) . sec =  _(+) (flip (*) 60 min) . sec =

              = (.) (+) (flip (*) 60) min sec =

              = (+) . (flip (*) 60) min sec.

 ш1.1
   Теперь перепишем  определение функции в виде  1полностью бесточеч-
 1ного 0 определения:
 ш1.0

   toSec = (.) (+) (flip (*) 60),

а также в виде  1частичного бесточечного определения

   toSec' min = (.) (+) (flip (*) 60) min

 ш1.1
   Очевидно, что  приведённые бесточечные определения функции toSec
не выглядят интуитивно понятными; сравните:
 ш1.0

   t1 min sec = min * 60 + sec
   t2 min     = (.) (+) (flip (*) 60) min
   t3         = (.) (+) (flip (*) 60)

 ш1.2
    2Пример 0.
 ш1.1
   Преобразуем функцию
 ш1.0

   mem x lst = any (== x) lst

в функцию, записанную в бесточечной форме:

   any (== x) lst = (.) any (==) x lst = (any . (==)) x lst

   Функция mem примет следующий вид:

   mem = any . (==)

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   Легко заметить,  что в бесточечной нотации используется   1большее
количество точек,  т.к. активно используется операция (.) ( 1компози-
 1ция функций 0), которая определена в стандартном модуле Prelude.
   Однако в наименовании техники корень " 1точка 0" не относится к этой
операции. Этот термин заимствован из топологии,  оперирующей прост-
ранствами, состоящими из точек,  а также функциями, действующими на
пространствах; поэтому  1бесточечное определение функции 0 - это  опре-
деление,  в котором не участвуют "точки" пространства,  над которым
действует функция.
   В терминах  языка Haskell  _ 1точками . 0 называются формальные парамет-
ры функций; другими словами,  1пространства 0 в языке Haskell - это ти-
пы, а  1точки 0 - их значения.
 ш1.2

                  3Использование сечений композиции
                     3в 0  3бесточечной форме записи

 ш1.0
                                         1Свет не вне меня, а во мне.
                                                               1Фихте
 ш1.2

    1Сечения композиции 0  являются  одним  из  инструментов построения
бесточечных выражений.
    2Определение 0.
 ш1.1
   Если 1 op 0  - бинарный оператор, 1  e 0 - выражение языка Haskell, 1  e 0 -
переменная, x 7Е 0FV( 1e 0), то выполняются тождества ( 1скобки важны 0!):
 ш1.0

   (1) ( 1op 0  1e 0)  ═+ 0 \x -> x 1 op e 0;  (2) ( 1e 0  1op 0)  ═+ 0 \x ->  1e op 0 x.

 ш1.2
   Другими словами,  сечения композиции являются синтаксическим са-
харом для 7 l 0-термов определённого вида.
    2Определение 0.
 ш1.1
    2(1) 0  _ 1Левым сечением композиции . 0  f . g  называется частичный вызов
(частичное применение) вида
 ш1.0

   (f .) ═+ 0\x -> (f 1  0. x), x 7Е 0FV(f).

 ш1.1
    2(2) 0  _ 1Правым сечением композиции . 0  f . g называется частичный вызов
(частичное применение) вида
 ш1.0

   (. g) ═+ 0\x -> (x 1  0. g), x 7Е 0FV(g).

 ш1.2
    _ 1Соглашение об обозначениях . 0 ( 1важное 0).
 ш1.1
   В выражении ( 7a 0 .  7b 0) можно опускать внешние скобки; в этом случае
выражение  7b 0 распространяется вправо до конца выражения,  т.е. выра-
жение  f . g h  понимается как (f . g h),  что, конечно, не обязано
совпадать с выражением (f . g) h.

 ш1.2
    2Теорема 0 ( 1о сечениях композиции 0).
 ш1.1
   Выполнены следующие утверждения о равенстве типов:
 ш1.0

   (1) f . g . h = f . (g . h) 1  0( 1правая ассоциативность композиции 0);

   (2) f (g x) = (.) f g x     ( 1введение композиции, свойство B 0);

   (3) f x y = flip f y x      ( 1введение flip, свойство C 0);

   (4) (f . g) = (f .) g       ( 1введение левого сечения 0);

   (5) (f . g) = (. g) f       ( 1введение правого сечения 0);

   (6) (f .) = (.) f           ( 1удаление левого сечения 0);

   (7) flip (.) f = (. f)      ( 1удаление flip 0).

 ш1.2
    2Доказательство 0. Обоснованием п. (1) является определение приори-
тета операции композиции (.);  обоснованием  пп. (2) и (3) являются
определения комбинаторов B и C в 7 l 0-исчислении.
   Обоснованием пп. (4) и (5) является определение  частичного при-
менения функции:
 ш1.0

   (f .) g ═+ 0(\x -> (f 1  0. x)) g = (f . g),

   (. g) f ═+ 0(\x -> (x 1  0. g)) f = (f . g).

   Далее, по определению операции композиции получим:

   f (g x) = (.) f g x = (f . g) x => (f . g) = (.) f g

   Отсюда получается доказательство пунктов (6) и (7):

   (f . g) = (f .)  _g . = (.) f  _g . => (f .) = (.) f;

   (f . g) = (. g)  _f . = (.) f g = flip (.) g  _f . => (. g) = flip (.) g

 ш1.2
    1Теорема доказана 0.
   Приведём тестирование типов с использованием интерпретатора:
 ш1.0

   (1) > :t (sin 2  0.)
       (sin .):: Floating a => (a -> b) -> a -> b
       > :t (.) sin
       (sin .):: Floating a => (a -> b) -> a -> b

   (2) > :t (. 2  0sin)
       flip (.) sin:: Floating a => (a -> b) -> a -> b

       > :t flip (.) sin
       flip (.) sin:: Floating a => (a -> b) -> a -> b

   (3) > :t \f -> \g -> \h -> f . (g . h)
       \f -> \g -> \h -> f . g . h ::
                         (a -> b) -> (c -> a) -> (d -> c) -> d -> b

       > :t \f -> \g -> \h -> (f . g) . h
       \f -> \g -> \h -> (f . g) . h ::
                         (a -> b) -> (c -> a) -> (d -> c) -> d -> b

 ш1.2
   (4) Обратим внимание на расстановку скобок в операции композиции
и на несовпадающие при этом типы:
 ш1.0

   > :t \f g x y -> (f . g) x y
   \f g x y -> (f . g) x y ::
                           (a -> b -> c) -> (d -> a) -> d -> b -> c
   > :t \f g x y -> (f . g x) y
   \f g x y -> (f . g x) y ::
                           (a -> b) -> (c -> d -> a) -> c -> d -> b
   > :t \f g x y -> f . g x y
   \f g x y -> f . g x y ::
                 (a -> b) -> (c -> d -> e -> a) -> c -> d -> e -> b

 ш1.2
    2Примеры 0.
 ш1.0

    21. 0 (. f) g = (flip (.) f) g = (.) g f = g . f

    22. 0 g . (. f) h
              = g . (flip (.) f) h = g . (flip (.) f h) =
              = g . (h . f)

    23. 0 f (g (h x y z))
              = (.) (f g) (h x y z) = (.) ((.) (f g)) (h x y) z =
              = (.) ((.) ((.) (f g))) (h x) y z =
              = (.) ((.) ((.) ((.) (f g)))) h x y z =
              = (.) (.) (.) ((.) ((.) (f g))) h x y z =
              = (.) ((.) (.) (.)) (.) ((.) (f g)) h x y z =
              = (.) ((.) ((.) (.) (.)) (.)) ((.) f) g) h x y z =
              = (.) ((.) ((.) ((.) (.) (.)) (.))) (.) f g h x y z =
              = ((((.) . (.)) . (.)) .) . (.) f g h x y z

 ш1.1
   Приведём примитивное тестирование в интерпретаторе Haskell:
 ш1.0

   h' x y z = x + y + z; g' x = 2 * x; f' x = x + 1000
   ---------------------------------------------------
   fun x y z = f' (g' (h' x y z))
   fun'      = (.) ((.) ((.) ((.) (.) (.)) (.))) (.)
   fun''     = ((((.) . (.)) . (.)) .) . (.)
   --------------------------------------------------
   test = fun' f' g' h' 1 1 1 == fun'' f' g' h' 1 1 1

 ш1.1
    24. 0 Докажем двумя способами утверждение
 ш1.0

   > ((.) (.)) (==) 1 (1 +) 0
   True

   (а) (.) (.) (==) 1 (1 +) 0
                   = (.) ((==) 1) (1 +) 0 = (==) 1 ((1 +) 0) =
                   = (==) 1 (1 + 0) = (1 == 1 + 0);

   (б) докажем, что a b (c d) = (.) (.) a b c d:

   a b (c d) = (.) (a b) c d = (.) (.) a b c d

 ш1.1
   Теперь
 ш1.0

   ((.)(.)) (==) 1 (1+) 0 = (==) 1 ((1+) 0).

 ш1.1
   Проверим полученный результат в интерпретаторе:
 ш1.0

   f     = \a -> \b -> \c -> \d -> a b (c d)
   test1 = f (==) 1 (1+) 0 == (==) 1 ((1+) 0)

    25. 0 f (g x y z) = (.) f (g x y) z = (.) ((.) f) (g x) y z =
                  = (.) ((.) ((.) f)) g x y z = ((f .) .) . g x y z
 ш1.2

                 3Варианты записи 0  3сечений 0  3композиции

 ш1.0
                                   1Смерть и жизнь во власти языка, и
                                   1любящие его вкусят от плодов его.
                                                       1Притчи, 18 0: 121
 ш1.2

    21. 0 Рассмотрим  _ 1бесточечную конструкцию . 0 вида:
 ш1.0

   (. f) . g = g x (f y)

   Приведём бесточечную форму к аппликативной форме:

   ((. f) . g) x y = (. f) (g x) y = (g x . f) y = g x (f y).

 ш1.2
   Вычислим типы  аппликативной и бесточечной конструкций в интерп-
ретаторе Haskell:
 ш1.0

   > :t \f g x y -> g x (f y)
   \f g x y -> g x (f y):: (a -> b) -> (c -> b -> d) -> c -> a -> d

   > :t \f g -> (. f) . g
   \f g -> (. f) . g:: (d -> b) -> (a -> b -> c) -> (a -> d -> c)
                        ═└ 0── ═┬ 0─── ═┘ 0     ═└ 0───── ═┬ 0───── ═┘ 0     ═└ 0───── ═┬ 0───── ═┘
                          f              g 3                0  3R

 ш1.2
   Конструкция  ((. f) . g) порождает функцию, семантически эквива-
лентную функции g,  только её второй аргумент заменен на  результат
вызова f.
   Докажем, что если f:: d -> b, g:: a -> b -> c, то
 ш1.0

   g  3x 0 (f  3y 0):: a -> d -> c

 ш1.2
построением следующего дерева вывода,  в котором используется  син-
таксис языка Haskell:
 ш1.0

    3y 0::d  f::d -> b   3x 0::a  g::a -> b -> c
   ───────────────  ────────────────────
        f 3y 0::b  3      0      g 3x 0::b -> c
        ───────────────────────────
                 g 3x 0(f 3y 0):c

 ш1.2
   Построим  _ 1коммутативную диаграмму . 0 по аппликативному представлению:
 ш1.0

              4┌ 0─── 4┐
          id 4d 0│ d │
              4└ 0─∙ 75 4┘
               ═J 0│ ═\ 0          Аппликативную форму g x (f y) представим
              ═/ 0 │  ═\ 0         также в виде вызовов (с типами):
             ═/ 0  │   ═\
           3R ═/ 0  f│    ═\ 3R 0         b 76 0c  7  0 b
           ═/ 0    │     ═\ 0           7% 0     7%
    id 4a 0   ═/ 0     │      ═\ 0         ═┌┴┐ 0  ═┌ 0─ ═┴ 0─ ═┐
    4┌ 0─ 76 0─ 4┐ ═/ 0       7^ 0b      ═K 0 c    (g  3x 0 (f  3y 0))::c
   │ a ∙────── 76 0∙────── 76 0∙         7% 0     7%
    4└ 0─── 4┘ ═└ 0────── ═┬ 0────── ═┘ 0         a    d
               g

 ш1.2
    2Примеры 0.
 ш1.0

   tm1 x y = map x (tail y)
   tm2     = (. tail) . map
   -------------------------------------
   msz1 x y z = zipWith x (map succ y) z
   msz2       = (. map succ) . zipWith
   test1      = msz1 (\x -> \y -> x+y) [1..3] [10..12]
   test2      = msz2 (\x -> \y -> x+y) [1..3] [10..12]
   ---------------------------------------------------
   ff1 x y = foldr1 x (filter (>3) y)
   ff2     = (. filter (>3)) . foldr1
   ----------------------------------------------------
   -- Определение функции replicate в бесточечном стиле
   ----------------------------------------------------
   rt1 x y = take x (repeat y)
   rt2     = (. repeat) . take

 ш1.2
    22. 0 Рассмотрим  _ 1бесточечную конструкцию . 0 вида:
 ш1.0

   (f .) . g

   Приведём бесточечную форму к аппликативной:

   ((f .) . g) x y = (f .) (g x) y = (f . (g x)) y = f (g x y)

 ш1.2
   Конструкция (f .) . g порождает функцию, эквивалентную g, только
её результат обрабатывается затем f.
   Вычислим тип бесточечной конструкции в языке Haskell:
 ш1.0

   \f g -> (f .) . g:: (c -> d) -> (a -> b -> c) -> (a -> b -> d)
                        ═└ 0── ═┬ 0─── ═┘ 0     ═└ 0───── ═┬ 0───── ═┘ 0     ═└ 0───── ═┬ 0───── ═┘
                          f              g 3                0  3R

 ш1.2
   Докажем, что если f:: c -> d, g:: a -> b -> c, то
 ш1.0

   f (g  3x 0  3y 0):: a -> b -> d

 ш1.2
построением следующего дерева вывода,  в котором используется  син-
таксис языка Haskell:
 ш1.0

        3x 0::a  g:: a -> b -> c
       ─────────────────────
    3y 0::b      g 3x 0::b -> c
   ────────────────────
          g 3xy 0::c       f:: c -> d
          ───────────────────────
                 f(g 3xy 0)::d

 ш1.2
   Построим  _ 1коммутативную диаграмму . 0 по аппликативному представлению:
 ш1.0

          g
    ═┌ 0────── ═┴ 0────── ═┐
   ∙───── 76 0∙───── 76 0∙c       Аппликативную форму f (g x y) представим
   a     b  ═\ 0     │        также в виде вызовов (с типами):
             ═\ 0    │              c
             3R ═\ 0   │f              7%
               ═\ 0  │             ═┌ 0─ ═┴ 0─ ═┐
                ═\ 0 │        (f (g  3x 0  3y 0))::d
                 ═K 7^ 0               7% 0  7%
                 ∙d             a b

 ш1.2
    2Примеры 0.
 ш1.0

   -- Определение функционала takeWhile в бесточечном стиле
   --------------------------------------------------------
   f1 = (fst .) . span
   --------------------------------------------
   -- Функция возвращает 0 при неудачном поиске
   --------------------------------------------
   f2 = (fromMaybe 0 .) . find

 ш1.2
    23. 0 Рассмотрим  _ 1бесточечную конструкцию . 0 вида:
 ш1.0

   g . (f .)

   Приведём бесточечную форму к аппликативной форме:

   (g . (f .)) h = g ((f .) h) = g (f . h)

 ш1.2
   Конструкция g . (f .) порождает функцию, эквивалентную g, только
вместо её функционального аргумента передается композиция f и ново-
го функционального аргумента.
   Вычислим тип бесточечной конструкции в языке Haskell:
 ш1.0

  \f g -> g . (f .):: (d -> b) -> ((a -> b) -> c) -> ((a -> d) -> c)
                        ═└ 0─ ═┬ 0── ═┘ 0       ═└ 0───── ═┬ 0───── ═┘ 0       ═└ 0── ═┬ 0── ═┘
                         f               g                3h

 ш1.2
   Докажем, что если f:: d -> b, g:: (a -> b) -> c,  3h 0:: a -> d, то
 ш1.0

   \ 3h 0 -> g (f .  3h 0):: (a -> d) -> c

 ш1.2
построением следующего дерева вывода,  в котором используется  син-
таксис языка Haskell:
 ш1.0

    3h 0:: a -> d  f:: d -> b
   ──────────────────────
      (f .  3h 0):: a -> b   g:: (a -> b) -> c
      ────────────────────────────────────
                 g (f .  3h 0):: c
        ───────────────────────────────
        \ 3h 0 -> g (f .  3h 0):: (a -> d) -> c

 ш1.2
   Построим  _ 1коммутативную диаграмму . 0 по аппликативному представлению:
 ш1.0

          ∙d
          ═J 0│ ═\ 0              Аппликативную форму g (f . h) представим
         ═/ 0 │  ═\ 0             также в виде вызовов (с типами):
       3h ═/ 0 f│   ═\ 0                 7  0a 76 0b
       ═/ 0   │    ═\ 7           0  7  0    7  %
   a  ═/ 0     7^ 0b    ═K 0 c             ═┌ 0─ ═┴ 0─ ═┐
    ∙──── 76 0∙──── 76 0∙         (g (f 7  0. 7  3h 0))::c
     ═└ 0───── ═┬ 0───── ═┘ 0              7% 0    7%
          g                  d 76 0b a 76 0d

 ш1.2
    2Пример 0.
 ш1.0

   > map . (digitToInt .)
   -------------------------------------------------------
   -- Функция succ вызывается до преобразования к типу Int
   -- (прерывание работы на значении digitToInt 'G')
   -------------------------------------------------
   > (map . (digitToInt .)) succ "ABCDE"
   [11,12,13,14,15]
   --------------------------------------
   > (map . (digitToInt .)) succ "ABCDEF"
   [11,12,13,14,15,
   *** Exception: Char.digitToInt: not a digit 'G'

 ш1.2
    24. 0 Рассмотрим  _ 1бесточечную конструкцию . 0 вида:
 ш1.0

   g . (. f)

   Приведём бесточечную форму к аппликативной форме:

   (g . (. f)) h y = g ((. f) h) y = g (h . f) y.

 ш1.2
   Конструкция g . (. f) порождает функцию, эквивалентную g, только
вместо её функционального аргумента  передается  композиция  нового
функционального аргумента и f.
   Вычислим тип бесточечной конструкции в языке Haskell:
 ш1.0

   \f g -> g . (. f)::((a -> b) -> c) -> (a -> d) -> (d -> b) -> c)
                        ═└ 0───── ═┬ 0───── ═┘ 0      ═└ 0── ═┬ 0─── ═┘ 0     ═└ 0── ═┬ 0─── ═┘
                              g              f 3           h

 ш1.2
   Докажем, что если g:: (a -> b) -> c, f:: a -> d, то
 ш1.0

   g ( 3h 0 . f) y:: (d -> b) -> c

 ш1.2
построением следующего дерева вывода,  в котором используется  син-
таксис языка Haskell:
 ш1.0

    3h 0::d -> b  f::a -> d
   ────────────────────
     ( 3h 0 . 3  0f):: a -> b  g:: (a -> b) -> c
     ───────────────────────────────────
                g ( 3h 0 . 3  0f)::c

 ш1.2
   Построим  _ 1коммутативную диаграмму . 0 по аппликативному представлению:
 ш1.0

    ∙ d
     7% ═\ 0                   Аппликативную форму g ( 3h 0 . 3  0f) представим
    │  ═\ 0                  также в виде вызовов (с типами):
    │   ═\ 0                   7  0   a 76 0b
   f│    ═\ 3h 0                 7   0    7%
    │     ═\ 0           7    0       ═┌ 0─ ═┴ 0─ ═┐
    │      ═\ 0              (g (h . f))::c
   a│       ═K 7  0b  7    3  7  0c         7% 0    7%
    ∙────── 76 0∙────── 76 0∙       d 76 0b a 76 0d
     ═└ 0─────── ═┬ 0─────── ═┘ 0
            g

 ш1.2
    2Примеры 0.
 ш1.0

   > map . (. digitToInt)
   ----------------------------------------------------------
   -- Функция succ вызывается после преобразования к типу Int
   -- (отсутствует прерывание вычислений)
   --------------------------------------
   > (map . (. digitToInt)) succ "ABCDE"
   [11,12,13,14,15]
   -------------------------------------
   > (map . (.digitToInt)) succ "ABCDEF"
   [11,12,13,14,15,16]

 ш1.2
                    3Композиция сечений композиции
    2Пример 0.
 ш1.1
   Пусть f, g, h - унарные функции.
    21. 0 Покажем, что комбинация правых сечений позволяет "избавиться"
от  _ 1первого . 0 компонента композиционной формы (f . g . h):
 ш1.0

   ( _f . . g) . h = (.) (f . g) h = flip (.) h (f . g) =
                                  ═└ 0─── ═┬ 0──── ═┘
               = (. h) (f . g) = (. h) ((. g) f) =
               = (.) (. h) (. g) f = (. h) . (. g)  _f
                                      ═└ 0───── ═┬ 0───── ═┘

   ( _f . . g) . h = (. h) (f . g) = (. h) ((. g) f) =
               = (.) (. h) (. g) f = (. h) . (. g)  _f
                                      ═└ 0───── ═┬ 0───── ═┘

 ш1.1
    22. 0 Покажем,  что  комбинация  правого и левого сечения позволяет
"избавиться" от  _ 1среднего . 0 компонента в композиционной форме:
 ш1.0

   f .  _g . . h = f . (g . h) = f . ((. h) g) = (.) f ((. h) g) =
             = (.) ((.) f) (. h) g = (f .) . (. h)  _g
                     ═└ 0─ ═┬ 0── ═┘ 0            ═└ 0───── ═┬ 0───── ═┘

   (f .  _g .) . h = (.) (f . g) h = flip (.) h (f . g) =
                                  ═└ 0─── ═┬ 0──── ═┘
               = (. h) (f . g) = (. h) ((f .) g) =
               = (.) (. h) (f .) g = (. h) . (f .)  _g
                                      ═└ 0───── ═┬ 0───── ═┘

 ш1.1
    23. 0 Комбинация левых сечений позволяет "избавиться" от  _ 1последнего
компонента в композиционной форме (f . g . h):
 ш1.0

   f . g .  _h . = f . (g . h) = f . ((g .) h) = (.) f ((g .) h) =
             = (.) ((.) f) (g .) h = (f .) . (g .)  _h
                     ═└ 0─ ═┬ 0── ═┘ 0            ═└ 0───── ═┬ 0───── ═┘

 ш1.1
    24. 0 Можно  "избавиться" от 1  _первого . 0 и 1  _последнего . 0 компонента в ком-
позиционной форме (f . g . h):
 ш1.0

    _f . . g .  _h . = f . (g . h) = (.) f (g . h) = (.) f ((.) g h) =
             = (.) ((.) f) ((.) g) h = flip (.) ((.) g) ((.) f) h =
             = (. ((.) g)) ((.) f) h = (.) (. ((.) g)) (.) f h =
             = (. ((.) g)) . (.) f h = (. (g .)) . (.)  _f .  _h

 ш1.1
    25. 0 Можно "избавиться" от 1  _первого . 0 и 1  _второго . 0 компонента в компози-
ционной форме (f . g . h):
 ш1.0

    _f . .  _g . . h = f . (g . h) = (.) f ((.) g h) =
             = (.) f (flip (.) h g) = (.) f ((. h) g) =
             = (.) ((.) f) (. h) g = flip (.) (. h) ((.) f) g =
             = (. (. h)) ((.) f) g = (.) (. (. h)) (.) f g =
             = (. (. h)) . (.)  _f .  _g

 ш1.1
    26. 0 Можно "избавиться" от 1  _второго . 0 и 1  _третьего . 0 компонента в  компо-
зиционной форме (f . g . h):
 ш1.0

   f .  _g . .  _h . = f . (g . h) = (.) f ((.) g h) =
             = (.) ((.) f) ((.) g) h = (.) ((.) ((.) f)) (.) g h =
             = ((f .) .) . (.)  _g .  _h

 ш1.1
    27. 0 Можно "избавиться" от 1  _первого . 0,   _ 1второго . 0 и 1  _третьего . 0 компонента
в композиционной форме (f . g . h):
 ш1.0

    _f . .  _g . .  _h . = f . (g . h) = (.) f ((.) g h) =
             = (.) ((.) f) ((.) g) h = (.) ((.) ((.) f)) (.) g h =
             = flip (.) (.) ((.) ((.) f)) g h =
             = (. (.)) ((.) ((.) f)) g h =
             = (.) (. (.)) (.) ((.) f) g h =
             = (.) ((.) (. (.)) (.)) (.) f g h =
             = ((. (.)) . (.)) . (.)  _f .  _g .  _h

 ш1.2
    2Примеры 0 ( 1вычисления типов с помощью интерпретатора Haskell 0).
 ш1.0

    21. 0 > t: \f -> (f 2  0.)
      \f -> (f .):: (a -> b) -> (c -> a) -> (c -> b)

    22. 0 > t: \f -> ((f 2  0.) 2  0.)
      \f -> (f .):: (a->b) -> (c -> d -> a) -> (c -> d -> b)

    23. 0 > t: \f -> (((f 2  0.) 2  0.) 2  0.)
      \f -> (f.)::
               (a -> b) -> (c -> d -> e -> a) -> (c -> d -> e -> b)

    24. 0 > :t \f g -> ((. f) . (g . f))
      \f g -> flip (.) f . g . f ::
                           (a -> b) -> (b -> b -> c) -> a -> a -> c

      > :t \f g x y -> g (f x) (f y)
      \f g x y -> g (f x) (f y) ::
                           (a -> b) -> (b -> b -> c) -> a -> a -> c

 ш1.2
   Для дальнейшего воспользуемся  1операцией нестрогой аппликации 0  $,
обладающей  1наименьшим 0 приоритетом.
    2Определение 0.
 ш1.0

   f $ x ═+ 0f x

 ш1.2
    2Лемма 0 ( 1свойства 0 $).
 ш1.0

    2(1) 0 ($ x) = \z -> z x; 2   (3) 0 ($ g) . f = flip f g;
    2(2) 0 flip ($) x = ($ x); 2  (4) 0 f . ($ g) = flip (f .) g.

 ш1.2
    2Доказательство 0.
 ш1.0

    21. 0 ($ x) f = f $ x = f x, (\z -> z x) f = f x.

    22. 0 flip ($) x f 2  0= ($) f x = f $ x, ($ x) f = f $ x.

    23. 0 (($ g) . f) x y = ((\z -> z g) . f) x y =
             = (\z -> z g) (f x) y = (f x) g y = flip f g x y.

    24. 0 (f . ($ g)) x y = (f . (\z -> z g)) x y =
             = f ((\z -> z g) x) y = f (x g) y;
      flip (f .) g x y = (f .) x g y = (f . x) g y = f (x g) y.

 ш1.2
    1Лемма доказана 0.
   Приведём три примера использования $:
 ш1.0

   t1 = sin $ 2; t2 = map ($ 2) [sin,cos];
                 t3 = map (($) sin) [0,1]

 ш1.1
    2Пример 0.
 ш1.1
   Очевидно, что
 ш1.0

   flip . (. flip id) = flip . flip (.) (flip id)
           ═└ 0──── ═┬ 0──── ═┘ 0           ═└ 0─────── ═┬ 0──────── ═┘

 ш1.1
   Поэтому должны совпасть типы следующих выражений:
 ш1.0

   > :t flip . (. flip id)
   flip . flip (.) (flip id) ::
                         (((a -> b) -> b) -> c -> d) -> c -> a -> d

   > :t flip . flip (.) (flip id)
   flip . flip (.) (flip id) ::
                         (((a -> b) -> b) -> c -> d) -> c -> a -> d

 ш1.1
   Теперь переведём  выражение  flip . (. flip id)  в аппликативную
форму записи:
 ш1.0

   (flip . (. flip id)) f g x = (.) flip (. flip id) f g x =
           = flip ((. flip id) f) g x = ((. flip id) f) x g =
           = (f. flip id) x g = f (flip id x) g

 ш1.1
   Для контроля вычислим тип результата в интерпретаторе Haskell:
 ш1.0

   > t: \f -> \g -> \x -> f (flip id x) g
   \f -> \g -> \x -> f (flip id x) g ::
                         (((a -> b) -> b) -> c -> d) -> c -> a -> d

 ш1.1
   Приведём ещё  одно "точечное" представление рассматриваемого вы-
ражения с помощью операции нестрогой аппликации $:
 ш1.0

   (flip . (. flip id)) f g x = f (flip id x) g =
       = { в комбинаторах... } = f (CIx) g =
       = { CIx=( 7l 0x. 7l 0y. 7l 0z.xzy)Ix=( 7l 0y. 7l 0z.Izy)x=( 7l 0y. 7l 0z.zy)x= 7l 0z.zx } =
       = f (\z -> z x) g = f ($ x) g

 ш1.1
   Проверим тип полученного "точечного" выражения:
 ш1.0

   > t: \f -> \g -> \x -> f ($ x) g
   \f -> \g -> \x -> f (flip ($) x) g::
                         (((a -> b) -> b) -> c -> d) -> c -> a -> d

 ш1.1
   Проверим результаты преобразований в интерпретаторе Haskell; для
этого выберем f ═+ 0map, g ═+ 0[sin,cos], x ═+ 00.5:
 ш1.0

   abc  f g x = (flip . (. flip id)) f g x == f (flip id x) g
   abc' f g x = f ($ x) g == f (\z -> z x) g
   -----------------------------------------
   test1 = abc  map [sin,cos] 0.5
   test2 = abc' map [sin,cos] 0.5

 ш1.1
   Построим ещё одним способом точечное представление выражения
 ш1.0

   (flip . (. flip id)) f g x

 ш1.1
по его типу.
   Для этого будем интерпретировать тип как формулу  в   1минимальной
 1логике 0 и вначале построим его вывод в генценовском исчислении нату-
рального вывода:
 ш1.0

              3   4
               7^ 0    7^
              a  a─ 76 0b
              ───────
                 b               1
             ─────────            7^
          2  (a─ 76 0b)─ 76 0b  ((a─ 76 0b)─ 76 0b)─ 76 0(c─ 76 0d)
           7^ 0  ──────────────────────────────
          c              c─ 76 0d
          ───────────────────
                  d                       1Список допущений 0:
                 ────                    1. ((a─ 76 0b)─ 76 0b)─ 76 0(c─ 76 0d)
                 a─ 76 0d                    2. с
                9───────── 0                 3. a
               c─ 76 0(a─ 76 0d)                 4. a─ 76 0b
   ──────────────────────────────────
   (((a─ 76 0b)─ 76 0b)─ 76 0(c─ 76 0d))─ 76 0(c─ 76 0(a─ 76 0d))

 ш1.1
   Опираясь на вывод, построим 7 l 0-терм, имеющий заданный тип:
 ш1.0

                       3x 0::a  f::a─ 76 0b
                      ─────────────
                          f 3x 0::b
                     ────────────────
                      7l 0f.f 3x 0::(a─ 76 0b)─ 76 0b  g::((a─ 76 0b)─ 76 0b)─ 76 0(c─ 76 0d)
                     ────────────────────────────────────────
                 3y 0::c              g( 7l 0f.fx)::c─ 76 0d
                ────────────────────────────────
                          g( 7l 0f.f 3x 0) 3y 0::d
                       ──────────────────
                        7l 0x.g( 7l 0f.fx) 3y 0::a─ 76 0d
                   ──────────────────────────
                    7l 0y. 7l 0x.g( 7l 0f.f 3x 0) 3y 0::c─ 76 0(a─ 76 0d)
   ──────────────────────────────────────────────────────────
    7l 0g. 7l 0y. 7l 0x.g( 7l 0f.f 3x 0) 3y 0 :: ((((a─ 76 0b)─ 76 0b)─ 76 0(c─ 76 0d))─ 76 0(c─ 76 0(a─ 76 0d)))
    ═└ 0─────── ═┬ 0──────── ═┘ 0     ═└ 0──────────────── ═┬ 0───────────────── ═┘
      1Доказательство 0           1Формула в минимальной логике

 ш1.1
   Преобразуем полученное доказательство в  7l 0-терм в языке Haskell:
 ш1.0

   \g -> \y -> \x -> g (\f ->f x) y

 ш1.1
   Проверим тип полученного "точечного" выражения:
 ш1.0

   > t: \g -> \y -> \x -> g (\f ->f x) y
   \g -> \y -> \x -> g (\f ->f x) y::
                         (((a -> b) -> b) -> c -> d) -> c -> a -> d
                            ═└ 0── ═┬ 0─── ═┘ 0f
                            ═└ 0───── ═┬ 0───── ═┘ 7l 0f.fx
                          ═└ 0──────────── ═┬ 0──────────── ═┘ 0g

 ш1.1
   Построим  1коммутативную диаграмму 0 для  7l 0-терма  7l 0g. 7l 0y. 7l 0x.g( 7l 0f.fx)y:
 ш1.0

                  c   g   d
                   ∙──── 76 0∙     Аппликативную форму представим также
                    7% 0           в виде вызовов (с типами):
                   │                b
                  g│                  ═О
                   │                  ═┌┴┐
       f     7l 0f.fx  │           g ( 7l 0f.f x) y
    ∙──── 76 0∙─────── 76 0∙b              ═└ 0─ ═┬ 0── ═┘О 0   ═О
    a    7   0b                       7  0  7 ^ 0    a  c
                                    b

 ш1.2
                     3Работа с примерами решения
                        3некоторых упражнений
 ш1.1
   См. Пример 1, Пример 2, Пример 3, Пример 4.

 ш1.2
                        3Понятие "обфускация"
   Однако с бесточечной нотацией имеется одна проблема. При неакку-
ратном использовании эта методика может привести к эффекту, который
называется  1обфускацией исходного кода 0.
    2Определение 0 [Касперски,Рокко,2008,с.813,819].
 ш1.1
    _ 1Обфускацией . 0 (от англ.  1obfuscation 0 -  1запутывание 0) называется  со-
вокупность методик и средств,  направленных на затруднение  анализа
программного кода. Существуют различные типы обфускаторов: одни за-
нимаются интерпретируемыми языками наподобие Perl или PHP и  "корё-
жат" исходные тексты (удаляют комментарии, дают переменным бессмыс-
ленные имена,  шифруют строковые константы),  другие "перемалывают"
байт-код виртуальных машин Java и .NET, что технически сделать нам-
ного труднее.  Самые совершенные обфускаторы вторгаются  непосредс-
твенно в машинный код, "разбавляя" его мусорными инструкциями и вы-
полняя целый ряд структурных (реже математических)  преобразований,
изменяющих программу до неузнаваемости.
   Самые совершенные обфускаторы выполняют математические  преобра-
зования программного кода.  В частности, команда a++ может быть за-
менена на эквивалентную ей конструкцию на языке C
 ш1.0

   a+ = pow (sin (x),2) + pow (cos (x),2),

 ш1.1
где и sin(),  и cos() вычисляются "вручную" посредством самого гро-
моздкого  алгоритма,  распознать в котором исходную формулу практи-
чески невозможно.

 ш1.2
   При композиции  цепочек  функций  высшего  порядка  бывает очень
сложно мысленно вывести тип таких композиций, т.к. отсутствуют "за-
цепки" в виде аргументов,  тип которых помогает в  процессе  вывода
типа функции.
   Также функции,  которые определены в бесточечном стиле, обладают
 _ 1свойством усложнения модификации . 0 в случаях, когда необходимо внести
в функциональность малейшие изменения. Иной раз для этого приходит-
ся переписывать весь код функции. Это происходит потому, что компо-
зиция нескольких функций является более сложным элементом  програм-
мирования, чем вызов функций в обычном стиле.
   В заключение подчеркнём,  что  1бесточечный стиль 0 - это всего лишь
одна из техник программирования на языке Haskell. Разумный програм-
мист понимает, что никакой техникой не стоит злоупотреблять в ущерб
другим.  Компактность,  возникающая благодаря  использованию  этого
стиля,  имеет  свою  цену:  глядя  на бесточечную инструкцию иногда
трудно восстановить количество и тип необходимых аргументов. Поэто-
му  рассмотренные выше преобразования можно порекомендовать исполь-
зовать в ситуациях,  когда их  компонентами  являются  библиотечные
функции из семейств map, fold, scan, zipWith и т.п.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1, Пример 2, Пример 3, Пример 4.

 ш1.2
    3Замечание 0.
 ш1.1
   Иногда для обозначения точечного стиля  используются  английские
термины " 1pointwize 0", " 1pointful 0" и " 1pointfree 0".
 ш1.2

                    2Прагматика бесточечного стиля

 ш1.0
                 1Материнский педагогический  эксперимент  был в том,
                 1что мне не давали игрушек - только кубики с  буква-
                 1ми, из которых я складывал слова, играя у ног мате-
                 1ри на кухне во время её круглосуточной стряпни... 0
                                                      1Варлам Шаламов
 ш1.2

   Представим связь между различными представлениями функций следу-
ющим  образом (стрелки помечены смыслами переводов из одного предс-
тавления в другое):
 ш1.0

                      4┌ 0─────────────────────── 4┐
                     │Коммутативные диаграммы│
                      4└ 0──── 7% 0─────────────┬──── 4┘
                          │             │
                   1для визуализации и использования
                     1результатов теории категорий
                          │             │
      4┌ 0────────────────────┴───────────── 7^ 0────────────────────── 4┐
     │               Функции в  _ 1бесточечном . 0 стиле               │
      4└ 0── 7% 0────────────┬────────────┬────────────────┬──────── 7% 0── 4┘
        │             1│ 0             7^ 0                │        │
      1для прак- 0    1для чтения  0  1для построения 0  1  для чтения 0  1для прак-
      1тического 0    1чужих 0        1комбинаторных 0    1 чужих 0       1тического
      1программи- 0   1программ 0     1библиотек 0        1 программ 0    1программи-
      1рования 0          1│                             │ 0  1    рования
        │            │                             │        │
 4┌ 0───────┴──────────── 7^ 0── 4┐ 0                   1   0    1  4┌ 0─ 7^ 0────────┴───── 4┐
│Функции в  _ 1аппликативном . 0├──  1для практического  0── 76 0│Функции в  _ 1компо- . 0│
│("точечном") стиле: 1     0│ 75 0─  1программирования 0  1  0───┤ _ 1зиционном . 0 стиле:│
│     f (g (h...))      │                   1   0    1  0│   f . g . h    │
 4└ 0─────────────────────── 4┘ 0                   1    0    4└ 0──────────────── 4┘

 ш1.2
   Естественно, что  функция  в композиционном стиле может являться
функцией в бесточечном стиле.
                21. 3 Понятие "комбинаторная библиотека"
   Бесточечная форма используется для построения  _ 1комбинаторных биб-
 _ 1лиотек . 0 в языках функционального программирования.
    2Определение 0 [Кирпичёв,2009,с.177].
 ш1.1
    _ 1Комбинаторная библиотека . 0 - это программная библиотека, моделиру-
ющая предметную область при помощи комбинаторной модели,  для кото-
рой характерно:
   (1) соответствие терминологии библиотеки и терминологии предмет-
ной области;
   (2) состав:  типы,  примитивы, комбинаторы первого и высшего по-
рядка;
   (3) свойство замыкания;
   (4) возможность эффективной реализации.

 ш1.2
   Модели сущностей,  взаимосвязанных в предметной области,  должны
быть сами взаимосвязаны.  Всякой концепции  из  предметной  области
должна соответствовать концепция в языке моделей. Например, концеп-
ция последовательной композиции языков отражается такой же  концеп-
цией в языке регулярных выражений.
   Обычно комбинаторная библиотека состоит из  " 1примитивов 0"  (базо-
вых,  неделимых сущностей предметной области, таких как "регулярное
выражение, распознающее один символ")  и  " 1комбинаторов 0"  (способов
комбинирования сущностей в более сложные).
   Среди комбинаторов выделяют:
 ш1.1
   (1)  _ 1комбинаторы  первого  порядка . 0,  позволяющие собирать сложные
сущности предметной области из простых (таких как, например, опера-
тор последовательной или параллельной композиции в регулярных выра-
жениях);
   (2)  _ 1комбинаторы высшего порядка . 0, позволяющие комбинировать дейс-
твия самих комбинаторов. Поэтому комбинаторные библиотеки легче пи-
сать и использовать в языках, поддерживающих функции высшего поряд-
ка.

 ш1.2
    2Пример 0 [Кирпичёв,2009,с.178].
 ш1.1
   Выражение комбинаторов  друг  через  друга на примере регулярных
выражений:
 ш1.0

   A? = A|();  A+ = AA*

 ш1.2
   Довольно часто комбинаторные библиотеки открыты для  расширения:
пользователь может определить свои собственные примитивы и комбина-
торы, равноправные встроенным в библиотеку (в случае регулярных вы-
ражений это не так).
   Как и у любой другой программы,  терминологическая основа комби-
наторной библиотеки  - это типы используемых в ней сущностей.  Типы
определяют, в частности,  в каком контексте уместны какие примитивы
и комбинаторы, и какие из них совместимы друг с другом. Так, логич-
но, что в случае комбинаторной библиотеки для описания потоков дан-
ных (например,  электронных схем) комбинатор "последовательная ком-
позиция блока с самим собой N раз" уместен только если типы входа и
выхода блока совпадают.
    _ 1Одно из современных "веяний" в типизации в комбинаторных библио-
 _ 1теках . 0 - использование GADT ( 1обобщённых алгебраических типов 0).
   Самое важное свойство,  за соблюдением  которого  следует  более
всего  следить при проектировании комбинаторной библиотеки -  _ 1свойс-
 _ 1тво замыкания . 0. Составные сущности не должны  1ничем 0 отличаться с точ-
ки зрения использования от атомарных, и должны быть допустимы в лю-
бом контексте, где допустима атомарная сущность.
   Нарушение свойства  замыкания делает язык не только сложнее (так
как становится необходимо различать простые и составные сущности  и
помнить, в каком контексте какие из них допустимы),  но и менее вы-
разительным из-за невозможности использовать некоторые  комбинаторы
в некоторых контекстах.  Более того,  это закрывает путь к развитию
концепции, навсегда ограничивая её рамками первоначального  замысла
создателя.
   Примеры нарушения этого свойства - типы в языке FORTRAN: FORTRAN
позволяет создавать массивы из примитивных типов,  однако не позво-
ляет создавать массивы из массивов (многомерные массивы -  не  уни-
версальное решение, т.к. они не позволяют использовать так называе-
мые "зубчатые" (jagged) массивы,  т.е. такие, чьи ячейки имеют раз-
ный размер).
   Часто от модели требуется возможность эффективной реализации.
   Например, при  моделировании  преобразований системы координат в
компьютерной графике часто ограничиваются так называемыми аффинными
преобразованиями (перенос,  поворот,  масштабирование,  отражение),
поскольку они допускают чрезвычайно эффективную программную и аппа-
ратную реализацию при помощи матричной арифметики, а также удовлет-
воряют свойству замыкания: последовательность аффинных преобразова-
ний  сама по себе является аффинным преобразованием.  Тем не менее,
легко представить себе ситуацию, когда требуются более сложные пре-
образования координат: скажем, рябь или другие нелинейные искажения
экрана.
   Почти всегда  имеет место компромисс между эффективностью реали-
зации и универсальностью.  Например,  регулярные выражения в  самом
простом случае можно эффективно реализовать при помощи компиляции в
конечный автомат; в более сложных языках регулярных выражений также
обычно стараются предоставить набор операторов,  допускающий эффек-
тивную реализацию.
   Особенно хорошо, когда примитивные сущности аналогичны составным
и с точки зрения эффективности.  Например, в случае аффинных преоб-
разований это  так:  любое преобразование представляется умножением
на матрицу,  и даже композиция тысячи преобразований  -  это  всего
лишь матрица, умножение на которую ничуть не сложнее, чем умножение
на матрицу поворота или отражения.  Та же ситуация  имеет  место  в
случае подмножества регулярных выражений, поддающегося реализации с
помощью конечных автоматов,  а также для многих часто встречающихся
классов грамматик более общего назначения.
   Однако этого удаётся достичь не всегда: например, в случае нели-
нейных преобразований точек ничего не остаётся, кроме как применять
композицию из  нескольких  преобразований  путём  последовательного
применения каждого  из них,  т.е.  композиция тысячи преобразований
будет, по меньшей мере,  в тысячу раз менее эффективна,  чем каждое
преобразование по отдельности.  Более того,  свои издержки вносит и
сама "инфраструктура" библиотеки;  стоит  проектировать  библиотеку
так, чтобы эти издержки были минимальны,  т.е. чтобы библиотека пе-
реносила "тяжёлые" операции в примитивы.
    _ 1Комбинаторные библиотеки . 0  - один из основных способов проектиро-
вания библиотек в функциональных языках.  Это объясняется тем,  что
функциональные языки  располагают  к составлению одних сущностей из
других, за счёт следующих свойств:
   (1) удобная  синтаксическая  поддержка создания сложных структур
данных;
   (2) поощрение неизменяемых данных,  что положительно сказывается
на модульности и комбинируемости;
   (3) обилие способов комбинирования - ФВП и замыкания;
   (4) очень мощные системы типов,  позволяющие удобно моделировать
терминологию предметной области.
   Одно из самых удачных применений комбинаторных библиотек (в  том
числе и за пределами функционального программирования) - это библи-
отеки для синтаксического анализа. Данный подход оказался настолько
хорош, что   _ 1портированные  комбинаторные библиотеки синтаксического
 _ 1разбора . 0 существуют для очень большого количества языков,  далеко не
только функциональных.
                22. 0  3Использование бесточечной нотации
                      3для частичного применения
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 5, Пример 6.
 ш1.2

              23. 0  3Бесточечное программирование в языке J

 ш1.0
                                 1Попугай долбил клювом прутья клетки
                                 1и ругался скверными словами.
                                      1Р.Л.Стивенсон. Остров Сокровищ
 ш1.2

   Бесточечный стиль используется в языках  семейства  APL,  в  том
числе языках программирования  3J 0 и  3K 0. Интересны и самобытны средства,
предоставляемые для "бесточечного" программирования в языке  3J 0,  где
подавляющее большинство функций принято определять "бесточечно".
   Язык  3J 0 вводит следующие понятия:
 ш1.1
   (1)  1монадные глаголы 0 (не путать с монадами из языка Haskell);
   (2)  1диадные глаголы 0  - это унарные и бинарные операции;
   (3)  1наречия 0  - это модификаторы,  применяемые к монаде или диаде
для образования новой;
   (4)  1вилки 0  и   1крючки 0 - это особые синтаксические комбинации нес-
кольких монад или диад, образующих вместе новую монаду или диаду.

 ш1.2
    2Пример 0 ( 1использования "вилки" 0).
 ш1.1
   Вычислим в языке  3J 0 арифметическое среднее:
 ш1.0

   avg = . +/ % #

 ш1.1
   Эта фраза читается как "среднее есть сумма,  делённая на длину",
и она образована "вилкой" из  1монады 0 суммирования списка
 ш1.0

   +/,

где / -  1наречие 0 свёртки,  1диады 0 деления % и  1монады 0 взятия длины #.

 ш1.2
    2Примеры 0 ( 1"вилок-ложек-крючков" языка 0  3J 0).
 ш1.0

    21. 0 f g x y   = (f g) x y;

    22. 0 f (g x) y = (.) f g x y = (f . g) x y;

    23. 0 f g (x y) = (.) (f g) x y = ((f g) . x) y = ((f g) .) x y;

    24. 0 f (g x y) = (.) f (g x) y = (.) ((.) f) g x y =
                                        ═└ 0─ ═┬ 0─ ═┘
                = ((f .) . g) x y = ((f .) . g) x y;

 ш1.1
    25. 0 Проведём преобразования для случая, когда связанными являются
переменные h и x:
 ш1.0

   f (g (h x)) = f ((.) g h x) = (.) f ((.) g h) x =
               = (.) ((.) f) ((.) g) h x = ((f .) . (g .)) h x

    _ 1Проверка . 0: ((f .) . (g .)) h x = (f .) ((g .) h) x =
               = (f .) (g . h) x = (f . (g . h)) x =
               = (.) f (g . h) x = f ((g . h) x) = f (g (h x)).

 ш1.1
   Проведём преобразования для случая,  когда  связанными  являются
переменные g и x:
 ш1.0

   f (g (h x)) = (.) f g (h x) = (.) ((.) f g) h x =
               = (.) (f . g) h x = flip (.) h (f . g) x =
                                    ═└ 0─── ═┬ 0──── ═┘
               = (. h) (f . g) x = (. h) ((f .) g) x =
               = (.) (. h) (f .) g x = ((. h) . (f .)) g x

    26. 0 ((. g) . f) x y = (. g) (f x) y = ((f x) . g) y =
                      = f x (g y)

    _ 1Проверка . 0: f x (g y) = (.) (f x) g y = flip (.) g (f x) y =
                                          ═└ 0─── ═┬ 0──── ═┘
                       = (. g) (f x) y = (.) (. g) f x y =
                       = ((. g) . f) x y

    27. 0 f (x g) y = (.) f x g y = flip ((.) f) g x y =
                = flip (f .) g x y

    28. 0 flip ((f .) .) g x y = ((f .) .) x g y = ((f .) . x) g y =
               = (.) (f .) x g y = (f .) (x g) y = (f .(x g)) y =
               = f ((x g) y) = f (x g y)

    _ 1Проверка . 0: f (x g y) = (.) f (x g) y = (.) ((.) f) x g y =
                       = (.) (f .) x g y = flip (.) x (f .) g y =
                       = (. x) (f .) g y =
                       = ((f .). x) g y = ((f .) .) x g y =
                       = flip ((f .) .) g x y

    29. 0 f x (g $ y) = (.) (f x) (g $) y =
                  = flip (.) (g $) (f x) y =
                  = (.) (flip (.) (g $)) f x y =
                          ═└ 0───── ═┬ 0────── ═┘
                  = (.) (. (g $)) f x y = ((. (g $)) . f) x y

 ш1.2
    3Замечание 0.
 ш1.1
   Стековые (или конкатенативные) языки (например,  FORTH) также по
своей сути располагают к бесточечному программированию.
 ш1.2

                2ПРИМЕРЫ РЕШЕНИЯ НЕКОТОРЫХ УПРАЖНЕНИЙ
    2Пример 0  21. 0 Демонстрация формальных преобразований  функций, запи-
санных на языке Haskell, с использованием комбинаторного исчисления
на примере вычисления значения функции
 ш1.0

   M x (P y z),

 ш1.2
где M 5(2) 0, P 5(2) 0 - функции 5  0(в круглых скобках указана арность).
    _ 1Решение . 0. Продемонстрируем по шагам этапы трансформации с помощью
комбинаторов  2B 0abc=a(bc),  2C 0abc=acb:
 ш1.0

   Mx(Pyz)=(Mx)((Py)z)   = 2B 0(Mx)(Py)z     =( 2B 0(Mx))(Py)z=
          =( 2BB 0Mx)(Py)z   =( 2BB 0M)x(Py)z    = 2C 0( 2BB 0M)(Py)xz=
          =( 2C 0( 2BB 0M)(Py))xz=( 2B 0( 2C 0( 2BB 0M))P)yxz= 2C 0( 2B 0( 2C 0( 2BB 0M))P)xyz.
 ш1.2

    2Пример 0  22. 0  Демонстрация формальных преобразований функций, запи-
санных на языке Haskell, с использованием комбинаторного исчисления
на примере вычисления значения функции
 ш1.0

   M x (P y),

 ш1.2
где M 5(2) 0, P 5(1) 0 - функции 5  0(в круглых скобках указана арность).
    _ 1Решение . 0. Продемонстрируем по шагам этапы трансформации с помощью
комбинаторов  2B 0abc=a(bc),  2C 0abc=acb:
 ш1.0

   Mx(Py)= 2C 0M(Py)x=( 2C 0M(Py))x=( 2B 0( 2C 0M)P)yx= 2C 0( 2B 0( 2C 0M)P)xy.
 ш1.2

    2Пример 0  23. 0  Демонстрация формальных преобразований функций, запи-
санных на языке Haskell, с использованием комбинаторного исчисления
на примере вычисления значения функции
 ш1.0

   M (P x) (Q y)

 ш1.2
где M 5(2) 0, P 5(1) 0, Q 5(1) 0 - функции 5  0(в круглых скобках указана арность).
    _ 1Решение . 0. Продемонстрируем по шагам этапы трансформации с помощью
комбинаторов  2B 0abc=a(bc),  2C 0abc=acb:
 ш1.0

   M(Px)(Qy)=(M(Px))(Qy)=( 2B 0MPx)(Qy)  =( 2B 0MP)x(Qy)=
            = 2C 0( 2B 0MP)(Qy)x= 2B 0( 2C 0( 2B 0MP))Qyx= 2C 0( 2B 0( 2C 0( 2B 0MP))Q)xy.

   Теперь, например, функцию

   fun:: Int -> Int -> Bool
   fun x y = (&&) (odd x) (even y)

 ш1.2
преобразуем с помощью функций flip (интерпретация комбинатора  C  в
Haskell) и  (.) (интерпретация комбинатора B в Haskell) к представ-
лению в виде комбинатора:
 ш1.0

   fun1:: Int -> Int -> Bool
   fun1 = flip ((.) (flip ((.) (&&) (odd))) (even))
 ш1.2

    2Пример 0  24. 0  Демонстрация формальных преобразований функций, запи-
санных на языке Haskell, с использованием комбинаторного исчисления
на примере функции
 ш1.0

   y x F

 ш1.2
где F 5(2) 0 - функция 5  0(в круглых скобках указана арность).
    _ 1Решение . 0. Продемонстрируем по шагам этапы трансформации с помощью
комбинаторов  2B 0abc=a(bc),  2C 0abc=acb:
 ш1.0

   yxF= 2C 0yFx=( 2C 0yF)x= 2CC 0Fyx=( 2CC 0F)yx= 2C 0( 2CC 0F)xy= 2BCCC 0Fxy.

 ш1.2
   Теперь напишем комбинатор,  вычисляющий сумму двух чисел, и про-
ведём вычисления:
 ш1.0

   f = (.) flip flip flip (+)  или  f = (flip . flip) flip (+)
   > f 3 4
   > 7
 ш1.2

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 1.
 ш1.0

 ш1.2

    2Пример 2.
 ш1.0

 ш1.2

    2Пример 3.
 ш1.0

 ш1.2

    2Пример 4.
 ш1.0

 ш1.2

    2Пример 5.
 ш1.0

 ш1.2

    2Пример 6.
 ш1.0

 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                       1"Не побоюсь, ей богу не побоюсь 0! 1" - сказал он
                       1и, очертивши по-прежнему около себя круг, на-
                       1чал припоминать все свои заклинания. 0
                                                     1Н.В.Гоголь. Вий
 ш1.2

    20. 0 (По [Анисимов,Пупышев,2006,с.287,№16.188])
   Найдите ошибки,  описки, неточности и прочие изъяны в данной ла-
бораторной работе.
                      21. 3 Вспомогательные задачи
    21. 0 (По [Кирпичёв,2009,с.93])
   Постройте следующие функционалы для работы с парами:
 ш1.1
   (1) по функции X 76 0Y постройте функцию с типом X 76 0(X,Y);
   (2) по функции X 76 0Y постройте функцию с типом (Z,X) 76 0(Z,Y);
   (3) по функции X 76 0Y постройте функцию с типом (X,Z) 76 0(Y,Z);
   (4) по функциям X 76 0Y и X 76 0Z постройте функцию с типом X 76 0(Y,Z);
   (5) по X постройте функцию с типом Y 76 0(X,Y);
   (6) по X постройте функцию с типом Y 76 0(Y,X);
   (7) по функции X 76 0Y постройте функцию с типом (Z,Y,X) 76 0(X,Y,Z).

    _ 1Указания . 0.

   (1) >t: \f x -> (x,f x)
       \f x -> (x,f x):: (a -> b) -> a -> (a,b);

   (2) >t: \f x u -> (fst u,f (snd u))
       \f x u -> (fst u,f (snd u))::(a -> b) -> c -> (d,a) -> (d,b);

   (3) >t: \f x u -> (f (fst u),snd u)
       \f x u -> (f (fst u),snd u)::(a -> b) -> c -> (a,d) -> (b,d);

   (4) >t: \f1 f2 x -> (f1 x,f2 x)
       \f1 f2 x -> (f1 x,f2 x)::(a -> b) -> (a -> c) -> a -> (b,c);

   (5) >t: \x y -> (x,y)
       \x y -> (x,y):: a -> b -> (a,b).

 ш1.2
    22. 0 Осуществите формальные преобразования к  комбинаторам  приве-
дённых ниже функций T 5(3) 0, F 5(3) 0, M 5(2) 0, Z 5(2) 0, P 5(2) 0, R 5(2) 0, 5  0S 5(1) 0, D 5(1) 0,
Q 5(1) 0 (в круглых скобках указана  1арность 0), написанных на Haskell:
 ш1.0

   (1) M x (P y z);    (4) M (P x y) z;

   (2) M x (Q y);      (5) T (Q x) y (S z);

   (3) M (D x) (Q y);  (6) F (P x y) (Z z w) (R s t).

 ш1.2
   Результаты проверьте с помощью интерпретатора Haskell,  подобрав
примеры под заданную арность функций  T 5(3) 0, F 5(3) 0, M 5(2) 0, Z 5(2) 0, P 5(2) 0,
R 5(2) 0, S 5(1) 0, D 5(1) 0, Q 5(1) 0.
    23. 0 Проверьте, правильно ли проведены следующие формальные преоб-
разования:
 ш1.0

           4?      ? 0                     ?
   (1) xFy=( 2I 0x)Fy= 2СI 0Fxy;  (2) g(fx)(fy)= 2C 0( 2B 0( 2C 0( 2B 0gf))f)xy.

 ш1.2
                22. 0  3Бесточечный стиль программирования
                          3на языке Haskell
    21. 0 Проверьте правильность преобразований в бесточечную форму:
 ш1.0

   (1) f $ g x y = f (g x y) = (.) f (g x) y = (.) ((.) f) g x y =
             = ((.) f).g x y = (. f) . g x y = (f .) . g x y;

   (2) f (x g y) = (.) f (x g) y = (.) ((.) f) x g y =
             = flip ((.) ((.) f)) g x y.

 ш1.2
    22. 0 Проверьте правильность преобразований из точечной формы запи-
си в бесточечную форму записи:
 ш1.0

   (а) f (g x y) = (.) f (g x) y = (.) ((.) f) g x y =
                 = (((.) f) . g) x y = ((f .) . g) x y;
                     ═└ 0── ═┬ 0── ═┘

   (б) (g x) (f y) = (.) (g x) f y = flip (.) f (g x) y =
                   = (.) (flip (.) f) g x y = (.) (. f) g x y=
                           ═└ 0─── ═┬ 0──── ═┘
                   = (. f) . g x y = ((. f) . g) x y;

   (в) f (g . x) y = f ((g .) x) y = (.) f (g .) x y =
                   = (f . (g .)) x y;

   (г) f (x . g) y = f ((. g) x) y = (.) f (. g) x y =
                   = (f . (. g)) x y;

   (д) g (id x) (f (id y)) =
                 = (.) ((g . id) x) ((f . id) y) =
                 = (.) (.) (g . id) x ((f . id) y) =
                 = (.) ((.) (.) (g . id) x) (f . id) y
                 = (.) (.) ((.) (.) (g . id)) x (f . id) y =
                 = flip ((.) (.) ((.) (.) (g . id))) (f . id) x y =
                 = flip ((.) . ((.) . (g . id))) (f . id) x y.

   (е) g (x (f y)) = (.) g x (f y) = (.) ((.) g x) f y =
                   = (g . x . f) y = g (x . f) y = g ((. f) x) y =
                   = (.) g (. f) x y = (g . (. f)) x y

 ш1.2
    23. 0 Проверьте правильность перевода в бесточечную форму записи:
 ш1.0

   (а) \x y -> x + 1                 => const . (1 +);
   (б) \x y -> sum (zipWith (*) x y) => (sum .) . zipWith (*);
   (в) \x y z -> f (g x y z)         => ((f .) .) . g;
   (г) \x y z -> f (g x y) z         => (f .) . g
 
 ш1.2
    24. 0 Проверьте правильность перевода следующих  7l 0-термов  (записан-
ных в синтаксисе языка Haskell) в бесточечную форму записи.
   Предварительно напомним названия комбинаторов в Haskell:
 ш1.0

   id ═+ 0I; (.) ═+ 0B; flip ═+ 0С; const ═+ 2K 0.

   (а) \x -> \y -> x y => id;

    _ 1Решение . 0. x y = id x y;

   (б) \x -> \y -> y x => flip id;

    _ 1Решение . 0. y x = id y x = flip id x y;

   (в) \x -> \y -> x + 1 => const . (flip (+) 1);

    _ 1Решение . 0. x + 1 = (+) x 1 = flip (+) 1 x = const (flip (+) 1 x) y=
                  = (.) const (flip (+) 1) x y =
                  = (const . (flip (+) 1)) x y;

   (г) \x -> \y -> sum (zipWith (*) x y) => (sum .) . zipWith (*);

    _ 1Решение . 0. sum (zipWith (*) x y) = (.) sum (zipWith (*) x) y =
              = (.) ((.) sum) (zipWith (*)) x y =
              = ((sum .) . (zipWith (*))) x y;

   (д) \x -> \y -> \z -> f (g x y z) => (((f .) .) .);

    _ 1Решение . 0. f (g x y z) = (.) f (g x y) z = (.) ((.) f) (g x) y z =
                        = (.) ((.) ((.) f)) g x y z =
                        = (.) ((f .) .) g x y z =
                        = (((f .) .) .) x y z;

   (е) \x -> \y -> \z -> f (g x y) z => (f .) . g;

    _ 1Решение . 0. f (g x y) z = (.) f (g x) y z = (.) ((.) f) g x y z =
                        = ((f .) . g) x y z

   (ж) \x -> \y -> \z -> f z (g x y) => (flip f .) . g;

    _ 1Решение . 0. f z (g x y) = flip f (g x y) z =
                        = (.) (flip f) (g x) y z =
                        = (.) ((.) (flip f)) g x y z =
                        = ((flip f .) . g) x y z

   (з) \x -> \y -> x : y : [] => flip ((.) . ((.) . (:))) (:);

    _ 1Решение . 0. x : y : [] = x : (y : []) = (:) x ((:) y []) =
                       = (.) ((:) x) ((:) y) [] =
                       = (.) (.) (:) x ((:) y) [] =
                       = (.) ((.) (.) (:) x) (:) y [] =
                       = (.) (.) ((.) (.) (:)) x (:) y [] =
                       = flip ((.) (.) ((.) (.) (:))) (:) x y [] =
                       = flip ((.) . ((.) . (:))) (:) x y [];

   (и) \f -> \h -> \g -> \x -> f x `h` g x =>
                      => flip ((.) ((.) ((.) ((.) (.) flip))) (.));

    _ 1Решение . 0. f x `h` g x = h (f x) (g x) = (h . f) x (g x) =
             = flip (h . f) (g x) x = (.) (flip (h . f)) g x x =
             = (.) (.) flip (h . f) g x x =
             = (.) (.) flip ((h .) f) g x x =
             = (.) ((.) (.) flip) (h .) f g x x =
             = (.) ((.) ((.) (.) flip)) ((.) h) f g x x =
             = (.) ((.) ((.) ((.) (.) flip))) (.) h f g x x =
             = flip ((.) ((.) ((.) ((.) (.) flip))) (.)) f h g x x;

   (к) \f -> \a -> \b -> \c -> \d -> f b c d a =>
                      => flip . ((flip . (flip .)) .);

    _ 1Решение . 0. f b c d a = flip (f b c) a d = (.) flip (f b) c a d =
                   = flip ((.) flip (f b)) a c d =
                   = flip (flip . f b) a c d =
                   = flip ((flip .) (f b)) a c d =
                   = (.) flip (flip .) (f b) a c d =
                   = (.) ((.) flip (flip .)) f b a c d =
                   = flip ((.) ((.) flip (flip .)) f) a b c d =
                   = (.) flip ((.) ((.) flip (flip .))) f a b c d =
                   = flip . ((.) (flip . (flip .))) f a b c d =
                   = flip . ((flip . (flip .)) .) f a b c d;

   (л) \x -> \y -> g (f x) (f y) => ((. f) . (g . f));

    _ 1Решение . 0. g (f x) (f y) = (g . f) x (f y) = (.) ((g . f) x) f y =
                 = flip (.) f ((g . f) x) y = (. f) ((g . f) x) y =
                 = (.) (. f) (g . f) x y = ((. f) . (g . f)) x y.

   Осуществим обратный перевод из бесточечной формы в аппликативную:

   ((. f) . (g . f)) x y = (. f) ((g . f) x) y =
                         = (g (f x) . f) y = (g (f x)) (f y) =
                         = g (f x) (f y);

   (м) \a -> \b -> \c -> a*b+2+c => (((((.) (+)) . (+)) .) . (*));

    _ 1Решение . 0. a*b+2+c = (+) ((+) ((*) a b) 2) c =
                    = (.) (+) ((+) ((*) a b)) 2 c =
                    = (.) ((.) (+)) (+) ((*) a b) 2 c =
                    = (.) ((.) ((.) (+)) (+)) ((*) a) b 2 c =
                    = (.) ((.) ((.) ((.) (+)) (+))) (*) a b 2 c =
                    = (((((.) (+)) . (+)) .) . (*)) a b 2 c.

 ш1.2
    25. 0 Определите по заданному  _ 1типу . 0 его бесточечное представление:
 ш1.0

   (1) (a -> b) -> (a -> c);  (2) (a -> b) -> a.

 ш1.2
    _ 1Указание . 0.
 ш1.0

   (2) (a -> b) -> a = (->) ((->) a b) a =
          = (.) (->) ((->) a) b a = (.) ((.) (->)) (->) a b a =
          = (.) ((->) (.)) (->) a b a = ((->) (.)) . (->) a b a

 ш1.2
    26. 0 Проверьте правильность преобразований  из  бесточечной  формы
записи в точечную форму записи:
 ш1.0

   (а) (((f .) . g) x) y = (f .) (g x) y = (f . (g x)) y =
                         = f (g x y);
   (б) (((. f) . g) x) y = (. f) (g x) y = ((g x) . f) y =
                         = (g x) (f y);
   (в) ((f . (g .)) x) y = f (g . x) y;
   (г) ((f .(. g)) x) y = f ((x . g) y)

 ш1.2
    27. 0 Постройте  по заданному бесточечному представлению функции её
представление с помощью композиции:
 ш1.0

   (1) flip ((f .) .) g;   (4) (. g) . f;
   (2) flip (f .) g;       (5) ((. h) . (f .)) g;
   (3) (. ($ g)) . f;      (6) ((f .) . g)

 ш1.2
    28. 0 Проверьте правильность перевода из бесточечной формы записи:
 ш1.0

   (а) const . (1 +)         => \e _ -> 1 + e;
   (б) (sum .) . zipWith (*) => \d g -> sum (zipWith (*) d g);
   (в) ((f .) .) . g         => \e j m -> f (g e j m);
   (г) (f .) . g             => (\d i -> f (g d i)).

 ш1.2
    29. 0 Переведите заданный  7l 0-терм в точечную форму записи:
 ш1.0

   (а) \(a,b) -> (b,a) => uncurry (flip (,));
   (б) \(a,b) -> a : b : [];
   (в) \f -> \(a,b) -> (f a, f b);
   (г) \f -> \g -> \(a,b) -> (f a, g b).

    _ 1Указание . 0. (а) (b,a) = (,) b a = flip (,) a b.

 ш1.2
    210. 0 Укажите семантику следующих функций в языке Haskell:
 ш1.0

   (а) t1 = elem 5
       t2 = foldr (||) False . map (== 5)
       t3 = flip ((.) ((.) (flip (foldr (||)))) map (==15)) False

   (б) w = \x -> \y -> x y y
       f = w ((.) (flip ((.) (+) ((*) 2))) ((*) 3))

   (в) import List
       ddd (x:xs) =
           (flip ((.) ((.) ((.) (.) flip) ((.) (:))) (:)) tails)
                                                            x xs xs

 ш1.2
    211. 0 Проверьте правильность перевода из бесточечной записи в бес-
точечную:
 ш1.0

   f (. g) = ((f .) . flip) (.) g

 ш1.2
                23. 3 Построение коммутативных диаграмм
                   3по заданной бесточечной записи
    21. 0 Постройте  1коммутативную диаграмму 0 по бесточечной записи:
 ш1.0

   (1) flip ((.) (flip ((.) (&&) (odd))) (even));
   (2) (.) flip flip flip (+).

 ш1.2
    22. 0 Постройте  1коммутативную диаграмму 0 по аппликативной записи:
 ш1.0

   (1) f (g (h x));  (2) g x (f x);  (3) f (g x y) z.

 ш1.2
    _ 1Указание . 0.
 ш1.0

   (1) f (g (h x))=(.) f g (h x)=(.)((.) f g) h x=

          =((f . g) . h) x=(((f .) g) . h) x=(. h) (f . g) x

                1f
   a ∙───────────────── 76 0∙ b
      7% ═\ 0                 │
    g│  ═\ 0                │
     │   ═\ 0               │
     │    ═K 0     ( 1f 0 .)     7^
   c ∙─── 76 2∙ 0════════════> 2∙ 0 c->b ( 1значение функции 0 ((f .) g))
      7% ═\ 0 c->a            │
     │  ═\ 0                │
    h│   ═\ 0               │
     │    ═K 0 (((f .) g) .) 7^
   d ∙──── 2∙ 0════════════> 2∙ 0  2d->b 0 ( 1значение функции 0 ((f .) g) . h)
         d->c

   Таким образом, тип функции

   ((f .) g) . h :: (a -> b) -> (c -> a) -> (d -> c) -> d -> b

               1h 0         c    c->a  ( 1f 0 .)   c->b
   d ∙───────────────── 76 0∙──── 76 0∙════════════> 2∙ 0   ( 1значение функции
     │                  │ 4└ 0─── ═J 0───── 4┐ 0         7% 0    ((f .) g))
     │                 g│    ═/ 0      │        │
     │                  │   ═/ 0        4└ 0─────── 4┐ 0│
     │                  │  ═/ 0      ((f .) g))││
     │                   7^ ═/ 0                  7^ 0│
     │                a ∙────────────────── 76 0∙ b
      7^ 0      (. h)        7^ 0                    7^
      2∙ 0<═════════════════∙ 75 0──────────────────∙ b
    2d->b 0               c->b
   ( 1значение функции
   (. h) (f . g))

   Таким образом, тип функции

   (. h) (f . g) :: (a -> b) -> (c -> a) -> (d -> c) -> d -> b

 ш1.2
    23. 0 Постройте  1коммутативную диаграмму 0  по  представлению  в  виде
композиции:
 ш1.0

   f . g . h . k.
 ш1.2
