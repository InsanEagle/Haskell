   -- Демонстрация:
   --  (1) моделирования комбинатора неподвижной точки с по-
   --      мощью функционала foldr, т.е. в foldr-стиле;
   --
   --  (2) моделирования комбинатора неподвижной точки с по-
   --      мощью функционала foldl, т.е. в foldl-стиле;
   --
   --  (3) моделирования комбинатора неподвижной точки с по-
   --      мощью функционалов foldr  и unfold, т.е. в  fold-
   --      unfold-стиле;
   --
   --  (4) использования  комбинатора неподвижной точки  для
   --      моделирования рекурсивных вычислений по теореме о
   --      неподвижной  точке: для любого лямбда-терма F вы-
   --      полняется x=Fx => x=YF
   -- **************************************************
   -- Функция, моделирующая функционал unfold на списках
   -----------------------------------------------------
   unfold p f g x | p x  = [] 
                  | True = f x : unfold p f g (g x)

   -- **************************************************
   -- Функция, моделирующая комбинатор неподвижной точки
   -- по определению Yf=f(Yf)
   -- (для стратегии  э н е р г и ч н ы х  вычислений)
   ---------------------------------------------------
   y f = f (y f)

   -- **************************************************
   -- Функция, моделирующая комбинатор неподвижной точки
   -- по определению Yf=f(\x.Yfx)
   -- (для стратегии  о т л о ж е н н ы х  вычислений)
   ---------------------------------------------------
   y' f = f (\x -> y' f x)

   -- ***************************************************
   -- Функции, моделирующие комбинатор неподвижной точки.
   -- Авторы: B.Pope (2007), В.Брагилевский (2010)
   -----------------------------------------------
   fix g = foldr f e (repeat undefined)              
       where f = \_ -> g
             e = undefined                           -- foldr-стиль
   ------------------------
   fix' g = foldr f e [1..]                          
       where f = \_ -> g
             e = undefined                           -- foldr-стиль

   -- ***************************************************
   -- Функция, моделирующая комбинатор неподвижной точки.
   -- Автор: А.Холомьев (2012)
   ---------------------------
   fix'' = foldr f e . repeat                -- "Почти" foldr-стиль
       where f = ($)
             e = undefined

   -- ***************************************************
   -- Функция, моделирующая комбинатор неподвижной точки. 
   -- Числовой список [1..10000] подбирается  эмпирически
   -- для каждой рекурсивной функции, с  помощью  которой
   -- построена функция g (нерекурсивная "заготовка").
   --
   -- Автор: И.А.Кудрявцева (14.11-15.11.2015)
   -------------------------------------------
   fix''' g = foldl f e [1..10000]                   
       where f = \x _ -> g x
             e = undefined                           -- foldl-стиль

   -- **************************************************
   -- Функция, моделирующая комбинатор неподвижной точки
   -- Y с помощью функционала unfold.
   -- Числовой список [1..10000] подбирается  эмпирически
   -- для каждой рекурсивной функции, с  помощью  которой
   -- построена функция g (нерекурсивная "заготовка").
   --
   -- Автор: И.А.Кудрявцева, М.В.Швецкий (ноябрь, 2015)
   -------------------------------------------------------
   fix'''' g = last $ [e] ++ unfold p f' g' ([1..10000],e)  
       where f  = \x _ -> g x
             e  = undefined
             p  = \(x,y) -> null x
             f' = \(x,y) -> f y (head x)
             g' = \(x,y) -> (tail x, f' (x,y))      -- unfold-стиль

   -- **************************************************
   -- Функция, моделирующая комбинатор неподвижной точки
   -- в fold-unfold-стиле.
   -- Аргумент функции - это нерекурсивная "заготовка"
   ---------------------------------------------------
   fix''''' = foldr f e . unfold p f1 g1        
       where f = ($)
             e  = undefined
             p  = \x -> False
             f1 = id
             g1 = id                          -- foldr-unfold-стиль

   -- ****************************************************
   -- Для тестирования  комбинатора неподвижной точки  fix
   -- выполним следующие действия:
   --  (1) выберем в качестве функции F функционал foldr':
   --
   --   foldr':: (a -> b -> b) -> b -> [a] -> b
   --   foldr' f e []     = e
   --   foldr' f e (x:xs) = x `f` foldr' f e xs
   --
   --  (2) по функционалу foldr' построим функционал foldr'',
   --      который является нерекурсивной "заготовкой"
   --      (см. код ниже);
   --  (3) теперь для вычисления значения foldr f e lst ос-
   --      таётся набрать:
   --
   --   > fix foldr'' f e lst
   --------------------------
   foldr'' f1 f e []     = e
   foldr'' f1 f e (x:xs) = x `f` f1 f e xs

   -- ******************************************************
   -- Для тестирования комбинатора неподвижной точки fix вы-
   -- полним следующие действия:
   --  (1) выберем в качестве функции F функционал foldl':
   --
   --   foldl':: (b -> a -> b) -> b -> [a] -> b
   --   foldl' f e []     = e
   --   foldl' f e (x:xs) = foldl' f (e `f` x) xs
   --
   --  (2) по функционалу foldl' построим функционал foldl'',
   --      который является нерекурсивной "заготовкой"
   --      (см. код ниже);
   --  (3) теперь для вычисления значения foldl f e lst оста-
   --      ётся набрать:
   --
   --   > fix foldl'' f e lst
   --------------------------
   foldl'' f1 f e []     = e
   foldl'' f1 f e (x:xs) = f1 f (e `f` x) xs

   -- *******************************************************
   -- Функция, моделирующая с помощью комбинатора неподвижной
   -- точки функцию cycle языка Haskell, которая конструирует
   -- бесконечный циклический список
   -- (два способа представления) 
   --------------------------------------
   cycle'  = \xs -> fix'' (\f -> xs ++ f)
   cycle'' = fix'' (\f xs -> xs ++ f xs)

   -- ***************************
   -- Неудачные тестовые примеры:
   -----------------------------------------------------------------
   test1 = y        foldr'' (+) 0 [1..1120] == foldr (+) 0 [1..1120]
   test2 = y'       foldr'' (+) 0 [1..1120] == foldr (+) 0 [1..1120]
   test3 = fix      foldr'' (+) 0 [1..1120] == foldr (+) 0 [1..1120]
   test4 = fix'     foldr'' (+) 0 [1..1120] == foldr (+) 0 [1..1120]
   test5 = fix''    foldr'' (+) 0 [1..1120] == foldr (+) 0 [1..1120]
   test6 = fix'''   foldr'' (+) 0 [1..1120] == foldr (+) 0 [1..1120]
   test7 = fix''''  foldr'' (+) 0 [1..1120] == foldr (+) 0 [1..1120]
   test8 = fix''''' foldr'' (+) 0 [1..1120] == foldr (+) 0 [1..1120]
   -----------------------------------------------------------------
   test9  = fix'   (\f n -> if n==0 then 1 else n * f (n-1)) 3988
   test10 = fix''' (\f n -> if n==0 then 1 else n * f (n-1)) 3990 
   -----------------------------------------------------------------
   test11 = y       foldl'' (+) 0 [1..1120] == foldl (+) 0 [1..1120]
   test12 = y'      foldl'' (+) 0 [1..1120] == foldl (+) 0 [1..1120]
   test13 = fix     foldl'' (+) 0 [1..1120] == foldl (+) 0 [1..1120]
   test14 = fix'    foldl'' (+) 0 [1..1120] == foldl (+) 0 [1..1120]
   test15 = fix''   foldl'' (+) 0 [1..1120] == foldl (+) 0 [1..1120]
   test16 = fix'''  foldl'' (+) 0 [1..1120] == foldl (+) 0 [1..1120]
   test17 = fix''' (\f (_:xs) -> xs) [1..1000]
   test18 = fix'''' foldl'' (+) 0 [1..1120] == foldl (+) 0 [1..1120]
   test19 = fix''''' foldl'' (+) 0 [1..1120]== foldl (+) 0 [1..1120]
   test20 = fix''''' (\f x -> x + 1) 1000
   --------------------------------------------------------------
   test21 = map (fix'' (\f n -> if n==0 then 1 else n * f (n-1)))
                [1..20]
   test22 = map (fix''''' (\f n -> if n==0 then 1 else n * f (n-1)))
                [1..20] == map (\x -> product [1..x]) [1..20]
   -------------------------------------------------------------
   test23 = take 20 (cycle'  [1,2,3]) == take 20 (cycle [1,2,3])
   test24 = take 20 (cycle'' [1,2,3]) == take 20 (cycle [1,2,3])
