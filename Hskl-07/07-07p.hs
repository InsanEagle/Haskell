   -- Демонстрация программирования в стиле оригами, т.е.
   -- программирование в следующих стилях:
   --
   --   foldr-, foldl-, fold-unfold-, unfold-unfold-
   --
   -- *****************************
   -- Реализация функционала unfold
   --------------------------------
   unfold p f g x | p x  = [] 
                  | True = f x : unfold p f g (g x)

   -- **********************************
   -- Функция, конструирующая композицию
   --
   -- (g . g . ... . g) (n раз)
   --
   -- по заданной функции g и натуральному n
   ---------------------------------------------
   res g n x = foldr f e (replicate n undefined)
        where f = \_ y -> g y 
              e = x                                  -- foldr-стиль

   -- ******************************
   -- Реализация функции "факториал"
   ---------------------------------
   fact    n = foldr (*) 1 [1..n]                    -- foldr-стиль
   ----------------------------------------------
   fact'     = foldr (*) 1 . unfold (==0) id pred

                                              -- foldr-unfold-стиль
   ----------------------------------------------------------------
   fact''  n = (foldr (*) 1 . unfold (>n) id succ) 1

                                       -- "Почти" fold-unfold-стиль
   ----------------------------------------------------------------
   fact''' n = (.) ((.) ((.) ((.) (foldr (*) 1)))) 
                                  unfold (>n) id succ 1

                                          -- Нераспознаваемый стиль
   ----------------------------------------------------------------
   fact'''' n = (((((foldr (*) 1) .) .) .) .)
                                  unfold (>n) id succ 1

                                       -- "Почти" fold-unfold-стиль

   -- *******************************************
   -- Реализация функции, удаляющей все вхождения
   -- заданного элемента x из списка lst
   -------------------------------------
   deleteAll x = foldr f e                          
        where f = \y ys -> if (/= x) y               -- foldr-стиль
                             then y : ys 
                             else ys
              e = []

   -- *************************************
   -- Реализация функции, возвращающей пару
   -- (Сумма элементов списка, Длина списка)
   -----------------------------------------
   sumLen = foldr f e                                -- foldr-стиль
        where f = \n (x,y) -> (x + n, y + 1)
              e = (0,0)

   -- ************************************************
   -- Реализация функции, возвращающей  для  заданного
   -- числового списка тройку
   -- (Сумма элементов, Произведение элементов, Длина)
   ----------------------------------------------------
   sumProdLen :: [Integer] -> (Integer,Integer,Integer)
   sumProdLen = foldr f e 
        where f = \x (a,b,c) -> (x + a, x * b, c + 1)
              e = (0,1,0)
                                                     -- foldr-стиль

   -- **************************************************
   -- Реализация с помощью свёртки foldl конструирования
   -- p-ичного натурального числа  по  заданному  списку
   -- его цифр из {0,1,...,p-1}
   ----------------------------
   num2dec p = foldl f e                             -- foldl-стиль  
        where f = \a b -> p * a + b
              e = 0
   ----------------------------------------------
   num2dec' p = foldr f e . unfold null last init  
        where f = \a b -> p * b + a         
              e = 0                           -- foldr-unfold-стиль

   -- *****************************************
   -- Функция возвращает строку битов заданного
   -- положительного числа n
   ----------------------------------
   toBin = foldl f1 e . unfold p f2 g          
        where f1 = flip (:)
              e  = []
              p  = \x -> x==0
              f2 = \x -> intToDigit $ mod x 2
              g  = \x -> div x 2              -- foldl-unfold-стиль

   -- *************************************************
   -- Функция конструирует список битов двоичного пред-
   -- ставления  натурального числа, заданного  в  виде
   -- строки десятичных цифр.
   --
   --  Пример: "15" => [1,5] => 15 => [1,1,1,1]
   --------------------------------------------
   dec2bin x = (unfold null last init .     
                unfold (<=0) (`rem` 2) (`div` 2))
                       (num2dec' 10 (map digitToInt x))

                                     -- "Почти" unfold-unfold-стиль
   ----------------------------------------------------------------
   dec2bin' x = (((                  
                   (
                    unfold null last init .                       
                    unfold (<=0) (`rem` 2) (`div` 2)
                   ) . (num2dec' 10)
                  )
                 ) . (map digitToInt)
                ) x                  -- "Почти" unfold-unfold-стиль

   -- **********************************************
   -- Функция, возвращающая частичную сумму ряда для
   -- функции exp(x) при x=1 (n - количество  членов
   -- ряда).
   --   Для реализации использовано представление:
   --
   -- exp' n = foldr (+) 0 (map ((1/) . fact) [0..n])
   --
   ----------------------------------------------------------
   exp' = foldr (+) 0 . unfold null ((1/) . fact . head) tail
                      . per
        where per n = if n==0
                        then [0]
                        else per (n-1) ++ [n]

                                      -- "Почти" foldr-unfold-стиль

   -- ***********************************************
   -- Функция "реверсирует" список индексов элементов
   -- заданного списка
   ----------------------------------------
   lstRevIndex = unfold p f2 g . foldr f1 e
      where p  = (==0)
            f2 = id
            g  = pred
            f1 = \_ x -> x + 1
            e  = 0

   -- ***************************
   -- Неудачные тестовые примеры:
   -------------------------------------------------------
   test1 f  = (res f 5 100, last $ take 6 $ iterate f 100)
   test2 n  = (fact n,fact' n,fact'' n,fact''' n)
   test3    = map (\n -> fact n == product [1..n]) [1..1000]
   test4    = deleteAll 3 [3,2,4,5,3,6,7] == [2,4,5,6,7]
   test5    = map (\x -> exp' x - exp 1) [1..20]
   ---------------------------------------------------
   test6    = num2dec   2 [1,1,0,0,1,0,0]       == 100
   test7    = num2dec'  2 [1,1,0,0,1,0,0]       == 100
   test8    = num2dec  10 [1,2,3,4,5,6,7,8,9,0] == 1234567890 
   test9    = num2dec' 10 [1,2,3,4,5,6,7,8,9,0] == 1234567890
   test10 x = (num2dec' 2 (dec2bin  x), x)
   test11 x = (num2dec' 2 (dec2bin' x), x)
   test12   = toBin 1337 == "10100111001"
   test13   = (sumProdLen [1..6], sumProdLen [6])
   test14   = lstRevIndex [1,3..15] == [8,7..1]
