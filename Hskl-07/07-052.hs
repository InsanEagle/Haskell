   -- Демонстрация функционала "развёртка" unfold  на
   -- списках и его использования для Haskell-оригами
   --
   -- (в т о р о й  и  т р е т и й  варианты реализа-
   -- ции unfold)
   -- ***********
   import List

   -- **************************************************
   -- Функция, моделирующая функционал unfold на списках
   -- (список порождается, пока  не  выполнится  условие
   -- (p x); при этом
   --
   --   fg = \x -> (f x, g x),
   --
   -- где элементы списка  образует функция f, а началь-
   -- ный элемент x преобразуется функцией g)
   --
   -- (в т о р о й  вариант реализации)
   -------------------------------------------------
   unfold':: (a -> Bool) -> (a -> (b,a)) -> a -> [b] 
   --            p                 f g      x
   ------------------------------------------
   unfold' p fg x | p x  = []
                  | True = fx : unfold' p fg gx
         where (fx,gx) = fg x

   -- **********************************************
   -- Функция возвращает список вида [n,n-1,...,2,1]
   -------------------------------------------------
   downfrom = unfold' p fg                          
        where p    = (== 0)
              fg x = (id x, pred x)                 -- unfold-стиль

   -- *********************************
   -- Функция реализует функцию reverse
   ------------------------------------
   reverse' = unfold' p fg                          
        where p    = null              
              fg x = (last x, init x)               -- unfold-стиль

   -- *****************************
   -- Функция реализует функцию zip
   -----------------------------------------
   zip' lst1 lst2 = unfold' p fg (lst1,lst2)        
        where p (lst1,lst2)  = null lst1 || null lst2
              fg (a:as,b:bs) = ((a,b),(as,bs))     
                                                    -- unfold-стиль

   -- ********************************
   -- Функция реализует функционал map
   -----------------------------------
   map' f = unfold' p fg                            
        where p    = null 
              fg x = ((f . head) x, tail x)         -- unfold-стиль

   -- ************************************
   -- Функция реализует функционал iterate
   ---------------------------------------
   iterate' f = unfold' p fg
        where p    = \x -> False
              fg x = (x, f x)                       -- unfold-стиль

   -- ******************************************
   -- Функция, моделирующая функционал unfold на
   -- списках
   -- (т р е т и й  вариант реализации)
   ----------------------------------------------
   unfold'' :: (b -> Either () (a,b)) -> b -> [a]
   unfold'' pfg x = case pfg x of
                      Left  ()    -> []
                      Right (a,y) -> a : unfold'' pfg y

   -- ***************************
   -- Неудачные тестовые примеры:
   ------------------------------
   test1   = downfrom 23
   test2   = reverse' [1..20] == reverse [1..20]
   test3   = map' (^2) [1..20]
   test4   = zip' [1..4] [1..7] == zip [1..4] [1..7]
   test5 x = take 10 $ iterate' (^2) x
