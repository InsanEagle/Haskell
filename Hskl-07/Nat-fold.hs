   -- Демонстрация оригами-программирования
   -- на натуральных числах
   -- ***********************
   data Nat = Zero | Succ Nat

   -- *****************************
   -- Функции для натуральных чисел
   ---------------------------------------------------------
   (zero : one : two : three : four : five : six: seven : _)
                                 = iterate Succ Zero
   -------------------------------------------------
   test1 = int . abc

   -- *************************************************
   -- Перевод вида: zero -> 0, one -> 1,..., seven -> 7
   ----------------------------------------------------
   int:: Nat -> Integer
   int = iter 0 (1 +)

   -- *****************************************************
   -- Перевод вида: 0 -> zero, 1 -> one,..., 7 -> seven,...
   --------------------------------------------------------
   abc:: Int -> Nat
   abc n = iterate Succ Zero !! n

   -- ******************************
   -- Визуализация натуральных чисел
   ---------------------------------
   instance Show Nat 
      where show = show . int

   -- *************************
   -- Проверка "на равенство 0"
   ----------------------------
   isZero :: Nat -> Bool
   isZero = foldNat True (const False)

  {-
   Посмотрим как вычисляется эта функция:

   isZero Zero => True -- заменили конструктор Zero

   isZero (Succ (Succ (Succ Zero)))
     => const False (const False (const False True)) => False
                       -- заменили и Zero и Succ
     
   За счёт ленивых вычислений на самом деле во втором выражении
   произойдёт лишь одна замена. Мы не обходим всё дерево, это и
   не нужно, а смотрим лишь на  первый конструктор, если  там -
   Succ, то произойдёт замена на постоянную функцию, которая иг-
   норирует свой второй аргумент и рекурсивного вызова  функции 
   свёртки не произойдёт, совсем как в исходном определении!
  -}

   -- **************
   -- Чётность числа
   -------------------
   even':: Nat -> Bool
   even' = foldNat True not
   ------------------------
   test2 n = even' (abc n)

   -- ****************
   -- Нечётность числа
   -------------------
   odd' :: Nat -> Bool
   odd' = foldNat False not

   -- **************************
   -- Итерация (нумерация Чёрча)
   -----------------------------
   iter z s  Zero    = z
   iter z s (Succ n) = s (iter z s n)

   -- ***********************
   -- Арифметические операции
   --------------------------
   plus n = iter n Succ
   mult n = iter Zero (plus n)
   ---------------------------
   test3 = plus two two 
   test4 = mult two seven

   -- *****************************
   -- Свёртка на натуральных числах
   ---------------------------------
   foldN:: a -> (a -> a) -> Nat -> a
   foldN z s Zero     = z
   foldN z s (Succ n) = s (foldN z s n)
   ------------------------------------
   test5 = foldN Zero id (Succ five)

   -- *******************************************************
   -- Обратите внимание на рекурсивный вызов foldNat: обходим 
   -- всё дерево значения, заменяя каждый конструктор
   --------------------------------------------------
   foldNat :: a -> (a -> a) -> (Nat -> a)
   foldNat zero succ = \n -> case n of
                              Zero -> zero
                              Succ m -> succ (foldNat zero succ m)

   -- ************************************
   -- Выражение итерации с помощью свёртки
   ---------------------------------------
   iter':: Nat -> (a -> a) -> (a -> a)
   iter' n f x = foldN x f n

   -- ***************************************************
   -- Выражение арифметических операций с помощью свёртки
   ------------------------------------------------------
   add :: Nat -> Nat -> Nat
   add a = foldNat a Succ
   ------------------------
   mul :: Nat -> Nat -> Nat
   mul a = foldNat Zero (add a)

   -- *******************************
   -- Развёртка на натуральных числах
   ---------------------------------------------
   unfoldN:: (a -> Bool) -> (a -> a) -> a -> Nat
   unfoldN p f x = if p x
                     then Zero 
                     else Succ (unfoldN p f (f x)) 
   --------------------------------------------------------
   test6 = unfoldN (\x -> int x > int five) (plus two) zero

   -- ********************
   -- Примитивная рекурсия
   ------------------------
   primrec z s  Zero    = z
   primrec z s (Succ n) = s n (primrec z s n)

   -- ***************************************
   -- Вычисление значения функции "факториал"
   ------------------------------------------
   fac  = primrec one (mult . Succ)
   fac' = snd . iter (one, one) 
                     (\(a,b) -> (Succ a, mult a b))
   ------------------------------------------------
   test7 = (fac five, fac' five)
