   -- Демонстрация моделирования функций и функционалов
   -- языка Haskell на списках с помощью свёртки foldl 
   -- ************************************************

   -- *********************
   -- Реализация функции id
   ------------------------
   id' :: [a] -> [a]
   id' = foldl (\x y -> x ++ [y]) []                -- foldl-стиль

   -- *******************************************
   -- Реализация функционала "композиция функций"
   -- (функции содержатся в списке аргументов)
   -------------------------------------------
   comp :: [a -> a] -> a -> a
   comp = foldl f e                                 
        where f = flip (.)
              e = id                                -- foldl-стиль

   -- **********************
   -- Реализация функции sum
   -------------------------
   sum' = foldl (+) 0                               -- foldl-стиль

   -- **************************
   -- Реализация функции product
   -----------------------------
   product' = foldl (*) 1                           -- foldl-стиль

   -- **********************
   -- Реализация функции not
   -------------------------
   not' a = foldl f e [a]                             
        where f = (\x y -> if y then False else True)
              e = True
                                                    -- foldl-стиль

   -- ***************************************
   -- Реализация логических операций and и or
   ------------------------------------------
   and' = foldl (&&) True                           -- foldl-стиль
   or'  = foldl (||) False                          -- foldl-стиль

   -- ************************
   -- Реализация операции elem
   ---------------------------
   elem' x = foldl f e
        where   f = \z y -> if y==x then True else z
             -- f = \z y -> (y==x) || z
             -- f = flip ((||) . (x ==))
                e = False                           -- foldl-стиль

  --------------------------------------------------------
  -- Преобразуем функцию f эквивалентным образом с помощью
  -- комбинатора (.) и этта-редукции:
  --
  -- (1) f = \z y -> if y==x then True else z =
  --       = \z y -> (y==x) || z;
  --
  -- (2) \z y -> (y==x) || z = \z y -> (||) (x == y) z =
  --       = \z y -> (.) (||) (x ==) y z =
  --       = \z y -> flip ((||) . (x ==)) z y =
  --       = flip ((||) . (x ==))
                                                    
   -- ************************************
   -- Реализация функций maximum и minimum
   ---------------------------------------
   maximum':: Ord a => [a] -> a
   maximum' = foldl1 max                            -- foldl1-стиль
   ----------------------------
   minimum':: Ord a => [a] -> a
   minimum' = foldl1 min                            -- foldl1-стиль

   -- *************************
   -- Реализация функции length
   ---------------------------------
   length' = foldl (\x _ -> x + 1) 0                -- foldl-стиль

   -- ***********************
   -- Реализация функции head
   --------------------------
   head' = foldl1 const                             -- foldl1-стиль

   -- ************************
   -- Реализация функции tail.
   -- Автор: Е.С.Буракова, И.С.Моисеев (29.02.2016)
   ------------------------------------------------
   tail' = foldl f e [1]                            
        where f _ _ (_:xs) = xs
              e            = undefined              -- foldl-стиль

   -- **************************
   -- Реализация функции reverse
   -----------------------------
   reverse' = foldl f e
        where   f = \ys x -> x : ys
             -- f = flip (:)
                e = []                              -- foldl-стиль

   ----------------------------------------------
   -- Преобразуем первое представление во второе,
   -- воспользовавшись этта-редукцией:
   --
   --  \ys x -> x : ys = \ys x -> (:) x ys = 
   --                  = \ys -> (\x -> flip (:) ys x) =
   --                  = \ys -> flip (:) ys = flip (:)

   -- *************************
   -- Реализация операции (++).
   -- Автор: М.В.Швецкий (27.02.2016)
   ----------------------------------
   (++~) = foldl f e [1..50000]                      
        where f g _ []     z = z         
              f g _ (x:xs) z = x : g xs z
              e              = undefined            -- foldl-стиль

   -- ************************
   -- Реализация операции (++)
   --------------------------------------
   (++~~) xs ys = foldl f e (reverse' xs)
        where   f = \x y -> y : x
             -- f = flip (:)
                e = ys                        -- foldl-foldl-стиль

   -------------------------------------
   -- Обоснуем преобразование функции f:
   --
   -- \x y -> y : x = \x y -> (:) y x = \x y -> flip (:) x y =
   --               = \x -> (\y -> flip (:) x y) = 
   --               = \x -> flip (:) x = flip (:)

   -- *************************
   -- Реализация функции concat
   ----------------------------
   concat' = foldl (++) []                          -- foldl-стиль

   -- ************************
   -- Реализация функции last.
   -- Автор: С.Довжиков (1 курс, ИС, 10.11.2015)
   ---------------------------------------------
   last'  = foldl f e            
        where   f = flip const
             -- f = \x y -> y
                e = undefined                       -- foldl-стиль

   -- ************************
   -- Реализация функции last.
   -- Автор: М.Алибеков (3 курс, ИС, 2015)
   ---------------------------------------
   last''' = foldl1 (const id)                      -- foldl1-стиль

   -- ************************
   -- Реализация функции init.
   -- Автор: М.В.Швецкий (27.02.2016)
   ----------------------------------
   init' = foldl f e [1..1000] 
        where f _ _ [_]    = []      
              f h _ (x:xs) = x : h xs
              e            = undefined              -- foldl-стиль

   -- ***********************************
   -- Реализация функции take с использо-
   -- ванием  к о н т е к с т а.
   -- Автор: И.А.Кудрявцева (21.10.2015)
   -------------------------------------
   take' n lst = snd $ foldl f e lst                
        where f = \(num,x) xs -> if num==0
                                   then (num, x)
                                   else (num - 1, x ++ [xs])
              e = (n,[])
                                                    -- foldl-стиль

   -- **************************************************
   -- Реализация функции drop, возвращающей список  эле-
   -- ментов исходного списка, начиная с n-ого  элемента
   -- (нумерация элементов списка начинается с 0).
   -- Используется  к о н т е к с т.
   --
   -- Автор: И.А.Кудрявцева (21.10.2015)
   -------------------------------------
   drop' n lst = snd $ foldl f e lst                
        where f = \(num,x) xs -> if num == n 
                                   then (num, x ++ [xs])
                                   else (num + 1, x)
              e = (0,[])
                                                    -- foldl-стиль

   -- **********************
   -- Реализация функции zip
   --------------------------------------------
   zip' l1 l2 = foldl f e [1..1+max (length l1)
                                    (length l2)] l1 l2                  
        where f _ _ _  []         = []               
              f _ _ [] _          = []              
              f h _ (x:xs) (y:ys) = (x,y) : h xs ys 
              e                   = undefined       -- foldl-стиль

   -- ************************
   -- Реализация функции unzip
   -----------------------------------------------------
   unzip' = foldl (\(a,b) (c,d) -> (a ++ [c], b ++ [d]))
                  ([],[])                           
                                                    -- foldl-стиль

   -- **************************
   -- Реализация функционала map
   -----------------------------
   map' g = foldl f e                              
        where f = \x y -> x ++ [g y]
              e = []                                -- foldl-стиль

   -- ********************************
   -- Реализация функционала concatMap
   --------------------------------------
   concatMap' :: (a -> [b]) -> [a] -> [b]            
   concatMap' g = foldl f e
        where f = \x y -> x ++ g y 
              e = []                                -- foldl-стиль

   -- *****************************
   -- Реализация функционала filter
   ----------------------------------
   filter' g = foldl (\xs x -> if g x
                                 then xs ++ [x]
                                 else xs)
                     []                             -- foldl-стиль

   -- *****************************
   -- Реализация функционала foldr.
   -- Автор: И.А.Кудрявцева, М.В.Швецкий (02.03.2016)
   --------------------------------------------------
   foldr' = foldl f e [1..500]                   
        where f _ _ _ e []     = e               
              f h _ g e (x:xs) = g x (h g e xs)
              e                = undefined

   -- *****************************
   -- Реализация функционала foldl1
   --------------------------------
   foldl1' f (x:xs) = foldl f x xs                  -- foldl-стиль

   -- **************************
   -- Реализация функционала all
   -----------------------------
   all' p = foldl f e
        where   f = \x y -> x && p y
             -- f = (flip (.) p) . (&&)
                e = True                            -- foldl-стиль

   -- **************************
   -- Реализация функционала any
   -----------------------------
   any' p = foldl f e
        where   f = \x y -> x || p y
             -- f = (flip (.) p) . (||)
                e = False                           -- foldl-стиль

   -----------------------------------------
   -- Эквивалентные преобразования очевидны:
   --
   -- \x y -> x || p y = \x y -> (||) x (p y) =
   --       = \x y -> (.) ((||) x) p y =
   --       = \x y -> flip (.) p ((||) x) y = 
   --       = \x y -> (.) (flip (.) p) (||) x y =
   --       = \x y -> ((flip (.) p) . (||)) x y =
   --       = (flip (.) p) . (||)

   -- ******************************************
   -- Реализация функционала takeWhile с исполь-
   -- зованием  к о н т е к с т а.
   -- Автор: М.В.Швецкий (26.02.2016)
   ----------------------------------
   takeWhile' p = fst . foldl f e
        where f = \(xs,l) x -> if p x && l
                                 then (xs ++ [x], l)
                                 else (xs, False)
              e = ([],True)                         -- foldl-стиль

   -- *************************************************
   -- Реализация функционала dropWhile с использованием
   -- к о н т е к с т а.
   -- Контекстом является флаг - признак начала списка.
   -- Значение флага меняется на False  при обнаружении
   -- первого элемента, не удовлетворяющего  предикату,
   -- после чего все оставшиеся элементы переносятся  в
   -- оставшийся список без изменения
   -- (недостатком кода является использование неэффек-
   -- тивной операции (++)).

   -- Автор: В.Брагилевский (2010)
   -------------------------------
   dropWhile' p = fst . foldl f e
        where f res@(xs,l) x | l && p x = res
                             | True     = (xs ++ [x],False)
              e = ([], True)            
                                                    -- foldl-стиль

   -- ******************************************
   -- Реализация функционала dropWhile с исполь-
   -- зованием контекста-флага
   -- (без именованных образцов)
   ---------------------------------------
   dropWhile'' p lst = fst $ foldl f e lst
        where f (xs,l) x | l && p x = (xs, l)
                         | True     = (xs ++ [x], False)
              e = ([], True)         
                                                    -- foldl-стиль

   -- ***************************
   -- Неудачные тестовые примеры:
   -------------------------------------------------------------
   test1 = comp [asin,sin] (pi/2) == pi/2       -- Не попались!
   test2 = comp [logBase (exp 1), exp] pi - pi  -- Попались!
   test3 = comp [y (\f x -> x + 1),
                 y (\f x -> if x==0 then 1 else x * f (x-1))] 800
         where y f = f (y f)
   -------------------------------------------
   test4 = not' True      == not' (not' False)
   test5 =   elem' 3 [1..6] == elem 3 [1..6]
          && elem' 5 [1..4] == elem 5 [1..4]
   -----------------------------------------------
   test6 =   maximum' [[1],[-2,3],[4,5,6],[1,1,1]]
             == max (max (max (max [1] [1]) [-2,3]) [4,5,6]) [1,1,1] 
          && max (max (max (max [1] [1]) [-2,3]) [4,5,6]) [1,1,1]
             == max (max (max [1] [-2,3]) [4,5,6]) [1,1,1]           
          && max (max (max [1] [-2,3]) [4,5,6]) [1,1,1]
             == max (max [1] [4,5,6]) [1,1,1]
          && max (max [1] [4,5,6]) [1,1,1] == max [4,5,6] [1,1,1] 
          && max [4,5,6] [1,1,1]           == [4,5,6]
   ------------------------------------------------------------
   test7 =   maximum' [[1],[1,1]]    == max (max [1] [1]) [1,1]
          && max (max [1] [1]) [1,1] == max [1] [1,1]
          && max [1] [1,1]           == [1,1]
   ------------------------------------------
   test8 = (sum' [1..5322],product' [1..5],
            and' [True,True,True,True],
            or' [False,True,False,False])
   --------------------------------------
   test9  = concat' [[1..3],[4..6]]
   test10 = concat' ["123","456"]
   test11 = (++~) [1..3] [4..6] == [1..3] ++ [4..6]
   test12 = "123" ++~~ "456"    == "123" ++ "456"
   ----------------------------------------------
   test13 = last' [1] == 1 && last' [1..10] == 10
   test14 = (drop' 2 [1,2,3,4,5] == [3,4,5],
             drop' 5 [1..5]      == [],
             drop' 3 [1..2]      == [])
   test15 = (init' [1] == [], init' [1..10] == [1..9])
   test16 = reverse' [1..5500] == reverse [1..5500]
   test17 = length' [1..5322]
   --------------------------
   test18 = head' []
   test19 = head' [1..1000]
   test20 = zip' [1..1000] [2..1001]
   test21 = unzip' [(1,2),(11,22),(111,222)]
   ------------------------------------------------------
   test22 = foldr' (+) 0 [1..100] == foldr (+) 0 [1..100]
   test23 = foldr' (*) 1 [1..60]  == foldr (*) 1 [1..60]
   test24 =   foldr' (++) [] [[1,2,3],[5,6,7]]
           == foldr  (++) [] [[1,2,3],[5,6,7]]
   test25 = foldl1' (++) [[1,2,3],[5,6,7],[8,9]] ==
            foldl1  (++) [[1,2,3],[5,6,7],[8,9]]
   ----------------------------------------------
   test26 = (all (<0) [-1..5], all' (<0) [-1..5])
   test27 = (any (>0) [-1,-2,-3,4], any' (>0) [-1,-2,-3,4])
   --------------------------------------------------------
   test28 = map' (\x -> head x) [[1,2,3],[1,5],[1,7,8,9]]
   test29 = map' (^2) [1..10]
   test30 = concatMap' reverse [[1,2,3],[1,5],[1,7,8,9]] ==
            concatMap  reverse [[1,2,3],[1,5],[1,7,8,9]]
   --------------------------------------------------------------
   test31 = takeWhile'  (< 0) [-1,-2,-3,4,-5,-6,-7] == [-1,-2,-3]
   test32 = takeWhile'  (< 0) [1,2,3,4,-5,-6,-7]    == []
   test33 = dropWhile'  (< 0) [-1,-2,3,-4,-5,-6,-7] ==
            dropWhile   (< 0) [-1,-2,3,-4,-5,-6,-7]
   test34 = dropWhile'' (< 0) [-1,-2,3,-4,-5,-6,-7] ==
            dropWhile   (< 0) [-1,-2,3,-4,-5,-6,-7]
