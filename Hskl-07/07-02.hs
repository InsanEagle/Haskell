   -- Демонстрация моделирования функций и функционалов
   -- языка Haskell на списках с помощью свёртки foldr 
   -- ************************************************
   import List

   -- *********************
   -- Реализация функции id
   ------------------------
   id' :: [a] -> [a]
   id' = foldr (:) []                                -- foldr-стиль

   -- *******************************************
   -- Реализация функционала "композиция функций"
   ----------------------------------------------
   comp :: [a -> a] -> a -> a
   comp = foldr (.) id                               -- foldr-стиль

   -- ************************************
   -- Реализация функций maximum и minimum
   ---------------------------------------
   maximum':: Ord a => [a] -> a                      
   maximum' = foldr1 max                             -- foldr-стиль
   ----------------------------
   minimum':: Ord a => [a] -> a                      
   minimum' = foldr1 min                             -- foldr-стиль

   -- ************************
   -- Реализация операции elem
   ---------------------------
   elem' x = foldr f e
        where    f = \z y -> if z==x then True else y
              -- f = \z y -> (z==x) || y
              -- f = (||) . (x ==)
                 e = False                           -- foldr-стиль

   --------------------------------------------------------
   -- Преобразуем функцию f эквивалентным образом с помощью
   -- комбинатора (.) и этта-редукции:
   --
   -- (1) f = \z y -> if z==x then True else y =
   --       = \z y -> (z==x) || y;
   --
   -- (2) \z y -> (z==x) || y = \z y -> (||) (z==x) y =
   --       = \z -> (||) (z==x) = \z -> (||) (x==z) =
   --       = \z -> (.) (||) (x ==) z = (.) (||) (x ==) =
   --       = (||) . (x ==)
   ------------------------

   -- **********************
   -- Реализация функции not
   -------------------------
   not' a = foldr f e [a]
        where f = \x _ -> if x then False else True
              e = True                               -- foldr-стиль

   -- *********************************************
   -- Реализация логических операций над элементами
   -- булева списка
   ----------------------
   and' = foldr (&&) True                            -- foldr-стиль
   or'  = foldr (||) False                           -- foldr-стиль

   -- **************************************************
   -- Реализация суммирования элементов числового списка
   -----------------------------------------------------
   sum' = foldr (+) 0                                -- foldr-стиль

   -- **************************************************
   -- Реализация произведения элементов числового списка
   -----------------------------------------------------
   product' = foldr (*) 1                            -- foldr-стиль

   -- ****************************************
   -- Варианты реализации конкатенации списков
   -- с помощью свёртки foldr
   ---------------------------
   concat' = foldr (++) []                           -- foldr-стиль

   -- ************************
   -- Реализация операции (++)
   ---------------------------
   (++~) xs ys = foldr f e xs
        where f = (:)
              e = ys                                 -- foldr-стиль
   ---------------------------
   (++~~) = (flip . foldr) (:)

   -- *************************
   -- Реализация функции length
   ---------------------------------
   length' = foldr (\_ x -> x + 1) 0                 -- foldr-стиль

   -- **************************
   -- Реализация функции reverse
   -----------------------------
   reverse' = foldr f e
        where f = \x xs -> xs ++ [x]
              e = []                                 -- foldr-стиль

   -- **************************
   -- Реализация функции reverse
   -- Автор: http://smokycat.info/haskell/604 (26.03.2013)
   -------------------------------------------------------
   reverse'' list = foldr f e list []
        where f x g rest = g (x : rest)
              e          = id                        -- foldr-стиль

   -- ***********************
   -- Реализация функции head
   -----------------------------
   head' = foldr const undefined                     -- foldr-стиль

   -- *********************************************
   -- Реализация функции tail для конечного списка.
   -- Автор: М.В.Швецкий (26.02.2016)
   ------------------------------------
   tail' = foldr f e (repeat undefined)
        where f _ _ (_:xs) = xs
              e            = undefined               -- foldr-стиль

   -- *********************************************
   -- Реализация функции tail для конечного списка.
   -- Автор: http://smokycat.info/haskell/604 (26.03.2013)
   -------------------------------------------------------
   tail'' list = foldr f e list list
        where f _ _ (_:xs) = xs
              e _          = error "Empty list"      -- foldr-стиль

   -- *********************************************
   -- Реализация функции tail для конечного списка.
   -- Автор: И.А.Кудрявцева (21.10.2015)
   -------------------------------------
   tail''' = drop' 1                                 -- foldr-стиль

   -- ***********************
   -- Реализация функции init
   -- Автор: М.В.Швецкий (27.02.2016)
   ----------------------------------
   init' = foldr f e (repeat undefined)
        where f _ _ [x]    = []      
              f _ h (x:xs) = x : h xs
              e            = undefined               -- foldr-стиль

   -- ************************
   -- Реализация функции init.
   -- Автор: http://smokycat.info/haskell/604 (26.03.2013)
   -------------------------------------------------------
   init'' list = foldr f e list list   
        where f _ _ [y]    = []                    
              f _ g (y:ys) = y : g ys
              e            = error "Empty list"      -- foldr-стиль
                                                     
   -- ************************
   -- Реализация функции init.
   -- https://groups.google.com/forum/#!topic
   --        /comp.lang.haskell/_5soLhPlwCk
   -- Автор: Dirk Thierbach (12.08.08)
   -----------------------------------
   init''' xs = foldr f e xs $ id                    
        where f x g h = h $ g $ (x :)
              e       = const []                     -- foldr-стиль

   -- ***********************
   -- Реализация функции last
   -----------------------------------
   last' lst = foldr f e lst undefined
        where f = (\x -> (. flip (\x y -> y) x))
              e = id                                 -- foldr-стиль
                                                     
   -- ************************
   -- Реализация функции last.
   -- Автор: http://smokycat.info/haskell/604 (26.03.2013)
   -------------------------------------------------------
   last'' list = foldr f e list (error "Empty list")
        where f x g _ = g x
              e       = id                           -- foldr-стиль

   -- ***********************
   -- Реализация функции take
   ---------------------------
   take' n xs = foldr f e xs n                       
        where f x g 0 = []
              f x g n = x : g (n-1)
              e       = const []                     -- foldr-стиль

   -- ************************
   -- Реализация функции drop.
   -- Автор: http://smokycat.info/haskell/604 (26.03.2013)
   -------------------------------------------------------
   drop' n lst = foldr f e lst n            
        where f x g n = (if n>0                     
                           then id
                           else (x :)) (g (n-1))
              e _     = []                           -- foldr-стиль

   -- ************************
   -- Реализация функции drop.
   -- Автор: М.В.Швецкий (26.02.2016)
   ----------------------------------
   drop'' = foldr f e [1..]
        where f _ _ 0 lst    = lst               
              f _ _ _ []     = []                
              f _ g n (_:xs) = g (n-1) xs
              e              = undefined             -- foldr-стиль

   -- **********************
   -- Реализация функции zip
   -------------------------
   zip' = foldr f e                                  -- foldr-стиль
        where f x g []     = []
              f x g (y:ys) = (x,y) : g ys
           ---------------------------------   
           -- f = \x g l@(y:ys) -> if null l 
           --                        then [] 
           --                        else (x,y) : g ys
           -------------------------------------------
              e            = const []

   --------------------------------------------------
   -- Приведём пошаговое выполнение кода функции zip'
   -- для конкретного примера:
   --
   -- zip' [1,2] [3,4] = foldr f e [1,2] [3,4] =
   --    (f 1 (foldr f e [2]) [3,4])           =>
   -- => (1,3) : (foldr f e [2]) [4]           =>
   -- => (1,3) : (f 2 (foldr f e []) [4])      =>
   -- => (1,3) : ((2,4) : (foldr f e []) [])   =>
   -- => (1,3) : ((2,4) : (e [])               =>
   -- => (1,3) : ((2,4) : [])                  =>
   -- => [(1,3),(2,4)]
   -------------------

   -- *************************
   -- Реализация функции unzip.
   -- Автор: R.Bird [1998,p.121]
   -----------------------------
   unzip' = foldr f e                                
        where f (x,y) (xs,ys) = (x : xs, y : ys)
              e               = ([],[])              -- foldr-стиль
   ------------------------------------
   unzip'' = foldr f e
        where f = \(a,b) (c,d) -> ([a] ++ c, [b] ++ d)
              e = ([],[])
                                                     -- foldr-стиль

   -- **************************
   -- Реализация функционала map
   -----------------------------
   map' g = foldr f e                                
        where f = (:) . g
              e = []                                 -- foldr-стиль

   -- ********************************
   -- Реализация функционала ConcatMap
   --------------------------------------
   concatMap' :: (a -> [b]) -> [a] -> [b]            
   concatMap' g = foldr f e
        where f = (++) . g
              e = []                                 -- foldr-стиль

   -- *****************************
   -- Реализация функционала filter
   --------------------------------
   filter' p = foldr f e                             
        where f = \x xs -> if p x then x : xs
                                  else xs
              e = []                                 -- foldr-стиль

   -- *****************************
   -- Реализация функционала foldr1
   -----------------------------------
   foldr1' g xs = foldr g e (init' xs)               
        where f = g
              e = last' xs                           -- foldr-стиль

   -- *****************************
   -- Реализация функционала foldl.
   -- Автор: G.Hutton [1999,p.367]
   -------------------------------
   foldl' h v xs = foldr f e xs v
        where f = \x g a -> g (h a x)
              e = id                                 -- foldr-стиль
                                                     
   -- *****************************
   -- Реализация функционала foldl.
   -- Автор: А.Холомьев (2012)
   -------------------------------
   foldl'' g s xs = foldr f e xs s
        where f = \x -> (. flip g x)
              e = id                                 -- foldr-стиль
                                      
   --------------------------------------------------
   -- Выполним рефакторинг для преобразования функции
   -- foldl' в функцию foldl'', воспользовавшись этта-
   -- редукцией:
   --
   --   f = \x g -> (\a -> g (h a x)) =
   --     = \x g -> (\a -> g (flip h x a)) =
   --     = \x g -> (\a -> (.) g (flip h x) a) =
   --     = \x g -> (.) g (flip h x) =
   --     = \x g -> g . flip h x = \x g -> (. flip h x) g =
   --     = \x -> (\g -> (. flip h x) g) = \x -> (. flip h x)
   ----------------------------------------------------------

   -- **************************
   -- Реализация функционала all
   -----------------------------
   all' p = foldr f e                                
        where   f = \x y -> p x && y
             -- f = (&&) . p
                e = True                             -- foldr-стиль

   -- **************************
   -- Реализация функционала any
   -----------------------------
   any' p = foldr f e                                
        where   f = \x y -> p x || y
             -- f = (||) . p
                e = False                            -- foldr-стиль
  
   -----------------------------------------
   -- Эквивалентные преобразования очевидны:
   --
   -- \x y -> p x || y = \x y -> (||) (p x) y = 
   --                  = \x y -> (||) . p) x y = (||) . p
   ------------------------------------------------------

   -- ********************************
   -- Реализация функционала takeWhile
   -- [Bird,Wadler,1988,p.67]
   --------------------------
   takeWhile' p = foldr f e                          
        where f x xs = if (not . p) x then []
                                      else x : xs
              e      = []                            -- foldr-стиль

   -- *************************************************
   -- Реализация функционала dropWhile с использованием
   -- к о н т е к с т а   в  виде пары, содержащей  два
   -- списка, которые содержат:
   --  (1) все элементы списка, просмотренные к настоя-
   --      щему моменту;
   --  (2) все элементы списка, просмотренные к настоя-
   --      щему моменту, за исключением начальных, удов-
   --      летворяющих предикату
   -- (не работает с бесконечными списками).
   --
   -- Авторы: G.Hutton (1999), B.Pope (2007)
   -----------------------------------------
   dropWhile' p = fst . foldr f e                    -- foldr-стиль
        where f x (ys,xs) = (if p x 
                               then ys 
                               else x : xs, x : xs)
              e           = ([],[]) 
   -----------------------------------
   dropWhile'''''' p = fst . foldr f e
        where f x (ys, xs) | p x  = (ys,     x : xs)
                           | True = (x : xs, x : xs)
              e = ([], [])                           -- foldr-стиль

   -- ***************************************************
   -- Реализация функционала dropWhile с помощью  к о н -
   -- т е к с т а, представленного  в  виде  функционала,
   -- построенного с помощью списка  lst  и возвращающего
   -- композицию функций id и tail.
   -- Далее построенная композиция применяется к исходно-
   -- му списку и возвращает требуемый результат
   -- (требует два прохода по исходному списку,
   --  работает с  бесконечными списками).
   --
   -- Автор: B.Pope (2007)
   ---------------------------------------
   dropWhile'' p lst = (foldr f e lst) lst           
        where f x g | p x  = g . tail 
                    | True = id
              e = id                                 -- foldr-стиль

   -----------------------------------------------
   -- Выполним "ручную" прокрутку для dropWhile'':
   --     
   -- (а) f 3 (f 2 (f 4 id))                                   
   --               -------                                    
   --               id.tail                                    
   --          ------------                                    
   --          id.tail.tail                                    
   --     -----------------                                    
   --     id.tail.tail.tail =>
   --          => (id.tail.tail.tail) [3,2,4] = []
   --
   -- (б) f 3 (f 2 (f -4 (f -5 (f 6 id)))                         
   --                           -------                           
   --                           id.tail                           
   --                     -------------                           
   --                     id                                      
   --               --------                                      
   --               id                                            
   --          -------                                            
   --          id.tail                                            
   --     ------------                                            
   --     id.tail.tail =>
   --        => (id.tail.tail) [3,2,-4,-5,6] = [-4,-5,6]
   --
   -- (в) f 3 (f -2 (f 4 id))
   --                ------  
   --                id      
   --          --------      
   --          id.tail        
   --     ------------        
   --     id           => id [3,-2,4] = [3,-2,4]

   -- ***************************************************
   -- Вспомогательная функция, визуализирующая композицию
   -- функций, которая  строится в процессе работы  функ-
   -- ции dropWhile''.
   -- Автор: В.Брагилевский (2010)
   -------------------------------
   visual p lst = foldr f e lst
        where f x g | p x  = g ++ ". tail"
                    | True = "id"
              e = "id"

   ----------------------------------------------
   -- Выполним рефакторинг функции f, находящейся
   -- в замыкании функционала dropWhile'':
   --
   -- f x g | p x  = g . tail => 
   --       | True = id          
   --                            
   -- => f x g lst = if p x then (g . tail) lst =>
   --                       else id lst       
   --
   -- => f x g lst = if p x then g (tail lst) =>
   --                       else lst           
   --
   -- => f x g lst@(x:xs) | p x  = g xs
   --                     | True = lst
   --
   -- и получим представление функции dropWhile'''

   -- ********************************
   -- Реализация функционала dropWhile
   -- (работает с бесконечными списками)
   --
   -- Автор: B.Pope (2007)
   -------------------------------------
   dropWhile''' p xs = (foldr f e xs) xs                 
        where f x g xs@(_:ys) | p x  = g ys
                              | True = xs
              e = id                                 -- foldr-стиль
   ------------------------------------------
   dropWhile'''' p list = foldr f e list list
        where f _ g (x:xs) = if p x
                               then g xs 
                               else x : xs
              e            = id                      -- foldr-стиль

   -- ******************************************
   -- Реализация функционала dropWhile с помощью
   -- комбинатора неподвижной точки, представлен-
   -- ного в foldr-стиле
   -- (работает с бесконечными списками).
   --
   -- Автор: М.В.Швецкий (26.02.2016)
   ---------------------------------------------
   dropWhile''''' = foldr f e (repeat undefined)      
        where f _ _ _ []     = []            
              f _ g p (x:xs) = if p x        
                                 then g p xs
                                 else x : xs 
              e              = undefined             -- foldr-стиль

   -- *****************************************
   -- Функция, моделирующая функционал zipWith.
   -- Автор: http://smokycat.info/haskell/604 (26.03.2013)
   -------------------------------------------------------
   zipWith' g = foldr f e
        where f x h (y:ys) = g x y : h ys
              f _ _ _      = []
              e _          = []                      -- foldr-стиль

   -- *****************************
   -- Реализация функционала scanr.
   -- Автор: М.В.Швецкий (28.02.2016)
   ----------------------------------
   scanr' = foldr f e [1..]                          
        where f _ _ _  q0 []     = [q0]       
              f _ h f' q0 (x:xs) = f' x q : qs
                where qs@(q:_) = h f' q0 xs
              e                  = undefined         -- foldr-стиль

   -- *****************************
   -- Реализация функционала scanl.
   -- Автор: М.В.Швецкий (28.02.2016)
   ----------------------------------
   scanl'= foldr f e [1..]                          
        where f _ h f' q xs = q : (case xs of
                                    []   -> []
                                    x:xs -> h f' (f' q x) xs)
              e             = undefined
                                                     -- foldr-стиль

   -- ****************************************
   -- Реализация функции inits из модуля List:
   --
   --  inits []     = [[]]
   --  inits (x:xs) = [] : map (x :) (inits xs)
   --
   -- Автор: R.Bird [1998,p.124]
   -----------------------------
   inits' = foldr f e                                
        where f x xs = [] : map' (x :) xs
              e      = [[]]                          -- foldr-стиль

   -- ****************************************
   -- Реализация функции tails из модуля List:
   --
   --  tails []     = [[]]
   --  tails (x:xs) = (x : xs) : tails xs
   --
   -- Функция tails' "работает" с бесконечными
   -- списками, т.е.
   --
   --  > take 5 $ head $ tails' [1..]
   --
   -- не приводит к переполнению.
   --
   -- Автор: С.Довжиков (1 курс, ИС, 18.11.2015)
   ---------------------------------------------
   tails' :: [a] -> [[a]]                            
   tails' = foldr f e
        where f = \x xs -> (x : head xs) : xs
              e = [[]]                               -- foldr-стиль

   -- ****************************************
   -- Реализация функции tails из модуля List.
   -- Автор: http://smokycat.info/haskell/604 (26.03.2013)
   -------------------------------------------------------
   tails'' list = foldr f e list list
        where f _ g (x:xs) = (x : xs) : g xs
              e _          = [[]]                    -- foldr-стиль

   -- ****************************************
   -- Реализация функции delete из модуля List
   -------------------------------------------
   delete' :: Eq a => a -> [a] -> [a]
   delete' = foldr f e [1..]
        where f _ _ _ []     = []               
              f _ h x (y:ys) = if x==y          
                                 then ys        
                                 else y : h x ys
              e              = undefined             -- foldr-стиль

   -- ***********************************************
   -- Реализация функционала partition из модуля List
   --------------------------------------------------
   partition' :: (a -> Bool) -> [a] -> ([a],[a])     
   partition' g  = foldr f e
        where f x (xs,xs') = if g x
                               then (x:xs, xs')
                               else (xs, x:xs')
              e            = ([],[])                 -- foldr-стиль

   -- **********************************************
   -- Реализация функционала groupBy из модуля List.
   -- Автор: http://smokycat.info/haskell/604 (26.03.2013)
   -------------------------------------------------------
   groupBy' g list = foldr f e list list id          
        where f _ next (a:b:cs) tmp 
                     = if g a b
                         then next (b : cs) (tmp . (a :))
                         else tmp [a] : next (b : cs) id
              f _ next (y:ys) tmp
                     = tmp [y] : next ys id
              e _ _  = []                            -- foldr-стиль

   -- *************************************************
   -- Реализация функции intersperse, которая принимает
   -- элемент x и список xs и возвращает список, в кото-
   -- ром x расположен между каждым элементом списка xs
   ----------------------------------------------------
   intersperse':: a -> [a] -> [a]
   intersperse' x = foldr f e
        where f x' xs = x' : (if null xs
                                then xs 
                                else x : xs)
              e       = []                           -- foldr-стиль

   -- *************************************************
   -- Реализация функции intercalate, которая принимает
   -- список x и список списков xs и размещает список x
   -- между всеми списками в xs
   ----------------------------------
   intercalate':: [a] -> [[a]] -> [a]
   intercalate' x = foldr f e
        where f x' xs = x' ++ if null xs
                                then xs 
                                else x ++ xs
              e       = []                           -- foldr-стиль

   -- *********************************************
   -- Реализация функции isPrefixOf из модуля List.
   -- Автор: http://smokycat.info/haskell/604 (26.03.2013)
   -------------------------------------------------------
   isPrefixOf' :: Eq a => [a] -> [a] -> Bool
   isPrefixOf' = foldr f e
        where f x next (y:ys) = x==y && next ys
              f _ _    _      = False             
              e _             = True                 -- foldr-стиль

   -- ********************************************
   -- Реализация функции isInfixOf из модуля List.
   -- Автор: http://smokycat.info/haskell/604 (26.03.2013)
   -------------------------------------------------------
   isInfixOf' xs ys = foldr f e (tails'' ys)
        where f = ((||) . isPrefixOf' xs)
              e = False                              -- foldr-стиль
 
   -- *********************************************
   -- Реализация функции isSuffixOf из модуля List.
   -- Автор: http://smokycat.info/haskell/604 (26.03.2013)
   -------------------------------------------------------
   isSuffixOf' xs ys = isPrefixOf' (reverse' xs)
                                   (reverse' ys)     -- foldr-стиль

   -- ***************************
   -- Неудачные тестовые примеры:
   ------------------------------
   test1 = id [1..50]
   -----------------------------------------------
   -- Примеры опасного использования операции "=="
   --------------------------------------------------------------
   test2 = comp [asin,sin] (pi/2)        == pi/2  -- Не попались!
   test3 = comp [logBase (exp 1),exp] pi == pi    -- Попались!
   test4 = comp [y (\f x -> x + 1),
                 y (\f x -> if x==0 then 1 else x * f (x-1))] 5
         where y f = f (y f)
   ---------------------------
   test5 =   elem' 3 [1,2,6,3]
          && not' (elem' 3 [1,2,4,5,6])
          && elem' 3 [3,1,2,6]     
          && not' (not' (elem' 3 [3]))
   -----------------------------------------
   test6  = (sum' [1..3989],product' [1..5],
             and' [True,True,True,True],
             or' [False,True,False,False])
   test7  = concat' [[1..3],[4..6]]
   test8  = concat' ["123","456"]
   test9  = (++~) [1..3] [4..6]
   test10 = ("123" ++~ "456", "" ++~~ "", "" ++~~ "1")
   ---------------------------------------------------
   test11 = (head' [1..10] == 1, head' [1..10] == 1,
             tail' [1] == [], tail' [1..1000] == tail [1..1000])
   test12 = (init' [1] == [], init' [1..10] == [1..9],
             init'' [1..10] == [1..9],
             last' [1] == 1, last' [1..10] == 10)
   test13 = (init''' [1..10] == [1..9], init''' [1] == [])
   -------------------------------------------------------
   test14 = (take'  5 [1..10] == [1..5],
             take'  0 [1..10] == [],
             take' 10 [1..10] == [1..10])
   -----------------------------------------
   test15 = (drop' 2 [1,2,3,4,5] == [3,4,5],
             drop' 5 [1..5]      == [],
             drop' 3 [1..2]      == [])
   test16 = (drop'' 2 [1,2,3,4,5] == [3,4,5],
             drop'' 5 [1..5]      == [],
             drop'' 3 [1..2]      == [])
   ---------------------------------------------
   test17 = (reverse' [1..50],reverse'' [1..50],
             length' [1..5000])
   test18 =   inits' [1..5]      == inits [1..5]
           && inits' [1,2,3]     == [[],[1],[1,2],[1,2,3]]
           && inits' [6,4,7,9,2] == 
                     [[],[6],[6,4],[6,4,7],[6,4,7,9],[6,4,7,9,2]]
   test19 =   tails' [1..1000]     == tails [1..1000]
           && tails' [1,2,3]     == [[1,2,3],[2,3],[3],[]]
           && tails' [6,4,7,9,2] == 
                     [[6,4,7,9,2],[4,7,9,2],[7,9,2],[9,2],[2],[]]
   test20 = intersperse' ' ' "Avoid success at all costs"
            == "A v o i d   s u c c e s s   a t   a l l   c o s t s"
   test21 = intercalate' " " ["Avoid","success","at","all","costs"]
            == "Avoid success at all costs"
   -------------------------------------------------
   test22 = map (\x -> (x, lst, delete' x lst)) lst
               where lst = [1..9]
   test23 = delete' 4 [3,4,5,6,4] == [3,5,6,4]
   ---------------------------------------------
   test24 = zip' [1,2,3,4,5] [11,22,33,44,55] ==
            zip  [1,2,3,4,5] [11,22,33,44,55]
   test25 = zip' [1,2,4] [7,3,2] == [(1,7),(2,3),(4,2)]
   test26 = map (\f -> take 5 $ (f [2..] [1..])) [zip']
   test27 = unzip' [(1,2),(11,22),(111,222)]
   test28 = unzip'' [(1,2),(11,22),(111,222)]
   -------------------------------------------------------
   test29 = map' (\x -> head x) [[1,2,3],[1,5],[1,7,8,9]]
   test30 = map' (^2) [1..10]
   test31 = concatMap' reverse [[1,2,3],[1,5],[1,7,8,9]] ==
            concatMap  reverse [[1,2,3],[1,5],[1,7,8,9]]
   -----------------------------------------------------
   test32 = filter' (==3) [1,2,3,1,2,3]   == [3,3]
   test33 = (take 5 $ filter' (> 0) [1..])    -- Тест "ленивости"!
   test34 = take  7 $ filter' (==5) [1..]     -- Важный тест!
   ----------------------------------------------------------
   test35   = foldl' (++) [] [[1,2,3],[5,6,7]] ==
              foldl'' (++) [] [[1,2,3],[5,6,7]]
   test36   = foldr1' (++) [[1,2,3],[5,6,7],[8,9]]
   test37 n = (foldl (+) 0 [1..n],foldl' (+) 0 [1..n])
   -------------------------------------------------------
   test38 = (takeWhile' (>0) [1,2,3,-1,-2]     == [1,2,3],
             takeWhile' (even) [1..5]          == [],
             takeWhile' (>0) [1,5,2,-3,-6,6,7] == [1,5,2])
   test39 =   takeWhile' (<5) [1..10]          == [1..4]
           && takeWhile' (not . null) [[1],[52],[],[4]]
                                               == [[1],[52]]
           && takeWhile' (>2) []               == []
   -------------------------------------------------
   test40 = partition' (>0) [1,5,3,-2,3,4,-2] ==
            partition  (>0) [1,5,3,-2,3,4,-2]
   -------------------------------------------------------------
   test41 = take 3 $ dropWhile'     (<5) [1..]  -- Важные тесты!
   test42 = take 3 $ dropWhile''    (<5) [1..]
   test42'    = visual (> 0)  [3,2,-4,-5,6] == "id. tail. tail"
   test42''   = visual (> 0)  [3,2,4]     == "id. tail. tail. tail"
   test42'''  = visual (< 0)  [3,-2,4]    == "id"
   test42'''' = visual (<= 4) [1,2,3,5,2] == "id. tail. tail. tail"
   test43 = take 3 $ dropWhile'''   (<5) [1..]
   test44 = take 3 $ dropWhile''''  (<5) [1..]
   test45 = take 3 $ dropWhile''''' (<5) [1..]
   -------------------------------------------------
   test46 = dropWhile'      (==0) [0,1,2,3,-3,-3] ==
            dropWhile       (==0) [0,1,2,3,-3,-3]
   test47 = dropWhile''     (< 3) [1,2,3,4,1,5]   ==
            dropWhile       (< 3) [1,2,3,4,1,5]
   test48 = dropWhile'''    (==0) [0,1,2,3,-3,-3] ==
            dropWhile       (==0) [0,1,2,3,-3,-3]   
   test49 = dropWhile''''   (==0) [0,1,2,3,-3,-3] ==
            dropWhile       (==0) [0,1,2,3,-3,-3]   
   test50 = dropWhile'''''  (==0) [0,1,2,3,-3,-3] ==
            dropWhile       (==0) [0,1,2,3,-3,-3]   
   test51 = dropWhile'''''' (==0) [0,1,2,3,-3,-3] ==
            dropWhile       (==0) [0,1,2,3,-3,-3]   
   --------------------------------------------------------------
   test52 = isPrefixOf' "asdfg" "asd" == isPrefixOf "asdfg" "asd"
   test53 = isSuffixOf' "asdfg" "dfg" == isSuffixOf "asdfg" "dfg"
   --------------------------------------------------------------
   test54 = any' (> 0) [1,4,2,-3,-4]  == any (> 0) [1,4,2,-3,-4]
   test55 = groupBy' (==) "qqqwweeee" == groupBy (==) "qqqwweeee"
   --------------------------------------------------------------
   test56 = scanr' (+) 1 [1..5] == scanr (+) 1 [1..5]
   test57 =   scanr' (+) 0 [1,2,3,4,5] == [15,14,12,9,5,0]
           && scanr' (*) 2 [5,6,7]     == [420,84,14,2]
           && scanr' min (-5) [-1,2,-13,-4,-6] 
                                       == [-13,-13,-13,-6,-6,-5]
           && scanr' (-) 0 [1,2,3,4,5] == [3,-2,4,-1,5,0]
   ------------------------------------------------------
   test58 =   scanl' (+) 0 [1,2,3,4,5] == [0,1,3,6,10,15]
           && scanl' (*) 2 [5,6,7]     == [2,10,60,420]
           && scanl' min (-5) [-1,2,-13,-4,-6]
                                       == [-5,-5,-5,-13,-13,-13]
           && scanl' (-) 0 [1..5]      == [0,-1,-3,-6,-10,-15]

   -- *****************************************************
   -- Тестирование (комплексное) некоторых свойств функций:
   -------------------------------------------------------------
   test59 = foldl' (+) 1 [1..5] == (last' . scanl' (+) 1) [1..5]
   test60 = foldr  (*) 1 [1..5] == (last' . scanl' (*) 1) [1..5]

