   -- Демонстрация функционала "развёртка" unfold на списках
   -- и его использования для Haskell-оригами, т.е. програм-
   -- мирования в unfold- и foldr-unfold-стилях 
   --
   -- (п е р в ы й  вариант реализации функционала unfold)
   -- ****************************************************
   import List

   -- **************************************************
   -- Функция, моделирующая функционал unfold на списках
   -- (список порождается, пока  не  выполнится  условие
   -- (p x); элементы  списка  образует функция f, а на-
   -- чальный элемент x преобразуется функцией g)
   -- (п е р в ы й  вариант реализации)
   --------------------------------------------------------
   unfold:: (a -> Bool) -> (a -> b) -> (a -> a) -> a -> [b]
   --          p              f           g        x
   -------------------------------------------------
   unfold p f g x | p x  = [] 
                  | True = f x : unfold p f g (g x)

   -- *******************************************
   -- Функция возвращает потенциально бесконечный
   -- список [1,2,3,...]
   -----------------------------------------
   infinity = unfold (\x -> False) id succ 1        -- unfold-стиль

   -- **********************************************
   -- Функция возвращает список вида [n,n-1,...,2,1]
   -- (pred - функция из модуля Prelude)
   -------------------------------------
   downfrom = unfold p f g                          
        where p = (== 0)
              f = id
              g = pred  -- \x -> x-1                -- unfold-стиль

   -- **********************************************
   -- Функция возвращает список вида [1,2,...,n-1,n]
   -- (succ - функция из модуля Prelude)
   -------------------------------------
   upto n = unfold p f g 1                          
        where p = (> n)             
              f = id                
              g = succ  -- \x -> x+1                -- unfold-стиль

   -- *******************************************
   -- Функция возвращает список [a,a+1,a+2,...,b]
   ----------------------------------------------
   range' a b = unfold (> b) id (+ 1) a             -- unfold-стиль

   -- ********************************
   -- Функция реализует функцию repeat
   ------------------------------------
   repeat' = unfold (\x -> False) id id             -- unfold-стиль

   -- **********************************
   -- Функция реализует функцию reverse.
   -- Автор: М.Захаров (2 курс ИС, 30.10.2015)
   -------------------------------------------
   reverse' = unfold p f g                          
        where p = null              
              f = last                
              g = init                              -- unfold-стиль

   -- *****************************
   -- Функция реализует функцию zip
   ---------------------------------
   zip' l1 l2 = unfold p f g (l1,l2)        
        where p (l1,l2) = null l1 || null l2
              f (a:as,b:bs) = (a, b)
              g (a:as,b:bs) = (as,bs)               -- unfold-стиль

   -- ********************************
   -- Функция реализует функционал map
   ------------------------------------
   map' f = unfold p f1 g
        where p  = null 
              f1 = f . head
              g  = tail                             -- unfold-стиль

   -- ************************************
   -- Функция реализует функционал filter.
   -- Автор: С.Довжиков (1 курс, ИС, 10.11.2015)
   ---------------------------------------------
   filter' h a = unfold p f g $ f' a                -- unfold-стиль
        where p = null 
              f = head
              g = f' . tail
              ----------------
              f' []       = []
              f' l@(x:xs) = if h x then l else f' xs

   -- **************************
   -- Реализация функции filter.
   -- Авторы: Е.С.Буракова, И.С.Моисеев (1 курс, ИС, 29.02.2016)
   -------------------------------------------------------------
   filter'' = last $ [e] ++ unfold p f' g' ([1..100],e)  
        where f _ _ p xs = [x | x <- xs, p x]
              e          = undefined
              p          = \(x,y) -> null x
              f'         = \(x,y) -> f y (head x)
              g'         = \(x,y) -> (tail x,f' (x,y))

                                                    -- unfold-стиль

   -- ************************************
   -- Функция реализует функционал filter
   -- по следующему алгоритму:
   --
   --  filter p = concat . map f
   --
   -- Авторы: И.А.Кудрявцева, М.В.Швецкий (08.11.2015)
   ---------------------------------------------------
   filter''' p = foldr f1 e . unfold p1 f2 g
        where f1 = (++)
              e  = []
              p1 = null
              f2 = (\x -> if p x
                            then [x] 
                            else []) . head
              g  = tail                       -- foldr-unfold-стиль

   -- ***************************************
   -- Функция реализует функционал takeWhile.
   -- Автор: С.Довжиков (1 курс, ИС, 10.11.2015)
   ---------------------------------------------
   takeWhile':: (a -> Bool) -> [a] -> [a]           
   takeWhile' p = unfold pred f g
        where pred []    = True
              pred (x:_) = (not . p) x
              f          = head
              g          = tail                     -- unfold-стиль

   -- ***************************************
   -- Функция реализует функционал zipWith по
   -- следующему алгоритму:
   --
   -- zipWith f xs ys = map (uncurry f) (zip xs ys)
   --
   -------------------------------------------
   zipWith' h xs ys = unfold p f g (zip xs ys)
        where p = null
              f = uncurry h . head
              g = tail                              -- unfold-стиль

   -- После простой обфускации получим:

   zipWith'' f = ((foldr ((:) . uncurry f) [] .) .) zip

   -- ************************************
   -- Функция реализует функционал iterate
   ---------------------------------------
   iterate' :: (a -> a) -> a -> [a]
   iterate' f x = x : unfold p f' g x
        where p  = \x -> False
              f' = f
              g  = f                                -- unfold-стиль

   -- **********************************
   -- Функция реализует функционал until
   ---------------------------------------------
   until' p f = foldl1 (const id) . unfold p f f

                                             -- foldl1-unfold-стиль

   -- ***********************************
   -- Функция реализует функционал foldr.
   -- Автор: И.А.Кудрявцева (14.11-15.11.2015)
   -------------------------------------------
   foldr' f e lst = if null lst
                      then e
                      else head $ unfold p f' g lst
        where p      = null
              f' lst = if null lst 
                         then e
                         else f (head lst) ((f' . g) lst)
              g      = tail
                                                    -- unfold-стиль

   -- ****************************
   -- Реализация функционала foldr
   -- (неэффективная по памяти, требуется четыре прохода).
   --
   -- Автор: И.А.Кудрявцева (14.11-15.11.2015)
   -----------------------------------------------------
   foldr'' f e lst = last $ [e] ++ unfold p f' g (lst,e)
        where p  = \(x,y) -> null x
              f' = \(x,y) -> f (last x) y
              g  = \(x,y) -> (init x, f' (x,y))     -- unfold-стиль

   -- *****************************
   -- Реализация функционала foldl.
   -- Автор: И.А.Кудрявцева (14.11-15.11.2015)
   ----------------------------------------------------
   foldl' f e lst = last $ [e] ++ unfold p f' g (lst,e)
        where p  = \(x,y) -> null x
              f' = \(x,y) -> f y (head x)
              g  = \(x,y) -> (tail x,f' (x,y))      -- unfold-стиль

   ------------------------------------------------------
   -- Рассмотрим пошаговое выполнение функционала foldl':
   --
   -- foldl' (-) 0 [1,2,3] = last ([0] ++ (unfold ...))
   -- (unfold ...) =
   --    = ((-) 0 1) : unfold p f' g ([2,3],-1)) =
   --    = -1 : (((-) (-1) 2) : unfold p f' g ([3],-3)) =
   --    = -1 : (-3 : (((-) (-3) 3) : unfold p f' g ([],-6))) =
   --    = -1 : (-3 : (-6 : [])) = [-1,-3,-6]

   -- *****************************
   -- Реализация функционала scanr.
   -- Автор: И.А.Кудрявцева (14.11-15.11.2015)
   -------------------------------------------
   scanr' f e lst = unfold p f' g lst ++ [e]        -- unfold-стиль
        where p      = null
              f' lst = if null lst                 
                         then e
                         else f (head lst) ((f' . g) lst)
              g      = tail

   -- ******************************
   -- Реализация функционала scanr1.
   -- Автор: И.А.Кудрявцева (14.11-15.11.2015)
   -------------------------------------------
   scanr1' f lst = unfold p f' g lst                -- unfold-стиль
        where p      = null
              f' lst = if null (tail lst) 
                         then head lst
                         else f (head lst) ((f' . g) lst)
              g      = tail

   -- *****************************
   -- Реализация функционала scanl.
   -- Автор: И.А.Кудрявцева (14.11-15.11.2015)
   ---------------------------------------------
   scanl' f e lst = [e] ++ unfold p f' g (lst,e)    
        where p  = \(x,y) -> null x
              f' = \(x,y) -> f y (head x)
              g  = \(x,y) -> (tail x, f' (x,y))     -- unfold-стиль

   -- ******************************
   -- Реализация функционала scanl1.
   -- Автор: И.А.Кудрявцева (14.11-15.11.2015)
   ------------------------------------------------------------
   scanl1' f lst = head lst : unfold p f' g (tail lst,head lst)
        where p  = \(x,y) -> null x
              f' = \(x,y) -> f y (head x)
              g  = \(x,y) -> (tail x, f' (x,y))     -- unfold-стиль

   -- ***********************************************
   -- Функция реализует функцию inits из модуля List,
   -- представленную следующим кодом:
   --
   -- inits []     = [[]]
   -- inits (x:xs) = [] : map (x :) (inits xs)
   --
   --------------------------------------------------
   inits' lst = [[]] ++ foldr f e (unfold p f' g lst)
        where f  = \x xs -> xs ++ [x]
              e  = []                         
              p  = null
              f' = id                         -- foldr-unfold-стиль
              g  = init                      
   -----------------------------------------------------
   inits'' = ((++) [[]]) . reverse . unfold null id init

                                              -- foldr-unfold-стиль

   -- ***********************************************
   -- Функция реализует функцию tails из модуля List,
   -- представленную следующим кодом:
   --
   -- tails []     = [[]]
   -- tails (x:xs) = (x : xs) : tails xs
   --
   -------------------------------------
   tails' lst = unfold p f g lst ++ [[]]            -- unfold-стиль
        where p = null
              f = id
              g = tail
   ----------------------------------------------
   tails'' = flip (++) [[]] . unfold null id tail   -- unfold-стиль

   -- ****************************************
   -- Реализация функции tails из модуля List.
   -- Функция "не работает" с бесконечными списками:
   --
   -- > take 5 $ tails''' [1..]
   --
   -- приводит к переполнению...
   -----------------------------------------------------
   -- Вначале реализуем функцию tails следующим образом:
   --
   -- tails':: [a] -> [[a]] 
   -- tails' lst = takeWhile (\x -> length x > 0)
   --                        (iterate tail lst) ++ [[]]
   --
   -- Применим алгебру комбинаторов для эквациональных
   -- преобразований:
   --
   -- takeWhile (\x -> length x > 0) (iterate tail lst) ++ [[]] =
   --
   --  = (.) (takeWhile (\x -> length x > 0)) (iterate tail) lst
   --                                                   ++ [[]] =
   --  = (takeWhile (\x -> length x > 0) . iterate tail) lst
   --                                                   ++ [[]] =
   --  = (++) ((takeWhile (\x -> length x > 0) . 
   --                                   iterate tail) lst) [[]] =
   --
   --  = flip (++) [[]] ((takeWhile (\x -> length x > 0) . 
   --                                        iterate tail) lst) =
   --
   --  = (.) (flip (++) [[]]) (takeWhile (\x -> length x > 0) . 
   --                                         iterate tail) lst =
   --
   --  = (flip (++) [[]]) . (takeWhile (\x -> length x > 0) . 
   --                                           iterate tail) lst

   -- Остаётся применить к результату преобразований выражение
   -- unfold в виде композиции map, takeWhile, iterate:
   --
   -- (flip (++) [[]]) . (map id . takeWhile (\x -> length x > 0)
   --                            . iterate tail) =
   --    = (flip (++) [[]]) . 
   --                     (unfold (\x -> length x <= 0) id tail)
   --
   -- Обратите внимание на изменение знака неравенства в исполь-
   -- зуемом предикате...
   -----------------------------
   tails''' = (flip (++) [[]]) . 
              (unfold (\x -> length x <= 0) id tail)

                                                    -- unfold-стиль

   -- **********************************************
   -- Функция возвращает функцию nub из модуля List.
   -- Вначале построим следующий код:
   --
   --  nub lst | null lst = []
   --          | True     = head lst : 
   --                         nub (filter (/= head lst)
   --                                     (tail lst))
   --
   -- Затем преобразуем код так:
   --
   -- filter (/= (head lst)) (tail lst) =
   --          = (.) filter (/=) (head lst) (tail lst) =
   --          = (.) (filter . (/=)) head lst (tail lst) =
   --          = flip ((filter . (/=)) . head) (tail lst) lst =
   --         = (.) (flip ((filter . (/=)) . head)) tail lst lst =
   --          = w ((flip ((filter . (/=)) . head)) . tail) lst
   --
   -- Авторы: И.А.Кудрявцева, М.В.Швецкий (12.11.2015)
   ---------------------------------------------------
   nub' :: Eq a => [a] -> [a]                       
   nub' = unfold p f g                              -- unfold-стиль
        where p = null
              f = head
              g = (\x y -> x y y) 
                  ((flip ((filter' . (/=)) . head)) . tail)

   -- *************************************************************
   -- Функция, возвращающая результат разбиения заданного непустого
   -- списка на подсписки заданной длины n=1,2,3,....
   -- При реализации использован код [Bird,Wadler,1988,p.172]:
   --
   -- group_k n = map (take n) . takeWhile (/=[]) . iterate (drop n)
   --
   -- Автор: Р.Азами (1 курс, ИС, 07.12.2016)
   ------------------------------------------
   group_k n = unfold p f g
        where p = null
              f = take n
              g = drop n                         -- unfold-стиль

   -- ***************************
   -- Неудачные тестовые примеры:
   ----------------------------------
   test1 k = unfold (<0)  id   pred k
   test2 k = unfold (<=0) pred pred k
   test3 k = unfold (>k) (^ 2) (+ 2) 1
   test4 k = unfold (<0) (\x -> x*x) pred k
   test5   = unfold (<0) id (\x -> x-3) 9 == [9,6,3,0]
   test6   = unfold (==0) id pred
   test7 k = unfold (\x -> abs x < 0.1) sin sin k
   test8   =    range' 7 10   == [7,8,9,10]
             && range' 6 5    == []
             && range' 4 4    == [4]
   test9   = reverse' [1..20] == reverse [1..20]
   -------------------------------------------------
   test10  = zip' [1..4] [1..7] == zip [1..4] [1..7]
   test11  =   zip' [1,2,3,4] [5,6,7,8] == [(1,5),(2,6),(3,7),(4,8)]
            && zip' [1,2,3] [4,5]       == [(1,4),(2,5)]
            && zip' [1,2] [3,4,5]       == [(1,3),(2,4)]
   -----------------------------------------------------
   test12 =   inits'   [1..100] == inits [1..100]
           && inits''  [1..100] == inits [1..100]
   test13 =   tails'   [1..100] == tails [1..100]
           && tails''  [1..200] == tails [1..200]
           && tails''' [1..300] == tails [1..300]
           && tails''' [1..400] == tails [1..400]
   ---------------------------------------------------------------
   test14 = take 15 (iterate' (^2) 2) == take 15 (iterate  (^2) 2)
   test15 = take 4 (iterate' tail [1..5]) ==
            take 4 (iterate  tail [1..5])
   ----------------------------------------------------------------
   test16 =   nub' [1,2,3,1,2,3,2,1,3]   == nub [1,2,3,1,2,3,2,1,3]
           && nub' [1,2,3]               == nub [1,2,3]
           && nub' [1,3,2,3,3]           == nub [1,3,2,3,3]
           && nub' [1,2,3,4,2,3,4,3,4,4] == nub [1..4]
   ---------------------------------------------------------
   test17 x = until' (< 2) sqrt x   == until (< 2)    sqrt x
   test18 x = until' (< 0.01) sin x == until (< 0.01) sin  x
   -----------------------------------------------------------
   test19   =   takeWhile' (==4) [4,4,4,1,2,3]      == [4,4,4]
             && takeWhile' (<4)  [1,4,4,1,2,3]      == [1]
             && takeWhile' (>10) [56,21,45,9,6,152] == [56,21,45]
             && takeWhile' (>2) []                  == []
             && takeWhile' (not.null) [[1,2],[3,4],[],[5,6]]
                                                    == [[1,2],[3,4]]
   -----------------------------------------------------------------
   test20 = map' (^2) [1..20]
   test21 =   filter' (>0) []             == []
           && filter' (>0) [1]            == [1]
           && filter' (>0) [-1]           == []
           && filter' (>0) [-1,2,-3,4,-5] == [2,4]
           && filter' (>0) [-1,2,-3,4]    == [2,4]
           && filter' (>0) [1,-2,3,-4,5]  == [1,3,5]
           && filter' (>0) [1,-2,3,-4]    == [1,3]
           && filter' (>0) [1,2,3,-4,5]   == [1,2,3,5]
           && filter' (>0) [1,2,3,-4,-5]  == [1,2,3]
           && filter' (>0) [-1,-2,-3,4,5] == [4,5]
   test22 =   filter' odd []              == []
           && filter' odd [1]             == [1]
           && filter' odd [-1]            == [-1]
           && filter' odd [-1,2,-3,4,-5]  == [-1,-3,-5]
           && filter' odd [-1,2,-3,4]     == [-1,-3]
   test23 = filter' (>=2) [1..6]
   test24 = filter' (\x -> x>=20 && x<=40) [1..100]
   --------------------------------------------------
   test25 = filter'' (>= 1) [1,2,-3,-4]
   test26 = filter'' (== 3) [1,2,3,1,2,3] == [3,3]
   test27 = (take 5 $ filter'' (> 0) [1..])  -- Тест "ленивости"!
   test28 = take  7 $ filter'' (== 5) [1..]  -- Важный тест!
   ------------------------------------------------
   test29 =   filter''' (>0) []             == []
           && filter''' (>0) [1]            == [1]
           && filter''' (>0) [-1]           == []
           && filter''' (>0) [-1,2,-3,4,-5] == [2,4]
           && filter''' (>0) [-1,2,-3,4]    == [2,4]
           && filter''' (>0) [1,-2,3,-4,5]  == [1,3,5]
           && filter''' (>0) [1,-2,3,-4]    == [1,3]
           && filter''' (>0) [1,2,3,-4,5]   == [1,2,3,5]
           && filter''' (>0) [1,2,3,-4,-5]  == [1,2,3]
           && filter''' (>0) [-1,-2,-3,4,5] == [4,5]
   test30 =   filter''' odd []              == []
           && filter''' odd [1]             == [1]
           && filter''' odd [-1]            == [-1]
           && filter''' odd [-1,2,-3,4,-5]  == [-1,-3,-5]
           && filter''' odd [-1,2,-3,4]     == [-1,-3]
   ---------------------------------------------------
   test31 = filter''' (>= 2) [1..6]
   test32 = filter''' (\x -> x>=20 && x<=40) [1..100]
   --------------------------------------------------
   test33 = take 100 $ repeat' 1
   ----------------------------------------------
   test34 =   foldr' (+)  0 []             ==   0
           && foldr' (*)  4 [5,6,7]        == 840
           && foldr' (-)  0 [1,2,3,4,5]    ==   3
           && foldr' min 10 [-1,2,13,-4,5] ==  -4
           && foldr' (++) [] [[1,2,3],[5,6,7]]
                                           == [1,2,3,5,6,7]
           && foldr' (:) [1,2,3] [4,5,6]   == [4,5,6,1,2,3]
   test35 = foldr' (+) 0 [1..3500]
   -----------------------------------------------
   test36 =   foldr'' (+)  0 []             ==   0
           && foldr'' (*)  4 [5,6,7]        == 840
           && foldr'' (-)  0 [1,2,3,4,5]    ==   3
           && foldr'' min 10 [-1,2,13,-4,5] ==  -4
           && foldr'' (++) [] [[1,2,3],[5,6,7]]
                                            == [1,2,3,5,6,7]
           && foldr'' (:) [1,2,3] [4,5,6]   == [4,5,6,1,2,3]
   test37 = foldr'' (+) 0 [1..3500]         -- "Переполнение" памяти
   -----------------------------------------------------------------
   test38 =   foldl' (+)  0 []             ==        0
           && foldl' (+) 0 [1..5000]       == 12502500
           && foldl' (*)  4 [5,6,7]        ==      840
           && foldl' (-)  0 [1,2,3,4,5]    ==      -15
           && foldl' max 10 [-1,2,13,-4,5] ==       13
   -------------------------------------------------------
   test39 =   scanr' (+) 0 [1,2,3,4,5] == [15,14,12,9,5,0]
           && scanr' (*) 2 [5,6,7]     == [420,84,14,2]
           && scanr' min (-5) [-1,2,-13,-4,-6] 
                                       == [-13,-13,-13,-6,-6,-5]
           && scanr' (-) 0 [1,2,3,4,5] == [3,-2,4,-1,5,0]
   ---------------------------------------------------------
   test40 =   scanr1' (+) [1,2,3,4,5]      == [15,14,12,9,5]
           && scanr1' (*) [5,6,7]          == [210,42,7]
           && scanr1' min [-1,2,-13,-4,-6] == [-13,-13,-13,-6,-6]
           && scanr1' (-) [1,2,3,4,5]      == [3,-2,4,-1,5]
   --------------------------------------------------------
   test41 =   scanl' (+) 0 [1,2,3,4,5] == [0,1,3,6,10,15]
           && scanl' (*) 2 [5,6,7]     == [2,10,60,420]
           && scanl' min (-5) [-1,2,-13,-4,-6]
                                       == [-5,-5,-5,-13,-13,-13]
           && scanl' (-) 0 [1..5]      == [0,-1,-3,-6,-10,-15]
   -----------------------------------------------------------
   test42 =   scanl1' (+) [1,2,3,4,5]      == [1,3,6,10,15]
           && scanl1' (*) [5,6,7]          == [5,30,210]
           && scanl1' min [-1,2,-13,-4,-6] == [-1,-1,-13,-13,-13]
           && scanl1' (-) [1..5]           == [1,-1,-4,-8,-13]
   ----------------------------------------------------------------
   test43 = zipWith' (*) [1..50] [1..] == zipWith (*) [1..50] [1..]
   test44 = zipWith' (*) [1..50] [1..] == zipWith (*) [1..50] [1..]

   -- *************************
   -- Комплексное тестирование:
   -------------------------------------
   test45 = (concat' . tails') [1..4] ==
            foldr (\e x -> nub' ([e] ++ x) ++ x) [] [1..4]
        where concat' = foldr (++) []
   -----------------------------------------------
   -- Моделирование развёртки с помощью композиции
   -- функционалов map, takeWhile, iterate
   ---------------------------------------
   test46 n = unfold (==0) id pred n ==
              (map id . takeWhile (/=0) . iterate pred) n
   ------------------------------------------------------
   test47   = unfold null (sin . head) tail [1..5] ==
              (map (sin . head) . takeWhile (not . null)
                                . iterate tail) [1..5]
   ---------------------------------------------------
   test48 x = unfold (< 2) sqrt sqrt x ==
              (map sqrt . takeWhile (not . (< 2))
                        . iterate sqrt) x         -- x >= 2
   -----------------------------------------------------------------
   test49 =   group_k 3 [1,2,3,4,5,6,7,8] == [[1,2,3],[4,5,6],[7,8]]
           && group_k 4 [1,2,3,4,5,6,7]   == [[1,2,3,4],[5,6,7]]
           && group_k 1 [1,2,3,4,5]       == [[1],[2],[3],[4],[5]]
   test50 = group_k 1 [1..5]
