    2ЛАБОРАТОРНАЯ РАБОТА 7 41 2.
    2ЭКВАЦИОНАЛЬНЫЕ ДОКАЗАТЕЛЬСТВА С ПОМОЩЬЮ СВОЙСТВ СВЁРТКИ

 ш1.0
           1Есть дела, которые лучше начать, чем отказываться от них.
                                             1Дж.Толкин. Две крепости
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Знать . 0:
 ш1.0
    1- понятие "эквациональные рассуждения" 0;
    1- технология эквациональных рассуждений 0;
    1- свойство универсальности свёртки, свойство объединения свёртки 0;
    1- 0  1универсальность свёртки как способ 0  1определения функций  с  по-
 1мощью свёртки 0;
    1- определение функций с помощью 0  1свёртки на базе кортежей 0;
    1- 0  1определение примитивной рекурсии 0  1на списках с помощью свёртки 0;
    1- 0  1доказательство правильности функциональных программ с  помощью
 1свёртки 0:  1универсальность свёртки как способ доказательства эквацио-
 1нальных утверждений 0.

 ш1.2
    _ 1Уметь . 0:
 ш1.0
    1- применять 0   1универсальность  свёртки  для 0  1определения функций с
 1помощью свёртки 0;
    1- определять простейшие рекурсивные функции с помощью 0  1свёртки на
 1базе кортежей 0;
    1- применять 0   1универсальность свёртки для доказательства эквацио-
 1нальных утверждений 0.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                3Технология эквациональных рассуждений

 ш1.0
               1...  0[ 1доказательство 0] 1 - лишь дисциплина,  линейка, ко-
               1торой нас учат не умирать. 0
                                                           1Ю.И.Манин
 ш1.2

    2Определение 0.
 ш1.1
    2(1) 0  _ 1Равенства . 0 - это  1формулы 0 вида p=q, где p и q -  1термы 0, постро-
енные из функциональных и предикатных символов,  переменных и конс-
тант.
    2(2) 0 Логика, в которой формулами являются только  1равенства 0, назы-
вается  _ 1эквациональной логикой . 2  0(или  1логикой равенств 0),  а программи-
рование с помощью одних равенств называют  1эквациональным программи-
 1рованием 0.

 ш1.2
   Однако надо  иметь в виду,  что  1семантика  0(математический смысл)
равенств может определяться по-разному.  При этом одни  определения
могут быть более  1операционными 0,   1императивными 0, а другие более  1дек-
 1ларативными 0,  1непроцедурными. 0
    2Определение 0.
 ш1.1
    _ 1Эквациональные рассуждения . 0 (англ.   1equational reasoning 0)  -  это
технология формальной проверки кода на предмет отождествления функ-
ций.

 ш1.2
   В частности,  эквациональные рассуждения основаны на использова-
нии  1универсального свойства 0 функционала  foldr,  согласно  которому
доказательство эквационального утверждения
 ш1.0

   g = foldr f v

 ш1.2
эквивалентно доказательству  возможности  представления g с помощью
следующих уравнений:
 ш1.0

   g []     = v
   g (x:xs) = f x (g xs)

 ш1.2
    2Пример 0 ( 1технологии эквациональных рассуждений 0).
 ш1.1
   Рассмотрим рекурсивное определение функционала filter:
 ш1.0

   filter p [] = []
   filter p (x:xs) = if p x
                       then x : filter p xs
                       else filter p xs

 ш1.1
   Докажем, что функционал filter p представим в стиле Haskell-ори-
гами, т.е. может быть выражен в виде свёртки.
   Перепишем определение функционала filter так:
 ш1.0

   filter p [] = []
   filter p (x:xs) = (\x ys -> if p x then x : ys else ys) x
                                                      (filter p xs)

и сравним его с рекурсивным определением функционала foldr

   foldr f v []     = v
   foldr f v (x:xs) = f x (foldr f v xs).

 ш1.1
   Теперь, используя обозначения
 ш1.0

   v  ═+ 0 [], f  ═+ 0 \x ys -> if p x then x : ys else ys

 ш1.1
и рекурсивное определение свёртки,  получим доказанное эквациональ-
ное утверждение:
 ш1.0

   filter p = foldr f e
        where f = \x ys -> if p x then x : ys else ys
              e = []

 ш1.1
   Каждый из шагов является простой заменой аргументов в теле функ-
ции, поэтому оба определения эквивалентны.
 ш1.2

                          2Свойства свёртки

 ш1.0
           1Подобно тому, как малейшее изменение в устройстве глаза и
           1деятельности  зрительных  нервов неизбежно делает другими
           1восприятия и этим влияет на все миросозерцание  человека,
           1так  каждая  мелочь  в устройстве языка должна давать без
           1нашего ведома свои особые комбинации элементов мысли.
                                                         1А.А.Потебня
 ш1.2

   Применимость свёртки можно значительно расширить,  если восполь-
зоваться её классическими свойствами.
                 21. 0  3Свойство универсальности свёртки
   Универсальное свойство свёртки ( 1свойство универсальности 0) проис-
ходит из теории рекурсивных функций. Впервые этим свойством в функ-
циональном программировании воспользовался G.Malcolm (1990).
    2Теорема 0  21 0 ( 1универсальное свойство свёртки foldr 0,
               1uniqueness property 0) (по [Bird,1998]).
 ш1.1
   Для  _ 1конечных . 0 списков справедливо следующее утверждение о  равно-
сильности рекурсивного и "нерекурсивного" определений функции g:
 ш1.0

    7( 3g 0 []     = v
    7* 0                      <=>  3g 0 = fold 3r 0 f v
    79 3g 0 (x:xs) = f x ( 3g 0 xs)

 ш1.2
    2Доказательство 0.
    21 0. (<=) Пусть  3g 0 = foldr f v. Выполнив подстановку, получим
 ш1.0

    3g 0 []=foldr f v []         = v,

    3g 0 (x:xs)=foldr f v (x:xs) = f v (foldr f v xs)=f v ( 3g 0 xs).
             ═└ 0─── ═┬ 0─── ═┘ 3g 0               ═└ 0─── ═┬ 0─── ═┘ 3g

 ш1.2
   В результате получено  1известное 0 рекурсивное определение  функции
foldr.
    22 0. (=>)  Пусть  даны соотношения для функции 3 g 0;  требуется дока-
зать, что  3g 0=foldr f v. Проведём простые вычисления, используя дока-
зательство  _ 1структурной индукцией . 0 ( 1индукцией по построению списка 0):
 ш1.0

   (а)  3g 0 []=v, foldr f v []=v =>  3g 0 [] = foldr f v [];

   (б) если  3g 0 xs = foldr f v xs, то

     3g 0 (x:xs)=f x ( 3g 0 xs),
                     4(foldr)
    foldr f v (x:xs)   =   f x (foldr f v xs)=f x ( 3g 0 xs) =>
                                 ═└ 0─── ═┬ 0─── ═┘ 3g
    =>  3g 0 (x:xs) = foldr f v (x:xs).

 ш1.2
    1Теорема доказана 0.
   Универсальное свойство  свёртки  показывает,  что  для  конечных
списков функция  foldr f v является  1единственным решением 0 некоторых
рекурсивных уравнений.
   Универсальное свойство свёртки фактически является  _ 1паттерном ин-
 _ 1дуктивного доказательства . 0 (её использование фактически подтверждает
два предположения, требуемых для конкретного образца доказательства
по индукции).  Итак, свёртка является  1паттерном рекурсии 0, а универ-
сальное  свойство  свёртки  -  1паттерном доказательства правильности
рекурсивных определений.
    2Теорема 0  22 0 ( 1универсальное свойство свёртки foldl 0,
               1uniqueness property 0).
 ш1.1
   Для  _ 1конечных . 0 списков справедливо следующее утверждение о  равно-
сильности рекурсивного и "нерекурсивного" определений функции g:
 ш1.0

    7( 3g 0 e   []   = e
    7* 0                           <=>  3g 0 = fold 3l 0 g 41
    79 3g 0 e (x:xs) =  3g 0 (g 41 0 e x) xs

 ш1.2
    2Доказательство 0.  1Упражняйтесь 0.
    3Замечание 0.
 ш1.1
   Существует обобщения  универсального свойства свёртки для  1беско-
 1нечных 0 списков и для других частных  случаев,  когда  использование
этого свойства может быть удобным [Bird,1998].
   Однако для простоты будем рассматривать только  1конечные 0 списки.
 ш1.2

                   22. 0  3Свойство объединения свёртки

 ш1.0
                      1Формальные методы  не  будут приносить сущест-
                      1венных результатов до тех пор, пока их не смо-
                      1гут использовать люди, которые их не понимают.
                                                            1Т.Мелхэм
 ш1.2

   Впервые в функциональном программировании свойством  объединения
воспользовался G.Malcolm (1990). Свойство объединения (как и свойс-
тво универсальности свёртки) - это способ доказательства, не требу-
ющий прямого использования индукции.
    2Теорема 0 ( 1свойство объединения свёртки, fusion law 0)
           (по [Hutton,1999]).
 ш1.1
   Для любых  _ 1конечных . 0  списков  композиция  рекурсивной  функции  и
свёртки  при  выполнении определённых условий представима с помощью
одного оператора свёртки, т.е.
 ш1.0

    7( 3h 0 a       = v
    7* 0                      =>  3h 0 . foldr g a = foldr f b
    79 3h 0 (g x y) = f x ( 3h 0 y)

 ш1.2
    2Доказательство 0. Рассмотрим эквациональное утверждение (утвержде-
ние о равенстве функций на списках):
 ш1.0

    3h 0 . foldr g a = foldr f b                                    (*)

 ш1.2
   Заметим, что утверждение (*) часто  возникает  при  рассмотрении
программ, написанных с использованием свёртки.
   Воспользуемся свойством  универсальности свёртки для определения
условий, при которых это утверждение будет выполнено.
   Обозначив
 ш1.0

    3g 0 =  3h 0 . foldr g a

и воспользовавшись свойством универсальности, получим:

   ( 3h 0 . foldr g a) []     = b
   ( 3h 0 . foldr g a) (x:xs) = f x (( 3h 0 . foldr g a) xs)

 ш1.2
   Далее, по определению операции композиции:
 ш1.0

    3h 0 (foldr g a [])     = b
    3h 0 (foldr g a (x:xs)) = f x ( 3h 0 (foldr g a xs)).

 ш1.2
   Остаётся воспользоваться простыми вычислениями:
 ш1.0

                                  4┌ 0─────── 4┐
    3h 0 (foldr g a []) =  3h 0 a = b => │ 3h 0 a = b│;
       ═└ 0──── ═┬ 0───── ═┘ 4a 0               4└ 0─────── 4┘
                        4(foldr)
    3h 0 (foldr g a (x:xs))   =    3h 0 (g x (foldr g a xs))= 3h 0 (g x y),
                                       ═└ 0──── ═┬ 0───── ═┘ 4y

                                        4┌ 0─────────────────── 4┐
   f x ( 3h 0 (foldr g a xs))=f x ( 3h 0 y) => │ 3h 0 (g x y)=f x ( 3h 0 y)│.
            ═└ 0──── ═┬ 0───── ═┘ 4y 0                4└ 0─────────────────── 4┘

 ш1.2
   Итак,
 ш1.0

    7( 3h 0 a = b
    7* 0                    =>  3h 0 . foldr g a = foldr f b
    79 3h 0 (g x y)=f x ( 3h 0 y)

 ш1.2
    1Теорема доказана 0.
   Пользуясь свойством универсальности,  мы обошлись без явного ис-
пользования индукции.  Получены два  _ 1достаточных условия . 0  для  того,
чтобы гарантировать для любых конечных списков, что  1композиция про-
 1извольной функции и свёртки могут быть объединены в одну свёртку 0.
    3Замечание 0 (см. [Bird,1998]).
 ш1.1
   Существует множество полезных свойств свёртки, которые получают-
ся при помощи свойства универсальности.

 ш1.2
   Для большинства практических примеров  1свойство объединения 0  чаще
оказывается более предпочтительным, чем  1свойство универсальности 0.
    2Пример 0  21 0 [Hutton,1999].
 ш1.1
   С помощью  свойства объединения докажем эквациональное утвержде-
ние
 ш1.0

   (+ 1) . sum = foldr (+) 1.

 ш1.1
   Вначале вспомним, что
 ш1.0

   sum = foldr (+) 0 => (+ 1) . foldr (+) 0 = foldr (+) 1  =>
                         ═└ 0─ ═┬ 0─ ═┘ 0          ═└┬┘└┬┘ 0         ═└┬┘└┬┘
                           3h 0            g  w          f  v

   => 3 h 0 = (+ 1), g = (+), w = 0, f = (+), v = 1.

 ш1.1
   Теперь воспользуемся  1свойством объединения 0 и получим,  что соот-
ношение следует из двух предположений:
 ш1.0

    7( 0(+ 1) 0         = 1                   7( 00 + 1     = 1
    7* 0                                  =>  7*
    79 0(+ 1) ((+) x y) = (+) x ((+ 1) y)     79 0x + y + 1 = x + y + 1

   Получены верные равенства, и утверждение доказано.

 ш1.2
    2Пример 0  22 0 [Hutton,1999].
 ш1.1
   Докажем эквациональное утверждение о взаимодействии  функционала
map и композиции (.):
 ш1.0

   map f . map g = map (f . g).

 ш1.1
   Заменяя второе и третье вхождение map его определением с исполь-
зованием свёртки foldr,  получаем, что равенство может быть перепи-
сано в виде, подходящем для применения  1свойства объединения 0:
 ш1.0

   map f . foldr (\x xs -> g x : xs) [] =
    ═└ 0─ ═┬ 0─ ═┘ 0           ═└ 0─────── ═┬ 0─────── ═┘ 0  ═└┬┘ 0
      3h 0                    g          w

         = foldr (\x xs -> (f . g) x : xs) [].
                   ═└ 0────────── ═┬ 0────────── ═┘ 0  ═└┬┘
                             f             v

 ш1.1
   Применяя свойство объединения и упрощая, получим:
 ш1.0

   (1) map f [] = [];

   (2) map f ((\x xs -> g x : xs) x y) = map f (g x : y) =

                         = f (g x) : map f y =  _(f . g) x : map f y .,

       (\x xs -> (f . g) x : xs) x (map f y) =

       =  _(f . g) x : map f y ..

   Получены равенства, верные по определению map и (.):

 ш1.2
    3Замечание 0 [Мена,2015,с.97].
 ш1.1
   Осознание  _ 1законов . 0 может показаться простой теоретической игрой.
   Однако у них есть одно важное применение к программам  на  языке
Haskell, поскольку они используются компилятором для преобразования
кода в его более эффективную версию,  гарантирующую при этом точное
воспроизведение исходного поведения.
   Например, код  map (f . g) осуществляет последовательный перебор
элементов списка всего один раз,  а код  (map f . map g) делает это
дважды и нуждается в промежуточной структуре данных в памяти.
   Поэтому компилятор  пытается выполнить замену каждого экземпляра
последнего фрагмента кода предыдущим фрагментом.
 ш1.2

                         2Прагматика свёртки

 ш1.0
                           1Совершенствовать слог - значит совершенс-
                           1твовать мысль и больше ничего.
                                        1Ф.Ницше. Странник и его тень
 ш1.2

   При использовании функционального подхода к программированию  1ре-
 1курсия 0 и  1индукция 0 являются первичными инструментами для определения
и доказательства свойств программ.  Не удивительно,  что многие ре-
курсивные  программы  содержат  _ 1паттерн . 0 (общий образец)  _ 1рекурсии . 0,  а
индуктивные доказательства свойств этих программ  содержат   _ 1паттерн
(общий образец)  _ 1индукции . 0.
   Индуктивные доказательства свойств программ приводят к  монотон-
ному  повторению однотипных действий (мы снова и снова повторяем по
сути одни и те же рассуждения с небольшими вариациями),  что  часто
приводит к ошибкам. Такого повторения можно избежать, если выделить
общие образцы рекурсии в некоторые  1функции высшего порядка 0 (функци-
оналы).  Доказав однажды утверждение о такой функции, мы можем при-
менять его к различным ситуациям и концентрироваться только на час-
тях, специфических для данного применения.
   Другими словами,  повторений  можно  избежать с помощью введения
специальных паттернов рекурсии и паттернов  способа  доказательства
свойств программ.
   В функциональном  программировании   _ 1свёртка . 0  -  это  стандартный
функционал, являющийся паттерном рекурсии для функций, обрабатываю-
щих списки;  с другой стороны,  свёртка обладает  1свойствами универ-
 1сальности 0 и  1объединения 0, которые представляют собой паттерны индук-
тивного доказательства эквациональных утверждений.
   Свёртка используется для:
 ш1.1
    _(А) . записи рекурсивных функций без  1видимого 0 использования рекур-
сии в силу того, что:
   (1) с помощью свёртки выразим  1комбинатор неподвижной точки 0;
   (2) с помощью свёртки выразим  1оператор примитивной  рекурсии 0  на
       списках, что позволит выразить в терминах свёртки любые при-
       митивно-рекурсивные функции;
   (3) с помощью  1свойства универсальности свёртки 0 и   1свойства  объ-
        1единения 0 можно преобразовывать рекурсивные функции в опреде-
       ления с использованием свёртки;
    _(Б) . увеличения ( 1неожиданного 0!) степени выразительности  паттерна
рекурсии, выраженного свёрткой, с помощью 1 кортежей 0;
    _(В) . использовании  свойства  универсальности  свёртки и свойства
объединения 1  0для формального  доказательства  правильности  эквацио-
нальных утверждений, не требующего доказательства по индукции.
 ш1.2

              21. 0  3Универсальность как способ 0  3определения
                      3функций 0  3с помощью свёртки

 ш1.0
               1Если хочешь быть точным, нужно прибегать к метафорам.
                                                             1М.Марри
 ш1.2

   Свойство универсальности свёртки используется как способ опреде-
ления функций с помощью свёртки,  который осуществляет преобразова-
ние рекурсивных функций в соответствии с определением.
    2Пример 0  21 0 [Hutton,1999].
 ш1.1
   Рассмотрим рекурсивную функцию
 ш1.0

   sum:: [Int] -> Int
   sum []     = 0
   sum (x:xs) = x + sum xs

 ш1.1
   Предположим, что мы хотим переопределить эту функцию,  используя
свёртку. Для этого рассмотрим  эквациональное  равенство,  которому
припишем смысл "уравнения" относительно функций f и v:
 ш1.0

   sum = foldr f v,

 ш1.1
   Правая часть соответствует правой части свойства универсальности
свёртки, поэтому оно эквивалентно следующим двум равенствам:
 ш1.0

   sum []     = v
   sum (x:xs) = f x (sum xs)

 ш1.1
   С использованием первого соотношения и определения sum получаем,
что v=0. Из второго соотношения вычисляем определение для f:
 ш1.0

   f x (sum xs) = x + sum xs =>     ┌───────┐
   f x (sum xs) = (+) x (sum xs) => │f = (+)│ => sum = foldr (+) 0
                                    └───────┘

 ш1.2
   Пример с функцией sum является достаточно искусственным,  потому
что её определение непосредственно использует свёртку.  Однако, су-
ществует много функций,  определение которых с помощью  свёртки  не
является столь явным.
    2Пример 0  22 0 [Hutton,1999].
 ш1.1
   Рассмотрим рекурсивную функцию map,  которая применяет функцию f
к каждому элементу списка:
 ш1.0

   map:: (a -> b) -> [a] -> [b]
   map f []     = []
   map f (x:xs) = f x : map f xs

 ш1.1
   Для определения  функции map с помощью свёртки необходимо решить
следующее "уравнение" относительно неизвестных функций g и v:
 ш1.0

   map f = foldr g v

 ш1.1
   Используя свойство  универсальности свёртки,  получаем,  что это
соотношение эквивалентно следующим:
 ш1.0

   map f []     = v
   map f (x:xs) = g x (map f xs)

   Из первого соотношения по определению функции map получаем, что

   v 1  0= 1  0[].

 ш1.1
   С помощью второго соотношения вычисляем определение для g:
 ш1.0

   map f (x:xs)   = g x (map f xs);
   f x : map f xs = g x (map f xs), обозначим: ys ═+ 0map f xs;
   f x : ys       = g x ys;
   (:) (f x) ys   = g x ys;
   (.) (:) f x ys = g x ys;
   ((:) . f) x ys = g x ys;
   ((:) . f)      = g       (или g = \x ys -> f x : ys)

 ш1.1
   Итак, с помощью свойства универсальности свёртки получено:
 ш1.0

   map f = foldr ((:) . f) []

 ш1.2
    2Пример 0  23 0.
 ш1.1
   Рассмотрим рекурсивную функцию, возвращающую  1правильную дробь 0 по
заданной  1конечной цепной дроби 0:
 ш1.0

   abc' [x]    = x
   abc' (x:xs) = x + toRational (1 / (abc' xs))

 ш1.1
   Применим универсальное свойство свёртки  foldr1  для  реализации
функции abc в стиле Haskell-оригами.
   Вначале приведём  _ 1универсальное свойство свёртки . 0 foldr1:
 ш1.0
     
   g [x] = x             <=> g = foldr1 f
   g (x:xs) = f x (g xs)

 ш1.1
   Далее, сопоставляя с рекурсивным определением функции abc
 ш1.0
   
   abc [x]    = x
   abc (x:xs) = x + toRational (1 / (abc xs)),

приходим к необходимости решения эквационального уравнения:

   f x (g xs) = x + toRational (1 / (abc xs)).

 ш1.1
   Остаётся выполнить эквивалентные преобразования,  основанные  на
алгебре комбинаторов (.) и flip:
 ш1.0

   f x (g xs) = x + toRational (1 / (abc' xs)) = 
              = (+) x (toRational ((/) 1 (abc' xs))) =
              = flip (+) (toRational ((/) 1 (abc' xs))) x =
              = (.) (flip (+)) toRational ((/) 1 (abc' xs)) x =
              = (.) ((.) (flip (+)) toRational) ((/) 1) 
                                                  (abc' xs) x =
              = flip ((.) ((.) (flip (+)) toRational) ((/) 1)) 
                                                   x (abc' xs)

 ш1.1
   В результате получим:
 ш1.0

   abc'' = foldr1 f
          where f = (flip ((.) ((.) (flip (+)) toRational) ((/) 1)))

 ш1.2
    2Пример 4 0.
 ш1.1
   Рассмотрим рекурсивную  функцию,  которая  возвращает  результат
"переворачивания" заданного списка:
 ш1.0

   reverse' xs = rev [] xs
       where rev ys   []   = ys
             rev ys (x:xs) = rev (x : ys) xs

 ш1.1
   Выразим функцию  reverse'  в  терминах  foldl;  вначале вспомним
свойство универсальности для foldl:
 ш1.0

    3g 0 e   []   = e             <=>  3g 0 = foldl g 41
    3g 0 e (x:xs) =  3g 0 (g 41 0 e x) xs

 ш1.1
   Если ввести обозначения ys ═+ 0e,  3g ═+ 0rev, то
 ш1.0

    3g 0 e   []   = e          => g 41 0 e x = x:e = (:) x e =
    3g 0 e (x:xs) =  3g 0 (x:e) xs           = flip (:) e x => g 41 0 = flip (:)

 ш1.1
   Итак,  3g 0 = foldl g 41 0 => reverse' = foldl (flip (:)).
   Остаётся построить функцию
 ш1.0

   reverse' xs = rev [] xs = foldl (flip (:)) [] xs =>
               => reverse' = foldl (flip (:)) []

 ш1.2
    2Пример 5 0.
 ш1.1
   Рассмотрим стандартный функционал языка программирования Haskell:
 ш1.0

   takeWhile' p [] = []
   takeWhile' p (x:xs) | (not . p) x = [] 
                       | True        = x : takeWhile' p xs

 ш1.1
и применим универсальное  свойство  свёртки  foldr  для  реализации
функции takeWhile' в стиле Haskell-оригами.
   Сопоставив  1универсальное свойство свёртки 0 foldr
 ш1.0

    3g 0 e []     = e            <=>  3g 0 = foldr f e
    3g 0 e (x:xs) = f x ( 3g 0 e xs)
         
с рекурсивным определением функции takeWhile'
   
   takeWhile' p [] = []
   takeWhile' p (x:xs) = if (not . p) x
                           then []
                           else x : takeWhile' p xs,

 ш1.1
получим, что  3g 0 e = takeWhile' p,  e = [], т.е. приходим к необходи-
мости решения эквационального уравнения:
 ш1.0

   takeWhile' p (x:xs)        = f x (takeWhile' p xs);

   if (not . p) x
     then []
     else x : takeWhile' p xs = f x (takeWhile' p xs),
                                            ys ═+ 0takeWhile' p xs;
   if (not . p) x
     then []
     else x : ys              = f x ys

 ш1.1
   Отсюда
 ш1.0

   f x ys = if (not . p) x then [] else x : ys,

   takeWhile' p = foldr f e
          where f x ys = if (not . p) x then [] else x : ys
                e      = []

 ш1.2
    2Пример 0  26 0 [Hutton,1999].
 ш1.1
   Рассмотрим задачу  суммирования  элементов  заданного  числового
списка, решением которой является функция
 ш1.0

   sum = foldr (+) 0,

 ш1.1
   Реализуем функцию suml, обрабатывающую список в направлении  1сле-
 1ва направо 0 и использующую вспомогательную рекурсивную функцию suml'
с  1накапливающим параметром 0 n:
 ш1.0

   suml xs = suml' xs 0
        where suml'  1   0[] 1   0 n = n
              suml' (x:xs) n = suml' xs (n + x)

 ш1.1
   Применение функции suml вместо функции sum может оказаться более
рациональным, т.к. её можно легко модифицировать [Bird,1998].
   Теперь предположим,  что требуется переопределить функцию suml с
использованием свёртки foldr. Для этого воспользуемся вспомогатель-
ной функцией:
 ш1.0

   suml':: [Int] -> (Int -> Int),

 ш1.1
которая может быть переопределена напрямую с помощью свёртки.
   Применяя свойство универсальности свёртки,  получаем,  что соот-
ношение
 ш1.0

   suml' = foldr f v

эквивалентно следующим двум соотношениям:

   suml' []     = v
   suml' (x:xs) = f x (suml' xs)

 ш1.1
   Из первого соотношения получаем, что
 ш1.0

   v 1  0= 1  0id;

из второго соотношения выведем определение для f:

   suml' (x:xs)            = f x (suml' xs);
   suml' (x:xs) n          = f x (suml' xs) n;
   suml' xs (n + x)        = f x (suml' xs) n;
   g (n + x)               = f x g n,         g ═+ 0suml' xs;
   \x g -> (\n -> g (n+x)) = f

 ш1.1
   Докажите самостоятельно, что
 ш1.0

   f = flip (.) . (+)

 ш1.1
   Применяя свойство универсальности foldr, получаем:
 ш1.0

   suml' = foldr (\x g -> (\n -> g (n + x))) id

 ш1.1
   Полученное определение показывает,  что suml' обрабатывает  спи-
сок, заменяя пустой список [] функцией id, а каждый конструктор (:)
функцией,  которая берёт число x и функцию g, а возвращает функцию,
которая  берёт  значение  n  из аккумулятора и возвращает результат
применения g к новому значению аккумулятора n + x.
   Заметите, что задание функции, как
 ш1.0

   suml':: [Int] -> (Int -> Int)

невозможно при определении её с использованием свёртки foldr, т.к.

   foldr:: (a -> b -> b) -> b -> [a] -> b.

 ш1.1
   Итак, функция suml переопределена с использованием свёртки:
 ш1.0

   suml xs = foldr (\x g -> (\n -> g (n + x))) id xs 0

 ш1.2
    2Пример 0  27 0 (по [Hutton,1999]).
 ш1.1
   Рассмотрим реализацию  функции  Аккермана,  обрабатывающую   два
списка целых чисел и определяется с использованием  _ 1рекурсии . 0 так:
 ш1.0

   ack:: [Int] -> [Int] -> [Int]
   ack [] ys         = 1 : ys
   ack (x:xs) []     = ack xs [1]
   ack (x:xs) (y:ys) = ack xs (ack (x : xs) ys)

 ш1.1
   Приведённый вариант реализации функции  Аккермана  оперирует  со
списками, представляя  каждое натуральное число n с помощью списка,
содержащего n произвольных чисел.
   Эта функция - классический пример функции, которая в языке прог-
раммирования низкого уровня не является примитивно-рекурсивной.
   Однако, на языке высокого уровня, типа Haskell, функция Аккерма-
на действительно примитивно-рекурсивная (Reynolds, 1985).
   Для того,  чтобы выразить эту функцию,  используя свёртку,  вос-
пользуемся свойством универсальности свёртки foldr.
   Получаем следующее утверждение:
 ш1.0

   ack = foldr f v  <=>  ack []     = v
                         ack (x:xs) = f x (ack xs)

 ш1.1
   Из первого уравнения получаем, что v=(1 :).
   Из второго  уравнения  мы  не сможем получить определение для f,
как делали это раньше.  Необходимо переопределить с  использованием
свёртки функцию ack (x:xs) в левой части второго уравнения.
   С использованием  1универсального свойства свёртки 0 получаем следу-
ющий результат для уравнения:
 ш1.0

   ack (x:xs) []     = w
   ack (x:xs) (y:ys) = g y (ack (x : xs) ys)

 ш1.1
   Из первого уравнения получаем:
 ш1.0

   w = ack xs [1],

из второго получаем:

   ack (x:xs) (y:ys)      = g y (ack (x : xs) ys);
   ack xs (ack (x:xs) ys) = g y (ack (x : xs) ys);
   ack xs zs              = g y zs;
   g                      = \y -> ack xs

 ш1.1
   Итак, используя свойство универсальности свёртки, вычислили
 ш1.0

   ack (x:xs) = foldr (\y -> ack xs) (ack xs [1])

 ш1.1
   На основе полученного результата вычислим определение для f:
 ш1.0

   ack (x:xs)                      2  0= f x (ack xs);
   foldr (\y->ack xs) (ack xs [1]) = f x (ack xs);
   foldr (\y->g) (g [1])           = f x g;
   f                               2  0= \x g -> foldr (\y -> g) (g [1])

 ш1.1
   Теперь дважды применяем свойство универсальности свёртки:
 ш1.0

   ack = foldr (\x g -> foldr (\y -> g) (g [1])) (1 :)

 ш1.2
                  22. 0  3Определение функций с помощью
                      3свёртки 0  3на базе 0  3кортежей
    2Пример 1 0 ( 1использование свёртки для создания кортежей 0).
 ш1.1
   Рассмотрим функцию sumlength,  которая  возвращает   1одновременно
сумму и длину числового списка:
 ш1.0

   sumLen:: [Int] -> (Int,Int)
   sumLen xs = (sum xs, length xs)

 ш1.1
   Определим эту функцию с помощью свёртки,  для чего воспользуемся
определениями функций sum и length с использованием свёртки:
 ш1.0

   sum'    = foldr (+) 0,               =>
   length' = foldr (\_ n -> n + 1) 0

   => sum'    = foldr (\n x -> x + n) 0 =>
      length' = foldr (\n y -> y + 1) 0

   => sumLen = foldr (\n (x,y) -> (x + n, y + 1)) (0,0)

 ш1.1
   Это определение более эффективно, чем первое, т.к. исходный спи-
сок просматривается  _ 1только один раз . 0.

 ш1.2
    3Замечание 0.
 ш1.1
   В алгебре  программ  существует свойство " _ 1бананового соединения . 0"
свёртки (англ.  1"banana split law 0") (Meijer,1992), которое утвержда-
ет,  что любое двойное применение свёртки к одному и тому же списку
может быть заменено  1единственным использованием свёртки 0, генерирую-
щим пару.
   Отметим, что название свойства появилось из-за того, что свёртка
иногда  записывается с использованием "скобок" "(│" и "│)" (напоми-
нающих бананы), а соединяющий их оператор называют  1соединением 0; по-
этому их комбинацию можно назвать  1банановым соединением 0.

 ш1.2
    2Пример 0  22 0 (по [Hutton,1999]).
 ш1.1
   Рассмотрим функционал dropWhile p, последовательно удаляющий на-
чальные элементы из списка, пока они удовлетворяют предикату p:
 ш1.0

   dropWhile:: (a -> Bool) -> [a] -> [a]
   dropWhile p []     = []
   dropWhile p (x:xs) = if p x
                          then dropWhile p xs
                          else x:xs

 ш1.1
   Определим dropWhile с помощью свёртки.
   Используя свойство универсальности, заключаем, что соотношение
 ш1.0

   dropWhile p = foldr  ═f 0 v

эквивалентно следующим равенствам:

   dropWhile p []     = v
   dropWhile p (x:xs) =  ═f 0 x (dropWhile p xs)

 ш1.1
   Из первого получаем, что
 ш1.0

   v = [];

 ш1.1
из второго попытаемся вывести определение для  ═f 0 следующим образом:
 ш1.0

   dropWhile p (x:xs)    =  ═f 0 x (dropWhile p xs);

   if p x
     then dropWhile p xs
     else x:xs           =  ═f 0 x (dropWhile p xs), ys ═+ 0dropWhile p xs;

   if p x
     then ys
     else x:xs           =  ═f 0 x ys

 ш1.1
   Однако последнее равенство не может служить основанием для опре-
деления  ═f 0, т.к. переменная xs отсутствует в правой части.
   Итак, невозможно определить функционал dropWhile, непосредствен-
но используя свёртку.  Поэтому определим  dropWhile  через  свёртку
косвенным  образом  с помощью дополнительного функционала,  который
разбивает на пары результат применения dropWhile к списку:
 ш1.0

   dropWhile':: (a -> Bool) -> [a] -> ([a],[a])
   dropWhile' p xs = (dropWhile p xs, xs)

 ш1.1
   Применяя свойство универсальности, получаем, что соотношение
 ш1.0

   dropWhile' p = foldr  ═f 0 v

эквивалентно следующим соотношениям:

   dropWhile' p []     = v
   dropWhile' p (x:xs) =  ═f 0 x (dropWhile' p xs)

 ш1.1
   Из первого уравнения получаем, что
 ш1.0

   v=([],[]).

 ш1.1
   Из второго уравнения выведем определение для  ═f 0:
 ш1.0

   dropWhile' p (x:xs)          =  ═f 0 x (dropWhile' p xs);

    2( 0dropWhile p (x:xs), x:xs 2) 0   =  ═f 0 x  2( 0dropwhile p xs, xs 2) 0;

    2( 0if p x
      then dropWhile p xs
      else x:xs          ,x:xs 2)
                                =  ═f 0 x  2( 0dropWhile p xs, xs 2) 0;
    2( 0if p x
      then ys
      else x:xs, x:xs 2) 0          =  ═f 0 x  2( 0ys,xs 2)

 ш1.1
   Определение функции   ═f 0  в последней строке уже является коррект-
ным, т.к. все переменные связаны. Итак,
 ш1.0

   dropWhile' p = foldr f v
        where f x (ys,xs) = (if p x then ys else x : xs, x : xs)
              v           = ([], [])

 ш1.1
   Следовательно, функционал dropWhile определяется так:
 ш1.0

   dropWhile p = fst . dropWhile' p.

 ш1.2
    3Замечание 0 (по [Hutton,1999]).
 ш1.1
   Существует  _ 1теорема . 0 (Meertens,1992),  которая утверждает, что лю-
бая функция,  обрабатывающая конечные списки и составляющая пару из
желаемого результата и параметров списка, всегда может быть переоп-
ределена в терминах свёртки.
   Однако, это не всегда бывает выгодно, т.е. рекурсивное определе-
ние функции может оказаться более удобным.
 ш1.2

                 23. 3 Определение примитивной рекурсии
                    3на списках 0  3с помощью свёртки

 ш1.0
                        1... 0  1Деточка,
                        1все мы немножко лошади,
                        1каждый из нас по-своему лошадь.
                           1Маяковский В. Хорошее отношение к лошадям
 ш1.2

   Покажем, что при использовании  1техники составления кортежей 0 каж-
дая функция,  определённая с использованием примитивной рекурсии  и
обрабатывающая списки, может быть определена в терминах свёртки.
   Рассмотрим паттерн рекурсии
 ш1.0

    3h 0 []     = v
    3h 0 (x:xs) = g x ( 3h 0 xs)

 ш1.2
и обобщим  его  до классического паттерна,  называемого  1примитивной
 1рекурсией 0, следующим образом:
 ш1.1
   (1) вводим дополнительный аргумент y для функции  3h 0 (он будет об-
рабатываться новой функцией f), и для функции g:
 ш1.0

    3h 0  _y . []     = f  _y
    3h 0  _y . (x:xs) = g  _y . x ( 3h 0  _y . xs)

 ш1.2
   Попутно заметим,  что с помощью применения свойства  универсаль-
ности свёртки функцию h y можно переопределить так:
 ш1.0

   h y = foldr (g y) (f y);

 ш1.2
   (2) вводим список xs в качестве  дополнительного  аргумента  для
функции g.

 ш1.2
    2Определение 0.
 ш1.1
    2(1) 0  _ 1Примитивной рекурсией . 0 называется следующая схема рекурсии:
 ш1.0

    3h 0 y []     = f y
    3h 0 y (x:xs) = g y x xs ( 3h 0 y xs)

    2(2) 0  _ 1Примитивно-рекурсивной функцией . 0 называется функция 3 h 0.

 ш1.2
    3Замечание 0.
 ш1.1
   Стандартное определение  примитивной  рекурсии  иногда  требует,
чтобы y являлся конечной последовательностью аргументов.

 ш1.2
   Определим примитивную рекурсию в терминах свёртки.
   Рассмотрим уравнение относительно функций f 41 0 и v 41 0:
 ш1.0

    3h 0 y = foldr f 41 0 v 41

 ш1.2
   Найти функции непосредственно не удастся ( 1проверьте это 0!).
   Однако выполним это косвенным образом с помощью новой функции k,
которая разбивает  на   _ 1пары . 0  результат применения h y к списку xs с
самим списком xs, т.е.
 ш1.0

   k y xs = (h y xs, xs)

 ш1.2
   Определим k с использованием свёртки; воспользовавшись свойством
универсальности, получаем, что соотношение
 ш1.0

   k y = foldr f 41 0 v 41

 ш1.2
эквивалентно следующим двум соотношениям:
 ш1.0

   k y []     = v 41
   k y (x:xs) = f 41 0 x (k y xs)

 ш1.2
   Из первого соотношения получаем, что
 ш1.0

   k y [] = (h y [],[]) => v 41 0 = (f y,[]).

 ш1.2
   Из второго соотношения выведем определение для f 41 0 так:
 ш1.0

   k y (x:xs)               = f 41 0 x (k y xs);

    2( 3h 0 y (x:xs),x:xs 2) 0        = f 41 0 x  2( 3h 0 y xs,xs 2) 0;

    2( 0g y x xs (h y xs),x:xs 2) 0 = f 41 0 x  2( 3h 0 y xs,xs 2) 0, z ═+ 3h 0 y xs;

    2( 0g y x xs z,x:xs 2) 0        = f 41 0 x  2( 0z,xs 2)

 ш1.2
   Используя свойство универсальности, получим:
 ш1.0

   k y = foldr f 41 0 v 41
       where f 41 0 x (z,xs) = (g y x xs z,x:xs)
             v 41 0          = (f y,[])

 ш1.2
   Так как это определение удовлетворяет соотношению
 ш1.0

   k y xs = ( 3h 0 y xs,xs),

 ш1.2
то примитивно-рекурсивную функцию  3h 0 определим с использованием  со-
отношения
 ш1.0

    3h 0 y = fst . k y

 ш1.2
   Итак, произвольная примитивно-рекурсивная функция на списках мо-
жет быть переопределена в терминах функции foldr.
    3Замечание 0 ( 1важное 0) (по [Барендрегт,1985]).
 ш1.1
   Использование способа  составления кортежей для определения при-
митивно-рекурсивных функций в терминах  свёртки  является  ключевым
моментом для определения  1функции предшествования 0 succ для  1нумералов
 1Чёрча 0.
 ш1.2

             2Доказательство правильности функциональных
                     2программ с помощью свёртки

 ш1.0
                   1Одни языки создаются для решения задачи, другие -
                   1для доказательства той или иной точки зрения.
                                                              1Д.Ричи
 ш1.2

              3Доказательство эквациональных утверждений
                  3с помощью универсальности свёртки
   Свойство универсальности свёртки может выступать как способ  до-
казательства, при котором можно избежать индуктивных рассуждений.
    2Пример 0 (по [Hutton,1999]).
 ш1.1
   Рассмотрим следующее  1эквациональное утверждение 0,  относящееся  к
функциям  над  числовыми  списками (функция в левой части суммирует
элементы списка, а затем увеличивает результат на единицу):
 ш1.0

   (+ 1) . sum = foldr (+) 1

 ш1.1
   Напомним, что знак "=" в эквациональном утверждении  показывает,
что  эти  функции  всегда возвращают одинаковые результаты,  будучи
применёнными к одному и тому же конечному списку.
   Обозначив
 ш1.0

    3g 0 = (+ 1) . sum, f = (+), v = 1,

получим правую часть свойства универсальности свёртки

    3g 0 = foldr f v

 ш1.1
   Пользуясь свойством универсальности свёртки,  получаем,  что ра-
венство эквивалентно равенствам:
 ш1.0

   ((+ 1) . sum) []     = 1
   ((+ 1) . sum) (x:xs) = (+) x (((+ 1) . sum) xs)

 ш1.2
   Далее, применение композиции и секционирования (частичного  при-
менения функции) даёт
 ш1.0

   sum [] + 1     = 1
   sum (x:xs) + 1 = x + (sum xs + 1)

что очевидно, т.к.

   sum [] = 0, sum (x:xs) = x + sum xs.

 ш1.2
   Доказательство эквационального утверждения закончено.
   Итак, использование индукции в процессе доказательства скрыто  c
помощью универсального свойства свёртки.

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 0  21.
 ш1.0

 ш1.2

    2Пример 0  22.
 ш1.0

 ш1.2

    2Пример 0  23.
 ш1.0

 ш1.2

    2Пример 0  24.
 ш1.0

 ш1.2

    2Пример 0  25.
 ш1.0

 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ
                         21. 3 Свойства свёртки
    21. 0 Пусть  7Х 0 - произвольная ассоциативная бинарная операция.
   Докажите с помощью свойства объединения, что:
 ш1.0

   ( 7Х 0 a) . foldr ( 7Х 0) b = foldr ( 7Х 0) (b  7Х 0 a).

 ш1.2
    _ 1Решение . 0. Воспользуемся свойством объединения:
 ш1.0

   (1) ( 7Х 0 a) b = b  7Х 0 a => b  7Х 0 a = b  7Х 0 a;

   (2) ( 7Х 0 a) ( 7Х 0 x y) = ( 7Х 0) x (( 7Х 0 a) y) => (x  7Х 0 y)  7Х 0 a = x  7Х 0 (y  7Х 0 a).

 ш1.2
    22 0. Докажите,  что рекурсивная функция  abc,  которая  возвращает
правильную дробь по заданной конечной цепной дроби
 ш1.0

   abc [x]    = x
   abc (x:xs) = x + toRational (1 / (abc xs))

допускает следующее представление с помощью свёртки:

   abc' = foldr1 (flip ((.) ((.) (flip (+)) toRational) ((/) 1)))

 ш1.2
                   22. 0  3Функции высшего порядка как
                       3средство доказательства
    21. 0 Докажите, что
 ш1.0

   sum (xs ++ ys) = sum xs + sum ys,

если функция sum определяется следующим образом:

   sum []     = 0
   sum (x:xs) = x + sum xs

 ш1.2
    22. 0 Докажите, что для любой функции f
 ш1.0

   map f (xs ++ ys) = map f xs ++ map f ys,

если функция map определяется следующим образом:

   map f []     = []
   map f (x:xs) = f x : map f xs

 ш1.2
    23. 0 Докажите, что
 ш1.0

   map (f . g) xs = map f (map g xs)

если функция (f . g) является композицией f и g, т.е.

   (f . g) x = f (g x).

 ш1.2
    24. 0 Докажите следующие утверждения:
 ш1.0

   length (concat xs) = sum (map length xs);

   sum (concat xs)    = sum (map sum xs),

если функция concat определяется следующим образом:

   concat []     = []
   concat (x:xs) = x ++ concat xs.

 ш1.2
    25. 0 Докажите, что
 ш1.0

   map f (concat xs) = concat (map f' xs),

 ш1.2
где f' xs = map f xs.
    26. 0 Пусть
 ш1.0

   m :: forall a b. (a -> b) -> [a] -> [b].

   Докажите, что

   m f xs = map f (m id xs) = m id (map f xs),

 ш1.2
где id x = x.
