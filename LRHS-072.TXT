    2ЛАБОРАТОРНАЯ РАБОТА 7 42 2.
    2МОРФИЗМЫ 0  2НА СПИСКАХ: ката-, ана-, хило- и пара-

 ш1.0
                                       1Не я построил этот мир.
                                       1Я в нём скитаюсь, чужд и сир.
                                                         1А.Э.Хаусмен
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Знать . 0:
 ш1.0


    1- 0  1ката-, ана-, хило- и параморфизмы 0  1на списках 0.

 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
    2Определение 0.
 ш1.1
    _ 1Катаморфизм . 0 (от греч.  7kata 0 -  1вниз 0 и  7morfi 0 -  1форма 0),
    _ 1анаморфизм . 0 (от греч.  7ana 0 -  1наверх 0,  1кверху 0),
    _ 1хиломорфизм . 0 (от греч.  7ylos 0 -  1материя 0,  1пыль 0),
    _ 1параморфизм . 0 (от греч.  7para 0 -  1рядом 0) -
- это понятиям  1теории категорий 0,  имеющие непосредственное примене-
ние в функциональном программировании.
   Являются одним из паттернов (базовых  примитивов)  для  описания
рекурсивных функций (в более общем случае - рекурсивных процессов);
используются для представления произвольных рекурсивных функций.

 ш1.2
    2Определение 0.
 ш1.1
    7W 0- _ 1морфизмами . 0 будем называть множество  1морфизмов 0,  содержащее ка-
та-, ана-, хило- и параморфизмы, т.е.  7Wе 0{cata,ana,hilo,para}.

 ш1.2
    _ 1Соглашения об обозначениях . 0.
 ш1.1
    21. 0 Нотацией для записи  1cata f 0 является (│f│), где символы "(│" и
"│)" называются  1банановыми скобками 0 (англ.   1bananas 0); поэтому ката-
морфизмы называются  _ 1бананами . 0).
    22. 0 Нотацией для записи  1ana f 0 является [(f)],  где символы "[(" и
")])" называются  1линзовыми скобками 0 (англ.  1lenses 0 -  1линзы 0); поэтому
анаморфизмы называются  _ 1линзами . 0).
    23. 0 Нотацией для записи  1hilo f 0 является [[f]], где символы "[[" и
"]]" называются   1конвертами 0 (англ.   1envelopes 0 -  1конверты 0);  поэтому
хиломорфизмы называются  _ 1конвертами . 0.
    24. 0 Нотацией для записи  1para f 0 является  ═< 0│f│ ═> 0, где символы " ═< 0│" и
"│ ═> 0" называются  1колючкой 0 (англ.  1barbed wire 0 -  1колючая проволока 0).

 ш1.2
   В функциональном программировании описываемые понятия  использу-
ются:
 ш1.1
   (1) для повышения эффективности вычислений;
   (2) в процессе кодогенерации;
   (3) в механизме вывода типов (например,  в рамках модели  стати-
ческой типизации Хиндли-Милнера).

 ш1.2
   Однако, принимая во внимание высокую степень  абстракции  теории
категорий, эти  понятия применяются в тех областях научного знания,
где имеется необходимость в применении примитивов для рекурсии.
    7W 0-морфизмы описываются указанием следующих свойств:
 ш1.1
   (1)  _ 1правила вычислений . 0 (англ.   1evaluation rule 0) - правила вычис-
ления значения  7W 0-морфизма (например,  для  7W 0-морфизмов на списках  -
это рекурсивная схема, определяющая  7W 0-морфизм);
   (2)  _ 1свойства универсальности . 0 (англ.   1uniqueness property 0) -  ут-
верждения, позволяющего доказывать равенство двух функций (в интен-
сиональном смысле) без использования рекурсии;
   (3)  _ 1свойства объединения . 0 (англ.   1fusion law - свойство объедине-
 1ния 0,   1свойство слияния 0) - утверждения о том, что композиция некото-
рой функции и  7W 0-морфизма представляет собой  7W 0-морфизм.

 ш1.2
    3Замечание 0.
 ш1.1
   Одна из первых публикаций на эту тему в контексте программирова-
ния   1являлась 0  статья  [Meijer,Fokkinga,Paterson,1991],  в  которой
рассматриваемые ниже понятия описываются с помощью  _ 1Squiggol . 0  -  ис-
числения,  предназначенного  для  вывода функциональных программ из
заданной спецификации.
 ш1.2

                     21. 3 Катаморфизмы на списках

 ш1.0
                                      1... ad usum internum
                                     ( 1для внутреннего употребления 0)
 ш1.2

   Вспомним, что катаморфизм на списках "дробит",  разрушает струк-
туру данных, преобразовывая её в некоторое значение.

                                ...


    3Замечание 0.
 ш1.1
   В функциональном программировании  _ 1катаморфизм . 0  определяется  как
обобщённая свёртка над алгебраическими структурами данных.

 ш1.2
                22. 0  3Конструирование катаморфизмов 0  3для
                     3алгебраических типов 0  3данных
   В функциональном программировании катаморфизм является обобщени-
ем функционала " 1свёртка на списках 0" на произвольные   1алгебраические
 1типы  данных 0  (А 4лг 0ТД),  что  описывается с помощью  _ 1начальных алгебр
(понятие  1теории категорий 0).
    2Определение 0 ( 1повторение 0).
 ш1.1
    _ 1Алгебраический тип данных . 0 (А 4лг 0ТД) - это размеченное  объединение
декартовых произведений различных типов (в том числе сам такой  тип
может включаться в своё определение рекурсивно).
   Каждому декартову  произведению  в  языке  Haskell соответствует
один  _ 1конструктор данных . 0,  после которого перечисляются 0 или  более
полей некоторых типов.
   Все конструкторы  данных объединяются с помощью  _ 1конструктора ти-
 _ 1пов . 0. Каждый конструктор типа может содержать в своей записи  исход-
ный  алгебраический тип данных (такие конструкторы обозначаются  ═r 4i 0,
от слова " 1рекурсивный 0"), либо может не содержать (такие конструкто-
ры обозначаются  ═c 4i 0, от слова " 1конструктор 0").
   Итак, произвольный  _ 1алгебраический тип данных . 0 с именем  конструк-
тора типа T определяется следующим образом:
 ш1.0

   data T a 41 0 a 42 0 ... a 4n 0

        =   ═c 41  0a 411  0a 412  0... 4  0a 41k
         |  7777 0   7777 0    7777
         |  ═c 4j 0 a 4j1  0a 4j2  0... 4  0a 4jk

         |  ═r 41 0 b 411 0 b 412 0 ... b 41m 0 (T a 41 0 a 42 0 ... a 4n 0) ... (T a 41 0 a 42 0 ... a 4n 0)
         |  7777 0   7777 0    7777
         |  ═r 4i 0 b 4i1 0 b 4i2 0 ... b 4im 0 (T a 41 0 a 42 0 ... a 4n 0) ... (T a 41 0 a 42 0 ... a 4n 0)

 ш1.2
   Теперь (только для удобства!) построим  по заданному А 4лг 0ТД  _ 1сино-
 _ 1ним типа для представления алгебры . 0,  который содержит  1кортеж типов 0,
количество которых равно общему количеству конструкторов данных ти-
па T:
 ш1.0

   type TAlgebra a 41 0 a 42 0 ... a 4n 0 r =
                 7( 0 (
                 72 0   a 411  0-> a 412  0->  7777 0 -> 4  0a 41k 0 -> r,
                 72 0      7777         777         777
    1Кортеж типов 0  7* 0   a 4j1 0 -> 4  0a 4j2  0->  7777 4  0-> a 4jk 0 -> r,
                 72 0   b 411 0 -> b 412 0 -> ... -> b 41m 0 -> r ->  7777 0 -> r -> r,
                 72 0      7777         777 0          7777 0     7777
                 72 0   b 4i1 0 -> b 4i2 0 -> ... -> b 4im 0 -> r ->  7777 0 -> r -> r
                 79 0 )

 ш1.2
   В этом кортеже:
 ш1.1
   (1) каждому конструктору данных  ═c 4j 0 соответствует тип функции f 4j 0,
которая принимает на вход аргументы типов, собранные в соответству-
ющем конструкторе  ═c 4j 0; типом результата для функции f 4j 0 является r;
   (2) для  каждого конструктора  ═r 4i 0 в кортеже представлен тип неко-
торой функции g 4i 0,  определяемый так:  для простых типов a 4n 0 аргумент
функции должен иметь как раз этот тип, но для рекурсивных типов
 ш1.0

   T a 41 0 a 42 0 ... a 4n

 ш1.1
типом аргумента является r; типом результата для функции g 4i 0 являет-
ся также r.

 ш1.2
   Наконец, автоматически строится тип функции " 1катаморфизм 0", кото-
рую обозначим  2foldT 0, с помощью заданного А 4лг 0ТД и созданного синони-
ма типов:
 ш1.0

   ┌──────────────────────────────────────────────────────────────┐
   │ 2foldT 0 :: TAlgebra a 41 0 a 42 0 ... a 4n 0 r -> TAlgebra a 41 0 a 42 0 ... a 4n 0 -> r│
   └──────────────────────────────────────────────────────────────┘

 ш1.2
                      23. 3 Анаморфизмы на списках
   Анаморфизм - это операция,  порождающая сложную структуру из на-
чального значения a -> t b c помощью:
   (1) предиката (a -> Bool);
   (2) генератора полей конструктора (кроме рекурсивных - b);
   (3) нового начального значения (a -> (a,...)).

    2Примеры 0 ( 1анаморфизмов на списках 0).
 ш1.1
   Функция unfoldr
   Функция scanl

 ш1.2
   Итак, в  языке программирования Haskell катаморфизм и анаморфизм
- это обобщения функционалов foldr (свёртка) и unfoldr  (развёртка)
на произвольные  1алгебраические типы данных 0,  что может быть описано
при помощи  _ 1терминальных коалгебр . 0 (термин  1теории категорий 0).
    3Замечания 0.
 ш1.1
    21. 0 В  случае  списков  катаморфизм  оказывается  свёрткой  foldr
(foldr1, foldl, foldl1), а анаморфизм - развёрткой unfold.
    22. 0 В  теории  категорий  1анаморфизм 0 является дуальной (двойствен-
ной) сущностью к катаморфизму.

 ш1.2
                     24. 3 Хиломорфизмы на списках
   Понятие " 1хиломорфизм 0" для алгоритма, состоящего из свёртки, сле-
дующей за развёрткой, ввёл Э.Мейджер ( 1E.Meijer 0).
    2Определение 0 (по [Gibbons,2003,p.48]).
 ш1.0

    3hylo 0 f e p g h x = if p x
                        then e
                        else f (g x) ( 3hylo 0 f e p g h (h x)).

 ш1.2
   Хиломорфизм представляет собой композицию анаморфизма и катамор-
физма.
   Развёртка порождает  структуру  данных,  а свёртка поглощает её.
Эта промежуточная структура может быть исключена из вычислительного
процесса, что называется  _ 1усечением . 0 (англ.  1deforestation 0). В резуль-
тате получается шаблон (паттерн)  рекурсивного  алгоритма,  который
подходит для большинства случаев, встречающихся на практике.
   Этот паттерн называется  _ 1хиломорфизмом . 0.
   Тем, не менее, промежуточная структура совсем не бесполезна. Она
соответствует 1  дереву рекурсивных вызовов 0 хиломорфизма и может быть
положена в основу альтернативной, иногда более быстрой его реализа-
ции. Ускорение происходит,  когда дерево вызовов содержит разделяе-
мые узлы,  т.е.  те, которые имеют более одной входящей дуги. Такое
дерево называется  _ 1нексус . 0, оно появляется в любом рекурсивном вычис-
лении, где рекурсивно решаемые подзадачи имеют пересечения.
   Типичным примером  здесь  могут  служить алгоритмы динамического
программирования.
    2Теорема 0 ( 1устранение свёртки и развёртки, deforestation 0)
           (по [Gibbons,2003,p.48]).
 ш1.0

    3hylo 0 f e p g h = foldr f e . unfold p g h

   [[(e,f),((g,h),p)]] = (│e,f│) . [((g,h),p)]

 ш1.2
    3Замечание 0.
 ш1.1
   Иногда используется следующий паттерн:
 ш1.0

   unfold p g h . foldr f e

 ш1.2
   Итак,  3hylo 0 f e p g h после  _ 1усечения . 0 имеет рекурсивный вид:
 ш1.0

    3hylo 0 f e p g h x = if p x
                        then e
                        else f (g x) ( 3hylo 0 f e p g h (h x)).

 ш1.2
   В частности, факториал описывается как хиломорфизм следующим об-
разом (на языке программирования Haskell):
 ш1.0

   fact = 3 hylo 0 (*) 1 (==0) id pred

   foldr (*) 1 . unfold (<=1) id succ
    ═└ 0──── ═┬ 0──── ═┘ 0    ═└ 0──────── ═┬ 0───────── ═┘
     (│1,*│)      [((id,succ),(<=1))]

 ш1.2
   Функция "факториал"  названа   1архетипическим   хиломорфизмом 0   в
статье [Meijer,Fokkinga,Paterson,1991].
                     25. 3 Параморфизмы на списках
   Параморфизм используется  для  реализации   1примитивной  рекурсии
(это фактически усложненный функционал fold, параметру которого пе-
редаётся ещё и сам список, а не только его "голова").
    2Определение 0 (по [Gibbons,2003,p.44]).
 ш1.0

    3para 0 f e []     = e
    3para 0 f e (x:xs) = f x (xs, 3para 0 f e xs)

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   Во втором разделе статьи [Meijer,Fokkinga,Paterson,1991] имеется
 _ 1ошибка . 0:  в самом конце при описании параморфизма (скобки  -  "колю-
чие", т.е. " ═< 0│" и "│ ═> 0"):
 ш1.0

   tails= ═< 0│Cons(Nil,Nil), 7Х 0│ ═> 0,

   a 7Х 0(as,tls)=Cons(Cons(a,as),tls).

 ш1.1
   Это неверно,  потому что возвращает только первый tail (сам спи-
сок), а не сохраняет последующие. Необходимо писать:
 ш1.0

   a 7Х 0(as,tls) = Cons(Cons(a,as),Cons(as,tls)).

 ш1.2
    3Замечание 0.
 ш1.1
   Итак, хиломорфизм - это обобщение анаморфизма, параморфизм - ка-
таморфизма. Разница - в использовании функций вместо конструкторов.
 ш1.2

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 0  21.
 ш1.0

 ш1.2

    2Пример 0  22.
 ш1.0

 ш1.2

    2Пример 0  23.
 ш1.0

 ш1.2

    2Пример 0  24.
 ш1.0

 ш1.2

    2Пример 0  25.
 ш1.0

 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ
