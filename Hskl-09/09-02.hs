   -- Демонстрация:
   --  (1) моделирования комбинатора неподвижной точки
   --      на языке Haskell;
   --  (2) использования комбинатора  неподвижной точ-
   --      ки для моделирования рекурсивных вычислений
   -- ************************************************
   -- Функция, моделирующая комбинатор неподвижной
   -- точки Y по определению:
   --
   --   Yf=f(Yf)
   -------------
   y f = f (y f)

   -- ****************************************************
   -- Демонстрация моделирования рекурсии в языке Haskell,
   -- основанного на теореме о неподвижной точке:
   -- для любого терма F если x=Fx, то x=YF
   -- ***********************************************
   -- Пример 1. Рассмотрим нерекурсивный комбинатор z
   --------------------------------------------------
   z = \x -> x+1              -- z x = x + 1
   -----------------------------------------------------
   --           По комбинатору z построим функционал z':
   -----------------------------------------------------
   z' = \f1 -> \x -> x + 1    -- z' f1 x = x + 1

   --------------------------------------------------------
   -- Пример 2. Рассмотрим в качестве функции F рекурсивную
   --           функцию, вычисляющую факториал числа x
   ---------------------------------------------------
   fct:: Num a => a -> a
   fct x | x==1 = 1
         | True = x * fct (x - 1)
   -----------------------------------------------------
   --           По функции fct построим функционал fct':
   -----------------------------------------------------
   fct':: Num a => (a -> a) -> a -> a
   fct' f1 x | x==1 = 1
             | True = x * f1 (x - 1)

   --------------------------------------------------------
   -- Пример 3. Рассмотрим в качестве функции F рекурсивную
   --           функцию, вычисляющую факториал числа x
   ---------------------------------------------------
   fct1 = \x -> if x==0 then 1 else x * fct1 (x - 1)
   ----------------------------------------------------------
   --           По комбинатору fct1 построим функционал fct':
   ----------------------------------------------------------
   fct1' = \f1 -> \x -> if x==0 then 1 else x * f1 (x - 1)

   ---------------------------------------------
   -- Пример 4. Проведём аналогичные манипуляции
   --           с функционалом map'
   --------------------------------
   map':: (a -> b) -> [a] -> [b]
   map' f []     = []
   map' f (x:xs) = f x : map' f xs
   -----------------------------------------------------------
   --           По функционалу map' построим функционал map'':
   -----------------------------------------------------------
   map'':: ((a -> b) -> [a] -> [b]) -> (a -> b) -> [a] -> [b]
   map'' f1 f []     = []
   map'' f1 f (x:xs) = f x : f1 f xs

   ---------------------------------------------
   -- Пример 5. Проведём аналогичные манипуляции
   --           с функционалом filter'
   -----------------------------------
   filter':: (a -> Bool) -> [a] -> [a]
   filter' p []     = []
   filter' p (x:xs) | p x  = x : filter' p xs
                    | True = filter' p xs
   -------------------------------------------------------
   --           По функционалу filter' построим функционал
   --           filter'':
   -----------------------------------------------------
   filter'':: ((a -> Bool) -> [a] -> [a]) -> (a -> Bool)
                           -> [a] -> [a]
   filter'' f1 p []     = []
   filter'' f1 p (x:xs) | p x  = x : f1 p xs
                        | True = f1 p xs

   --------------------------------------------------------
   -- Пример 6. Реализация бесконечного циклического списка
   --           с использованием комбинатора Y
   -------------------------------------------
   l lst = y (\x -> lst ++ x)

   --------------------------------------------------
   -- Пример 7. Использование комбинатора неподвижной
   --           точки в сложной рекурсии
   -------------------------------------
   fibb:: Integer -> Integer
   fibb 0     = 1
   fibb 1     = 1
   fibb (n+1) = fibb n + fibb (n-1)
   --------------------------------
   fibb' g 0     = 1
   fibb' g 1     = 1
   fibb' g (n+1) = g n + g (n-1)

   -- ***************************
   -- Неудачные тестовые примеры:
   ---------------------------------------------------------
   test1 = y z' 12 == 13      -- y z' 12 = z' (y z') 12 = 13
   -----------------------------------------------------------------
   test2 =   fct 10                 ==                  y fct'    10 
          && y             fct'   10==fct'             (y fct')   10   
          && fct'       (y fct')  10==fct'       (fct' (y fct'))  10
          && fct' (fct' (y fct')) 10==fct' (fct' (fct' (y fct'))) 10
   -----------------------------------------------------------------
   test3 = y fct1' 1500 == product [1..1500]
   -----------------------------------------------
   test4 = y map'' (^2) [1..5] == map' (^2) [1..5]
   test5 = y map'' sin [1..7]  == map' sin [1..7]
   ----------------------------------------------
   test6 = y filter'' (>0) [1,-1,2,-2,3,-3]
           == filter' (>0) [1,-1,2,-2,3,-3]
   test7 = (take 10 $ l [1,2,3], take 10 $ l [1])
   ----------------------------------------------
   test8 = (fibb 20,y fibb' 20)
   ----------------------------------------------------------
   -- Внимание! Применение комбинатора y к постоянной функции
   -- не требует указания аргумента:
   --
   -- y (\x -> 4) = (\x -> 4) (y (\x -> 4)) = 4
   --------------------------------------------
   test9 = y (\x -> 4) 
